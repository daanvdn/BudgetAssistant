{
    "pipes": [
        {
            "name": "IbanPipe",
            "id": "pipe-IbanPipe-b249beccbe005f5f9e91bf0cf435f1b5d2e71bbae8d9300621052ad9d41b036b683e9ff65b77bf9958b510126c824f7a7769848dbadc8fc9a8bc226f69d34bbb",
            "file": "src/app/iban.pipe.ts",
            "type": "pipe",
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "properties": [],
            "methods": [
                {
                    "name": "transform",
                    "args": [
                        {
                            "name": "value",
                            "type": "",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "args",
                            "type": "[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "dotDotDotToken": true
                        }
                    ],
                    "optional": false,
                    "returnType": "",
                    "typeParameters": [],
                    "line": 9,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "args",
                            "type": "[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "dotDotDotToken": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "standalone": true,
            "ngname": "iban",
            "sourceCode": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n    name: 'iban',\n    standalone: true\n})\nexport class IbanPipe implements PipeTransform {\n\n  transform(value: unknown, ...args: unknown[]): unknown {\n    if (typeof value !== 'string') {\n      return value;\n    }\n    return value.replace(/(.{4})/g, '$1 ').trim();\n  }\n\n}\n"
        }
    ],
    "interfaces": [
        {
            "name": "BankAccount",
            "id": "interface-BankAccount-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "accountNumber",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 290
                },
                {
                    "name": "alias",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 291
                },
                {
                    "name": "editAlias",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 292
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "BudgetTrackerResult",
            "id": "interface-BudgetTrackerResult-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "columns",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 310
                },
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BudgetTrackerResultNode[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 309
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "BudgetTrackerResultNode",
            "id": "interface-BudgetTrackerResultNode-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "children",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BudgetTrackerResultNode[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 303
                },
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Record<string | any>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 302
                },
                {
                    "name": "leaf",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 304
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "BudgetTreeNode",
            "id": "interface-BudgetTreeNode-ab5802e1347f1b484d762ed6e73a59f110ab93d7f293d3abc926c94b10090e9aaed528e4bcd7224404a36df227182a0c26149eedd0309c7062054dec8e0225ba",
            "file": "src/app/budget/budget.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport {FlatTreeControl} from \"@angular/cdk/tree\";\nimport {MatTreeFlatDataSource, MatTreeFlattener} from \"@angular/material/tree\";\nimport {\n  AbstractControl,\n  FormBuilder,\n  FormControl,\n  FormGroup,\n  FormGroupDirective,\n  FormsModule,\n  NgForm,\n  ReactiveFormsModule,\n  ValidatorFn\n} from \"@angular/forms\";\nimport {ErrorStateMatcher} from '@angular/material/core';\nimport {MatDialog} from \"@angular/material/dialog\";\nimport {SaveErrorDialogComponent} from \"./save-error-dialog/save-error-dialog.component\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {MatButton, MatIconButton} from '@angular/material/button';\nimport {MatIcon, MatIconModule, MatIconRegistry} from '@angular/material/icon';\nimport {NgClass, NgIf} from '@angular/common';\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from '@angular/material/table';\nimport {MatError, MatFormField} from '@angular/material/form-field';\nimport {MatInput} from '@angular/material/input';\n\nexport interface BudgetTreeNode {\n  budgetTreeNodeAmount: number;\n  budgetTreeNodeId: number;\n  budgetTreeNodeParentId: number;\n  children: BudgetTreeNode[];\n  name: string;\n  qualifiedName: string;\n}\n\nexport class FlatBudgetTreeNode {\n  level!: number;\n  expandable!: boolean;\n  name!: string;\n  qualifiedName!: string;\n  budgetTreeNodeId!: number;\n  budgetTreeNodeAmount!: number;\n  budgetTreeNodeParentId!: number;\n}\n\n\n\nexport interface FindOrCreateBudgetResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n  budgetTreeNodes: BudgetTreeNode[];\n  numberOfBudgetTreeNodes: number;\n\n}\n\nexport interface UpdateBudgetEntryResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n\n\n}\n\n\nexport class MyErrorStateMatcher implements ErrorStateMatcher {\n  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid);\n  }\n}\n\n\n@Component({\n    selector: 'app-budget',\n    templateUrl: './budget.component.html',\n    styleUrls: ['./budget.component.scss'],\n    standalone: true,\n  imports: [MatToolbar, BankAccountSelectionComponent,\n    MatButton, MatIcon, NgIf, FormsModule, ReactiveFormsModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell,\n    MatCellDef, MatCell, MatIconButton, MatFormField, MatInput, MatError, MatHeaderRowDef,\n    MatHeaderRow, MatRowDef, MatRow, NgClass, MatIconModule, MatIcon],\n\n})\nexport class BudgetComponent implements OnInit {\n  TOTAL_NODE_ID: number = -1;\n  TOTAL_NODE_CATEGORY_NAME = 'Totaal';\n\n  totalBudget: number = 0;\n\n  matcher = new MyErrorStateMatcher();\n\n\n  /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n  idToNodeMap = new Map<number, BudgetTreeNode>();\n\n  /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n  nestedNodeMap = new Map<BudgetTreeNode, FlatBudgetTreeNode>();\n\n  qualifiedNameToNodeMap = new Map<string, BudgetTreeNode>();\n\n  treeControl!: FlatTreeControl<FlatBudgetTreeNode>\n  dataSource!: MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>;\n\n\n  treeFlattener: MatTreeFlattener<BudgetTreeNode, FlatBudgetTreeNode>;\n\n  displayedColumns: string[] = ['category', 'budget', 'yearlyBudget'];\n\n  rowsToHighlight: Set<number> = new Set<number>();\n\n  idToControlsMap: Map<number, FormControl> = new Map<number, FormControl>();\n  controlsToIdMap: Map<FormControl, number> = new Map<FormControl, number>();\n  allControls: FormControl[] = [];\n  mainForm: FormGroup;\n  idToBudgetNodeMap: Map<number, BudgetTreeNode> = new Map<number, BudgetTreeNode>();\n  currentSubTreeHasError: boolean = false;\n  isTreeExpanded = true;\n\n\n  constructor(private appService: AppService, private fb: FormBuilder, public dialog: MatDialog\n  ) {\n\n    this.mainForm = this.fb.group({});\n\n    this.treeFlattener = new MatTreeFlattener(\n      this.transformer,\n      this.getLevel,\n      this.isExpandable,\n      this.getChildren\n    );\n    this.treeControl = new FlatTreeControl<FlatBudgetTreeNode>(\n      this.getLevel,\n      this.isExpandable\n    );\n    this.dataSource = new MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>(\n      this.treeControl,\n      this.treeFlattener\n    );\n\n\n\n  }\n\n\n  transformer = (node: BudgetTreeNode, level: number) => {\n    const existingNode = this.nestedNodeMap.get(node);\n    const flatNode =\n      existingNode && existingNode.qualifiedName === node.qualifiedName\n        ? existingNode\n        : new FlatBudgetTreeNode();\n    flatNode.name = node.name;\n    flatNode.qualifiedName = node.qualifiedName;\n    flatNode.level = level;\n    flatNode.expandable = (node.children != undefined && node.children.length > 0);\n    flatNode.budgetTreeNodeAmount = node.budgetTreeNodeAmount;\n    flatNode.budgetTreeNodeId = node.budgetTreeNodeId;\n    flatNode.budgetTreeNodeParentId = node.budgetTreeNodeParentId;\n    this.idToNodeMap.set(node.budgetTreeNodeId, node);\n\n    this.nestedNodeMap.set(node, flatNode);\n    this.qualifiedNameToNodeMap.set(node.qualifiedName, node);\n    return flatNode;\n  };\n\n  getLevel = (node: FlatBudgetTreeNode) => node.level;\n\n  isExpandable = (node: FlatBudgetTreeNode) => node.expandable;\n\n  getChildren = (node: BudgetTreeNode): BudgetTreeNode[] => node.children;\n\n  hasChild = (_: number, _nodeData: FlatBudgetTreeNode) => _nodeData.expandable;\n\n  inputChanged: boolean = false;\n  dataLoaded: boolean = false;\n  isSaved: boolean = false;\n\n\n  getRowClass(data: FlatBudgetTreeNode): string {\n    if (data.name === this.TOTAL_NODE_CATEGORY_NAME) {\n      return 'highlight-total-row';\n    }\n    if (this.currentSubTreeHasError && this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-error';\n    }\n    if (this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-no-error';\n    }\n    return '';\n  }\n\n\n  ngOnInit(): void {\n    this.appService.selectedBankAccountObservable$.subscribe(selectedAccount => {\n      if (selectedAccount) {\n        this.appService.findOrCreateBudget(selectedAccount).subscribe((response: BudgetTreeNode[]) => {\n\n          let filteredData = response.filter(node => node.name !== 'NO CATEGORY' && node.name !== 'DUMMY CATEGORY');\n          let totalBudgetTreeNode = this.initTotalBudgetTreeNode();\n          filteredData.push(totalBudgetTreeNode);\n          this.dataSource.data = filteredData;\n          let allBudgetNodes: BudgetTreeNode[] = [];\n          for (const node of response) {\n            if (node.name === 'NO CATEGORY' || node.name === 'DUMMY CATEGORY') {\n              continue;\n            }\n            allBudgetNodes.push(node);\n            this.getAllDescendantsRecursively(node, allBudgetNodes);\n          }\n\n\n          for (const node of allBudgetNodes) {\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            let control = new FormControl<number>(node.budgetTreeNodeAmount, [this.budgetValidator(), this.negativeNumberValidator()]);\n            this.idToControlsMap.set(node.budgetTreeNodeId, control);\n            control.valueChanges.subscribe((value) => {\n              if ((value !== undefined)) {\n                // this.inputChanged = false;\n                this.validateAllControls();\n                this.calculateTotalBudget();\n\n                let flatNode = this.nestedNodeMap.get(node);\n                if (flatNode){\n                  if (flatNode.name === this.TOTAL_NODE_CATEGORY_NAME) {\n                    //we don't want to do anything when the total node is changed\n                    return;\n                  }\n                  this.determineSubTreeForNode(flatNode as FlatBudgetTreeNode);\n                  if (!this.currentSubTreeHasError){\n                    this.onBudgetChange(flatNode as FlatBudgetTreeNode);\n                  }\n                }\n              }\n            });\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            this.controlsToIdMap.set(control, node.budgetTreeNodeId);\n            this.allControls.push(control);\n            this.mainForm.addControl(node.budgetTreeNodeId.toString(), control);\n          }\n          this.calculateTotalBudget();\n          this.dataLoaded = true;\n          this.treeControl.expandAll();\n\n        });\n      }\n    });\n\n  }\n\n  getDescendantIds(node: BudgetTreeNode, allDescendantIds: number[]) {\n    if (node.children && node.children.length > 0) {\n      node.children.forEach(child => {\n        allDescendantIds.push(child.budgetTreeNodeId);\n        this.getDescendantIds(child, allDescendantIds);\n      });\n    }\n  }\n\n  validateAllControls() {\n    Object.keys(this.mainForm.controls).forEach(key => {\n      const control = this.mainForm.get(key);\n      if (control) {\n        control.updateValueAndValidity({onlySelf: false, emitEvent: false});\n\n      }\n    });\n    this.mainForm.markAllAsTouched();\n  }\n\n  budgetValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isLessThanSumOfDescendants = this.isLessThanSumOfDescendants(control as FormControl);\n      return isLessThanSumOfDescendants ? {'isLessThanItsDescendants': {value: control.value}} : null;\n    };\n  }\n\n  negativeNumberValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isNegative = control.value < 0;\n      return isNegative ? {'negativeNumber': {value: control.value}} : null;\n    };\n  }\n\n  isLessThanSumOfDescendants(control: FormControl): boolean {\n    let nodeId = this.controlsToIdMap.get(control);\n    if (!nodeId) {\n      return false;\n    }\n\n    let nodeValue = control.value;\n\n    if (nodeValue == undefined || nodeValue < 0) {\n      return false;\n    }\n    let sumOfDescendants = 0;\n\n    let payload = this.idToBudgetNodeMap.get(nodeId) as BudgetTreeNode;\n    let allDescendantIds: number[] = [];\n    this.getDescendantIds(payload, allDescendantIds);\n\n    for (const descendantId of allDescendantIds) {\n      let descendantValue = this.idToControlsMap.get(descendantId)?.value;\n      if (descendantValue) {\n        sumOfDescendants = sumOfDescendants + descendantValue;\n\n      }\n    }\n\n\n    let isLessThanSumOfDescendants = nodeValue < sumOfDescendants;\n    //unpacking boolean for debugging purposes\n    return isLessThanSumOfDescendants;\n\n  }\n\n\n  determineSubTreeForNode(data: FlatBudgetTreeNode) {\n    this.rowsToHighlight = new Set<number>();\n    this.currentSubTreeHasError = false;\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n    this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n    if (budgetTreeNode.budgetTreeNodeParentId) {\n      //go one level up the tree to the parent. Add the id of the parent and all its descendants to the set of rows to highlight\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeParentId);\n      let parentBudgetTreeNode = this.idToNodeMap.get(budgetTreeNode.budgetTreeNodeParentId);\n      if (parentBudgetTreeNode == undefined) {\n        return;\n      }\n\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(parentBudgetTreeNode, allDescendantIds);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n\n\n\n    } else {\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(budgetTreeNode, allDescendantIds);\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n    }\n    this.currentSubTreeHasError = this.anyFormControlIsInvalid(this.rowsToHighlight);\n\n\n  }\n\n  private anyFormControlIsInvalid(ids: Set<number>): boolean {\n    let idsArray = [...ids];\n    for (const number of idsArray) {\n      if(this.formControlIsInvalid(number)){\n        return true;\n      }\n    }\n\n    return false;\n\n\n\n\n  }\n\n  private formControlIsInvalid(budgetTreeNodeId: number): boolean {\n    let control = this.mainForm.get(budgetTreeNodeId.toString());\n    if (control) {\n      return control.invalid;\n    }\n    return false;\n  }\n\n\n  /*onBlur() {\n    this.inputChanged = true;\n  }\n\n  onKeyUpEnter(event: Event) {\n    let kbe = event as KeyboardEvent;\n    if (kbe.key === 'Enter') {\n      this.inputChanged = true;\n    }\n  }*/\n\n  getAllDescendantsRecursively(budgetTreeNode: BudgetTreeNode, descendants: BudgetTreeNode[]) {\n    if (budgetTreeNode.children && budgetTreeNode.children.length > 0) {\n      budgetTreeNode.children.forEach(child => {\n        descendants.push(child);\n        this.getAllDescendantsRecursively(child, descendants);\n      });\n    }\n  }\n\n\n\n\n  onBudgetChange(data: FlatBudgetTreeNode): void {\n\n    let budgetControl = this.mainForm.get(data.budgetTreeNodeId.toString()) as FormControl;\n    if (budgetControl == undefined) {\n      return;\n    }\n    if (data.budgetTreeNodeAmount === undefined || data.budgetTreeNodeAmount === null) {\n      data.budgetTreeNodeAmount = 0;\n      budgetControl.setValue(0);\n    }\n\n\n    if (!budgetControl.valid) {\n      return;\n    }\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n\n\n    if (budgetTreeNode.budgetTreeNodeAmount !== budgetControl.value) {\n      budgetTreeNode.budgetTreeNodeAmount = budgetControl.value;\n    }\n\n    this.appService.updateBudgetEntryAmount(budgetTreeNode).subscribe(\n      (\n        response: UpdateBudgetEntryResponse\n      ) => {\n        if (response.response.toLowerCase() !== \"success\") {\n          throw new Error(\"Failed to update budget entry amount\");\n        }\n        // this.recalculateCumulatedAmountsForAllNodes();\n        this.treeControl.expandAll();\n      });\n\n  }\n\n  sameSubTreeAsFocusedBudgetNode(data: FlatBudgetTreeNode): boolean {\n    return this.rowsToHighlight.has(data.budgetTreeNodeId);\n\n  }\n\n\n  /*onInputChange() {\n    this.inputChanged = true\n  }*/\n\n  saveAll() {\n    if (this.mainForm.invalid) {\n      let invalidCategories: BudgetTreeNode[] = [];\n      Object.keys(this.mainForm.controls).forEach(key => {\n        const control = this.mainForm.get(key);\n        if (control && control.invalid) {\n          let node = this.idToNodeMap.get(parseInt(key));\n          if (!node) {\n            throw new Error(\"Failed to find node for id \" + key);\n          }\n          node.budgetTreeNodeAmount = control.value;\n          invalidCategories.push(node);\n\n\n        }\n      });\n      this.dialog.open(SaveErrorDialogComponent, {\n        data: {\n          message: 'Sommige wijzingen kunnen niet worden opgeslaan! Corrigeer de inconsistente budgetbedragen voor onderstaande categorieën en probeer opnieuw:',\n          nodes: invalidCategories\n        }\n      });\n    } else {\n      let budgetTreeNodes = this.dataSource.data;\n      for (const budgetTreeNode of budgetTreeNodes) {\n        if (budgetTreeNode.budgetTreeNodeId === this.TOTAL_NODE_ID) {\n          continue;\n        }\n        let flatNode = this.nestedNodeMap.get(budgetTreeNode);\n        if (!flatNode) {\n          throw new Error(\"Failed to find flat node for budget tree node \" + budgetTreeNode);\n        } else {\n          this.onBudgetChange(flatNode);\n        }\n\n\n      }\n\n\n\n\n\n\n    }\n  }\n\n\n  toggleTree(): void {\n    if (this.isTreeExpanded) {\n      this.treeControl.collapseAll();\n    } else {\n      this.treeControl.expandAll();\n    }\n    this.isTreeExpanded = !this.isTreeExpanded;\n  }\n\n  calculateTotalBudget(): void {\n    this.totalBudget = Array.from(this.idToControlsMap.values()).filter(control => control.valid)\n      .reduce((sum, control) => sum + (control.value || 0), 0);\n    let totalNode = {\n      budgetTreeNodeAmount: this.totalBudget,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n    this.dataSource.data = [totalNode, ...this.dataSource.data.slice(1, this.dataSource.data.length - 1), totalNode];\n    this.mainForm.get(totalNode.budgetTreeNodeId.toString())?.setValue(totalNode.budgetTreeNodeAmount);\n  }\n\n  initTotalBudgetTreeNode(): BudgetTreeNode {\n    return {\n      budgetTreeNodeAmount: 0,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n  }\n\n}\n\n\n",
            "properties": [
                {
                    "name": "budgetTreeNodeAmount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "budgetTreeNodeId",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "budgetTreeNodeParentId",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "children",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BudgetTreeNode[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "qualifiedName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "Category",
            "id": "interface-Category-e168bf21321adc90ae9c3bf77f337ffe9eca6e61b6b27cf2e762cd27d58c8793f768f74f7193609e8f59413c570689d2cfc43cb589970de84724ebc82bacb233",
            "file": "src/app/category-details/category-details.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {Component, Input, OnChanges, OnInit, SimpleChanges} from '@angular/core';\nimport {Dataset} from \"../model\";\nimport {AppService} from \"../app.service\";\nimport ChartDataLabels from \"chartjs-plugin-datalabels\";\nimport {Observable} from \"rxjs\";\nimport {MatListOption, MatSelectionList, MatSelectionListChange} from \"@angular/material/list\";\n// @ts-ignore\nimport autocolors from 'chartjs-plugin-autocolors';\nimport {\n    BankAccount,\n    ExpensesRecurrenceEnum,\n    RevenueExpensesQuery,\n    RevenueRecurrenceEnum,\n    TransactionTypeEnum\n} from \"@daanvdn/budget-assistant-client\";\n\nimport {Criteria} from \"../model/criteria.model\";\nimport {NgFor, NgIf} from '@angular/common';\nimport {ChartModule} from 'primeng/chart';\n\n\ninterface Category {\n    name: string;\n    transactionType: TransactionTypeEnum;\n\n}\n@Component({\n    selector: 'category-details',\n    templateUrl: './category-details.component.html',\n    styleUrls: ['./category-details.component.scss'],\n    standalone: true,\n    imports: [NgIf, MatSelectionList, NgFor, MatListOption, ChartModule]\n})\nexport class CategoryDetailsComponent implements OnInit, OnChanges {\n\n    /* executedInitialQuery: boolean = false;\n     criteriaChangeCount: number = 0;\n     criteria: Criteria | undefined;*/\n\n\n    selectedCategory: Category | undefined;\n    plugins: any[] = [ChartDataLabels, autocolors];\n    expensesCategories!: Category[];\n    revenueCategories!: Category[];\n    chartData: any;\n\n    datatIsLoaded: Boolean = false;\n    chartOptions: any = this.initChartOptions();\n    @Input() criteria!: Criteria;\n\n    constructor(private appService: AppService) {\n\n        this.appService.selectedBankAccountObservable$.subscribe(bankAccount => {\n            if (bankAccount) {\n                this.initCategoryLists(bankAccount);\n            }\n\n        });\n\n    }\n\n\n    private initCategoryLists(bankAccount: BankAccount) {\n        this.getCategories(bankAccount, TransactionTypeEnum.EXPENSES).subscribe((data) => {\n            this.expensesCategories = data.map((category: string) => {\n                return {name: category, transactionType: TransactionTypeEnum.EXPENSES};\n            });\n        });\n        this.getCategories(bankAccount, TransactionTypeEnum.REVENUE).subscribe((data) => {\n            this.revenueCategories = data.map((category: string) => {\n                return {name: category, transactionType: TransactionTypeEnum.REVENUE};\n            });\n        });\n    }\n\n\n    ngOnInit(): void {\n\n    }\n\n\n\n    initChartOptions(): any {\n        return {\n            plugins: {\n                datalabels: {\n                    display: true,\n                    align: 'end',\n                    anchor: 'end',\n                    formatter: function (value: any, context: any) {\n                        return Math.round(value) || null;\n                    }\n\n                },\n                autocolors: {\n                    enabled: true,\n                    mode: 'dataset', // or 'data' or 'label'\n                    // other options...\n                }\n            },\n            indexAxis: 'x',\n            tooltips: {\n                mode: 'index',\n                intersect: false\n            },\n            responsive: true,\n            scales: {\n                x: {\n                    stacked: true\n\n                },\n                y: {\n                    stacked: true\n\n\n                }\n            }\n        };\n\n    }\n\n\n    doQuery(): void {\n\n        this.datatIsLoaded = false;\n\n        if (!this.criteria || !this.selectedCategory) {\n            return;\n        }\n        if(this.selectedCategory.transactionType !== this.criteria.transactionType) {\n            return;\n        }\n\n        let query: RevenueExpensesQuery = {\n            accountNumber: this.criteria.bankAccount.accountNumber,\n            grouping: this.criteria.grouping,\n            transactionType: this.criteria.transactionType,\n            start: JSON.stringify(this.criteria.startDate),\n            end: JSON.stringify(this.criteria.endDate),\n            expensesRecurrence: ExpensesRecurrenceEnum.BOTH,\n            revenueRecurrence: RevenueRecurrenceEnum.BOTH\n\n        };\n\n\n        this.datatIsLoaded = false;\n        this.appService.getCategoryDetailsForPeriod(query, this.selectedCategory.name).subscribe((data) => {\n            data.datasets = data.datasets.map((dataset: Dataset) => {\n                dataset.maxBarThickness = 50\n                return dataset;\n            });\n            this.chartData = data;\n            this.datatIsLoaded = true;\n        });\n\n    }\n\n\n    private getCategories(bankAccount: BankAccount, transactionType: TransactionTypeEnum):\n        Observable<string[]> {\n        if (transactionType === TransactionTypeEnum.BOTH) {\n            throw new Error(\"TransactionType.BOTH is not supported\");\n        }\n\n        return this.appService.getCategoriesForAccountAndTransactionType(bankAccount.accountNumber, transactionType);\n\n    }\n\n\n    onCategorySelectionChange($event: MatSelectionListChange) {\n        let options = $event.options;\n        if (options) {\n            this.selectedCategory = options[0].value as Category;\n            this.doQuery();\n        }\n\n    }\n\n    protected readonly TransactionType = TransactionTypeEnum;\n\n    ngOnChanges(changes: SimpleChanges): void {\n        let criteriaChange = changes['criteria'];\n        if (criteriaChange && criteriaChange.currentValue) {\n            let previousCriteria = criteriaChange.previousValue;\n            if (previousCriteria && this.criteria && previousCriteria.transactionType !== this.criteria.transactionType) {\n                this.selectedCategory = undefined;\n            }\n            this.doQuery();\n         }\n\n    }\n}\n",
            "properties": [
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "transactionType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionTypeEnum",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "CategoryAndAmount",
            "id": "interface-CategoryAndAmount-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "amount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "category",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "categoryId",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "isRevenue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "CategoryAndPeriod",
            "id": "interface-CategoryAndPeriod-20562cd5cae57d3c7655875ed70c4e5d58bd6abaf71cf8cf229e66e8d61c3a623bb92d8de6b6b8cd07e0fff39df1dfe2e6562130169c1053ab4da04569161918",
            "file": "src/app/revenue-expenses-per-period-and-category/context-menu.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import { Injectable } from '@angular/core';\n\nexport interface CategoryAndPeriod{\n    category: string;\n    period: string;\n\n}\n@Injectable({\n  providedIn: 'root'\n})\nexport class ContextMenuService {\n  data: any;\n\n  setData(data: CategoryAndPeriod): void {\n    this.data = data;\n  }\n\n  getData() : CategoryAndPeriod{\n    return this.data;\n  }\n}",
            "properties": [
                {
                    "name": "category",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "period",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "CategoryDetailsForPeriodHandlerResult",
            "id": "interface-CategoryDetailsForPeriodHandlerResult-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "datasets",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Dataset[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 189
                },
                {
                    "name": "labels",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 188
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "CategoryNode",
            "id": "interface-CategoryNode-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "children",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryNode[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 320
                },
                {
                    "name": "id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 324
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 321
                },
                {
                    "name": "qualifiedName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 322
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TypeEnum | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 323
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "CompositeTransactionsFileUploadResponse",
            "id": "interface-CompositeTransactionsFileUploadResponse-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "responses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionsFileUploadResponse[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 110
                },
                {
                    "name": "uploadTimestamp",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 111
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "Counterparty",
            "id": "interface-Counterparty-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "accountNumber",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38
                },
                {
                    "name": "category",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 37
                },
                {
                    "name": "streetAndNumber",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "zipCodeAndCity",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "Dataset",
            "id": "interface-Dataset-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 183
                },
                {
                    "name": "label",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 182
                },
                {
                    "name": "maxBarThickness",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 184
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "DistributionByCategoryForPeriodChartData",
            "id": "interface-DistributionByCategoryForPeriodChartData-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "entries",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryAndAmount[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 223
                },
                {
                    "name": "period",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 221
                },
                {
                    "name": "transactionType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 222
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "DistributionByCategoryForPeriodHandlerResult",
            "id": "interface-DistributionByCategoryForPeriodHandlerResult-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "chartData",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "DistributionByCategoryForPeriodChartData[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 167
                },
                {
                    "name": "tableColumnNames",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 169
                },
                {
                    "name": "tableData",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "DistributionByCategoryForPeriodTableData[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 168
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "DistributionByCategoryForPeriodHandlerResult2",
            "id": "interface-DistributionByCategoryForPeriodHandlerResult2-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "chartDataExpenses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "DistributionByCategoryForPeriodChartData[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 174
                },
                {
                    "name": "chartDataRevenue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "DistributionByCategoryForPeriodChartData[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 173
                },
                {
                    "name": "tableColumnNames",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 177
                },
                {
                    "name": "tableDataExpenses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "DistributionByCategoryForPeriodTableData[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 176
                },
                {
                    "name": "tableDataRevenue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "DistributionByCategoryForPeriodTableData[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 175
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "DistributionByCategoryForPeriodTableData",
            "id": "interface-DistributionByCategoryForPeriodTableData-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [],
            "indexSignatures": [
                {
                    "id": "index-declaration-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
                    "args": [
                        {
                            "name": "key",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "any",
                    "line": 228,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "kind": 181,
            "methods": [],
            "extends": []
        },
        {
            "name": "DistributionByTransactionTypeForPeriod",
            "id": "interface-DistributionByTransactionTypeForPeriod-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "balance",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 159
                },
                {
                    "name": "end",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 161
                },
                {
                    "name": "expenses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 158
                },
                {
                    "name": "period",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Period",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 156
                },
                {
                    "name": "revenue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 157
                },
                {
                    "name": "start",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 160
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "FieldMap",
            "id": "interface-FieldMap-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "properties": [],
            "indexSignatures": [
                {
                    "id": "index-declaration-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
                    "args": [
                        {
                            "name": "key",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Field",
                    "line": 448,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "kind": 181,
            "methods": [],
            "extends": []
        },
        {
            "name": "FileWrapper",
            "id": "interface-FileWrapper-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "failed",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 103
                },
                {
                    "name": "file",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "File",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 100
                },
                {
                    "name": "inProgress",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 101
                },
                {
                    "name": "progress",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 102
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "FindOrCreateBudgetResponse",
            "id": "interface-FindOrCreateBudgetResponse-ab5802e1347f1b484d762ed6e73a59f110ab93d7f293d3abc926c94b10090e9aaed528e4bcd7224404a36df227182a0c26149eedd0309c7062054dec8e0225ba",
            "file": "src/app/budget/budget.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport {FlatTreeControl} from \"@angular/cdk/tree\";\nimport {MatTreeFlatDataSource, MatTreeFlattener} from \"@angular/material/tree\";\nimport {\n  AbstractControl,\n  FormBuilder,\n  FormControl,\n  FormGroup,\n  FormGroupDirective,\n  FormsModule,\n  NgForm,\n  ReactiveFormsModule,\n  ValidatorFn\n} from \"@angular/forms\";\nimport {ErrorStateMatcher} from '@angular/material/core';\nimport {MatDialog} from \"@angular/material/dialog\";\nimport {SaveErrorDialogComponent} from \"./save-error-dialog/save-error-dialog.component\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {MatButton, MatIconButton} from '@angular/material/button';\nimport {MatIcon, MatIconModule, MatIconRegistry} from '@angular/material/icon';\nimport {NgClass, NgIf} from '@angular/common';\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from '@angular/material/table';\nimport {MatError, MatFormField} from '@angular/material/form-field';\nimport {MatInput} from '@angular/material/input';\n\nexport interface BudgetTreeNode {\n  budgetTreeNodeAmount: number;\n  budgetTreeNodeId: number;\n  budgetTreeNodeParentId: number;\n  children: BudgetTreeNode[];\n  name: string;\n  qualifiedName: string;\n}\n\nexport class FlatBudgetTreeNode {\n  level!: number;\n  expandable!: boolean;\n  name!: string;\n  qualifiedName!: string;\n  budgetTreeNodeId!: number;\n  budgetTreeNodeAmount!: number;\n  budgetTreeNodeParentId!: number;\n}\n\n\n\nexport interface FindOrCreateBudgetResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n  budgetTreeNodes: BudgetTreeNode[];\n  numberOfBudgetTreeNodes: number;\n\n}\n\nexport interface UpdateBudgetEntryResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n\n\n}\n\n\nexport class MyErrorStateMatcher implements ErrorStateMatcher {\n  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid);\n  }\n}\n\n\n@Component({\n    selector: 'app-budget',\n    templateUrl: './budget.component.html',\n    styleUrls: ['./budget.component.scss'],\n    standalone: true,\n  imports: [MatToolbar, BankAccountSelectionComponent,\n    MatButton, MatIcon, NgIf, FormsModule, ReactiveFormsModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell,\n    MatCellDef, MatCell, MatIconButton, MatFormField, MatInput, MatError, MatHeaderRowDef,\n    MatHeaderRow, MatRowDef, MatRow, NgClass, MatIconModule, MatIcon],\n\n})\nexport class BudgetComponent implements OnInit {\n  TOTAL_NODE_ID: number = -1;\n  TOTAL_NODE_CATEGORY_NAME = 'Totaal';\n\n  totalBudget: number = 0;\n\n  matcher = new MyErrorStateMatcher();\n\n\n  /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n  idToNodeMap = new Map<number, BudgetTreeNode>();\n\n  /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n  nestedNodeMap = new Map<BudgetTreeNode, FlatBudgetTreeNode>();\n\n  qualifiedNameToNodeMap = new Map<string, BudgetTreeNode>();\n\n  treeControl!: FlatTreeControl<FlatBudgetTreeNode>\n  dataSource!: MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>;\n\n\n  treeFlattener: MatTreeFlattener<BudgetTreeNode, FlatBudgetTreeNode>;\n\n  displayedColumns: string[] = ['category', 'budget', 'yearlyBudget'];\n\n  rowsToHighlight: Set<number> = new Set<number>();\n\n  idToControlsMap: Map<number, FormControl> = new Map<number, FormControl>();\n  controlsToIdMap: Map<FormControl, number> = new Map<FormControl, number>();\n  allControls: FormControl[] = [];\n  mainForm: FormGroup;\n  idToBudgetNodeMap: Map<number, BudgetTreeNode> = new Map<number, BudgetTreeNode>();\n  currentSubTreeHasError: boolean = false;\n  isTreeExpanded = true;\n\n\n  constructor(private appService: AppService, private fb: FormBuilder, public dialog: MatDialog\n  ) {\n\n    this.mainForm = this.fb.group({});\n\n    this.treeFlattener = new MatTreeFlattener(\n      this.transformer,\n      this.getLevel,\n      this.isExpandable,\n      this.getChildren\n    );\n    this.treeControl = new FlatTreeControl<FlatBudgetTreeNode>(\n      this.getLevel,\n      this.isExpandable\n    );\n    this.dataSource = new MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>(\n      this.treeControl,\n      this.treeFlattener\n    );\n\n\n\n  }\n\n\n  transformer = (node: BudgetTreeNode, level: number) => {\n    const existingNode = this.nestedNodeMap.get(node);\n    const flatNode =\n      existingNode && existingNode.qualifiedName === node.qualifiedName\n        ? existingNode\n        : new FlatBudgetTreeNode();\n    flatNode.name = node.name;\n    flatNode.qualifiedName = node.qualifiedName;\n    flatNode.level = level;\n    flatNode.expandable = (node.children != undefined && node.children.length > 0);\n    flatNode.budgetTreeNodeAmount = node.budgetTreeNodeAmount;\n    flatNode.budgetTreeNodeId = node.budgetTreeNodeId;\n    flatNode.budgetTreeNodeParentId = node.budgetTreeNodeParentId;\n    this.idToNodeMap.set(node.budgetTreeNodeId, node);\n\n    this.nestedNodeMap.set(node, flatNode);\n    this.qualifiedNameToNodeMap.set(node.qualifiedName, node);\n    return flatNode;\n  };\n\n  getLevel = (node: FlatBudgetTreeNode) => node.level;\n\n  isExpandable = (node: FlatBudgetTreeNode) => node.expandable;\n\n  getChildren = (node: BudgetTreeNode): BudgetTreeNode[] => node.children;\n\n  hasChild = (_: number, _nodeData: FlatBudgetTreeNode) => _nodeData.expandable;\n\n  inputChanged: boolean = false;\n  dataLoaded: boolean = false;\n  isSaved: boolean = false;\n\n\n  getRowClass(data: FlatBudgetTreeNode): string {\n    if (data.name === this.TOTAL_NODE_CATEGORY_NAME) {\n      return 'highlight-total-row';\n    }\n    if (this.currentSubTreeHasError && this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-error';\n    }\n    if (this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-no-error';\n    }\n    return '';\n  }\n\n\n  ngOnInit(): void {\n    this.appService.selectedBankAccountObservable$.subscribe(selectedAccount => {\n      if (selectedAccount) {\n        this.appService.findOrCreateBudget(selectedAccount).subscribe((response: BudgetTreeNode[]) => {\n\n          let filteredData = response.filter(node => node.name !== 'NO CATEGORY' && node.name !== 'DUMMY CATEGORY');\n          let totalBudgetTreeNode = this.initTotalBudgetTreeNode();\n          filteredData.push(totalBudgetTreeNode);\n          this.dataSource.data = filteredData;\n          let allBudgetNodes: BudgetTreeNode[] = [];\n          for (const node of response) {\n            if (node.name === 'NO CATEGORY' || node.name === 'DUMMY CATEGORY') {\n              continue;\n            }\n            allBudgetNodes.push(node);\n            this.getAllDescendantsRecursively(node, allBudgetNodes);\n          }\n\n\n          for (const node of allBudgetNodes) {\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            let control = new FormControl<number>(node.budgetTreeNodeAmount, [this.budgetValidator(), this.negativeNumberValidator()]);\n            this.idToControlsMap.set(node.budgetTreeNodeId, control);\n            control.valueChanges.subscribe((value) => {\n              if ((value !== undefined)) {\n                // this.inputChanged = false;\n                this.validateAllControls();\n                this.calculateTotalBudget();\n\n                let flatNode = this.nestedNodeMap.get(node);\n                if (flatNode){\n                  if (flatNode.name === this.TOTAL_NODE_CATEGORY_NAME) {\n                    //we don't want to do anything when the total node is changed\n                    return;\n                  }\n                  this.determineSubTreeForNode(flatNode as FlatBudgetTreeNode);\n                  if (!this.currentSubTreeHasError){\n                    this.onBudgetChange(flatNode as FlatBudgetTreeNode);\n                  }\n                }\n              }\n            });\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            this.controlsToIdMap.set(control, node.budgetTreeNodeId);\n            this.allControls.push(control);\n            this.mainForm.addControl(node.budgetTreeNodeId.toString(), control);\n          }\n          this.calculateTotalBudget();\n          this.dataLoaded = true;\n          this.treeControl.expandAll();\n\n        });\n      }\n    });\n\n  }\n\n  getDescendantIds(node: BudgetTreeNode, allDescendantIds: number[]) {\n    if (node.children && node.children.length > 0) {\n      node.children.forEach(child => {\n        allDescendantIds.push(child.budgetTreeNodeId);\n        this.getDescendantIds(child, allDescendantIds);\n      });\n    }\n  }\n\n  validateAllControls() {\n    Object.keys(this.mainForm.controls).forEach(key => {\n      const control = this.mainForm.get(key);\n      if (control) {\n        control.updateValueAndValidity({onlySelf: false, emitEvent: false});\n\n      }\n    });\n    this.mainForm.markAllAsTouched();\n  }\n\n  budgetValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isLessThanSumOfDescendants = this.isLessThanSumOfDescendants(control as FormControl);\n      return isLessThanSumOfDescendants ? {'isLessThanItsDescendants': {value: control.value}} : null;\n    };\n  }\n\n  negativeNumberValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isNegative = control.value < 0;\n      return isNegative ? {'negativeNumber': {value: control.value}} : null;\n    };\n  }\n\n  isLessThanSumOfDescendants(control: FormControl): boolean {\n    let nodeId = this.controlsToIdMap.get(control);\n    if (!nodeId) {\n      return false;\n    }\n\n    let nodeValue = control.value;\n\n    if (nodeValue == undefined || nodeValue < 0) {\n      return false;\n    }\n    let sumOfDescendants = 0;\n\n    let payload = this.idToBudgetNodeMap.get(nodeId) as BudgetTreeNode;\n    let allDescendantIds: number[] = [];\n    this.getDescendantIds(payload, allDescendantIds);\n\n    for (const descendantId of allDescendantIds) {\n      let descendantValue = this.idToControlsMap.get(descendantId)?.value;\n      if (descendantValue) {\n        sumOfDescendants = sumOfDescendants + descendantValue;\n\n      }\n    }\n\n\n    let isLessThanSumOfDescendants = nodeValue < sumOfDescendants;\n    //unpacking boolean for debugging purposes\n    return isLessThanSumOfDescendants;\n\n  }\n\n\n  determineSubTreeForNode(data: FlatBudgetTreeNode) {\n    this.rowsToHighlight = new Set<number>();\n    this.currentSubTreeHasError = false;\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n    this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n    if (budgetTreeNode.budgetTreeNodeParentId) {\n      //go one level up the tree to the parent. Add the id of the parent and all its descendants to the set of rows to highlight\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeParentId);\n      let parentBudgetTreeNode = this.idToNodeMap.get(budgetTreeNode.budgetTreeNodeParentId);\n      if (parentBudgetTreeNode == undefined) {\n        return;\n      }\n\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(parentBudgetTreeNode, allDescendantIds);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n\n\n\n    } else {\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(budgetTreeNode, allDescendantIds);\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n    }\n    this.currentSubTreeHasError = this.anyFormControlIsInvalid(this.rowsToHighlight);\n\n\n  }\n\n  private anyFormControlIsInvalid(ids: Set<number>): boolean {\n    let idsArray = [...ids];\n    for (const number of idsArray) {\n      if(this.formControlIsInvalid(number)){\n        return true;\n      }\n    }\n\n    return false;\n\n\n\n\n  }\n\n  private formControlIsInvalid(budgetTreeNodeId: number): boolean {\n    let control = this.mainForm.get(budgetTreeNodeId.toString());\n    if (control) {\n      return control.invalid;\n    }\n    return false;\n  }\n\n\n  /*onBlur() {\n    this.inputChanged = true;\n  }\n\n  onKeyUpEnter(event: Event) {\n    let kbe = event as KeyboardEvent;\n    if (kbe.key === 'Enter') {\n      this.inputChanged = true;\n    }\n  }*/\n\n  getAllDescendantsRecursively(budgetTreeNode: BudgetTreeNode, descendants: BudgetTreeNode[]) {\n    if (budgetTreeNode.children && budgetTreeNode.children.length > 0) {\n      budgetTreeNode.children.forEach(child => {\n        descendants.push(child);\n        this.getAllDescendantsRecursively(child, descendants);\n      });\n    }\n  }\n\n\n\n\n  onBudgetChange(data: FlatBudgetTreeNode): void {\n\n    let budgetControl = this.mainForm.get(data.budgetTreeNodeId.toString()) as FormControl;\n    if (budgetControl == undefined) {\n      return;\n    }\n    if (data.budgetTreeNodeAmount === undefined || data.budgetTreeNodeAmount === null) {\n      data.budgetTreeNodeAmount = 0;\n      budgetControl.setValue(0);\n    }\n\n\n    if (!budgetControl.valid) {\n      return;\n    }\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n\n\n    if (budgetTreeNode.budgetTreeNodeAmount !== budgetControl.value) {\n      budgetTreeNode.budgetTreeNodeAmount = budgetControl.value;\n    }\n\n    this.appService.updateBudgetEntryAmount(budgetTreeNode).subscribe(\n      (\n        response: UpdateBudgetEntryResponse\n      ) => {\n        if (response.response.toLowerCase() !== \"success\") {\n          throw new Error(\"Failed to update budget entry amount\");\n        }\n        // this.recalculateCumulatedAmountsForAllNodes();\n        this.treeControl.expandAll();\n      });\n\n  }\n\n  sameSubTreeAsFocusedBudgetNode(data: FlatBudgetTreeNode): boolean {\n    return this.rowsToHighlight.has(data.budgetTreeNodeId);\n\n  }\n\n\n  /*onInputChange() {\n    this.inputChanged = true\n  }*/\n\n  saveAll() {\n    if (this.mainForm.invalid) {\n      let invalidCategories: BudgetTreeNode[] = [];\n      Object.keys(this.mainForm.controls).forEach(key => {\n        const control = this.mainForm.get(key);\n        if (control && control.invalid) {\n          let node = this.idToNodeMap.get(parseInt(key));\n          if (!node) {\n            throw new Error(\"Failed to find node for id \" + key);\n          }\n          node.budgetTreeNodeAmount = control.value;\n          invalidCategories.push(node);\n\n\n        }\n      });\n      this.dialog.open(SaveErrorDialogComponent, {\n        data: {\n          message: 'Sommige wijzingen kunnen niet worden opgeslaan! Corrigeer de inconsistente budgetbedragen voor onderstaande categorieën en probeer opnieuw:',\n          nodes: invalidCategories\n        }\n      });\n    } else {\n      let budgetTreeNodes = this.dataSource.data;\n      for (const budgetTreeNode of budgetTreeNodes) {\n        if (budgetTreeNode.budgetTreeNodeId === this.TOTAL_NODE_ID) {\n          continue;\n        }\n        let flatNode = this.nestedNodeMap.get(budgetTreeNode);\n        if (!flatNode) {\n          throw new Error(\"Failed to find flat node for budget tree node \" + budgetTreeNode);\n        } else {\n          this.onBudgetChange(flatNode);\n        }\n\n\n      }\n\n\n\n\n\n\n    }\n  }\n\n\n  toggleTree(): void {\n    if (this.isTreeExpanded) {\n      this.treeControl.collapseAll();\n    } else {\n      this.treeControl.expandAll();\n    }\n    this.isTreeExpanded = !this.isTreeExpanded;\n  }\n\n  calculateTotalBudget(): void {\n    this.totalBudget = Array.from(this.idToControlsMap.values()).filter(control => control.valid)\n      .reduce((sum, control) => sum + (control.value || 0), 0);\n    let totalNode = {\n      budgetTreeNodeAmount: this.totalBudget,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n    this.dataSource.data = [totalNode, ...this.dataSource.data.slice(1, this.dataSource.data.length - 1), totalNode];\n    this.mainForm.get(totalNode.budgetTreeNodeId.toString())?.setValue(totalNode.budgetTreeNodeAmount);\n  }\n\n  initTotalBudgetTreeNode(): BudgetTreeNode {\n    return {\n      budgetTreeNodeAmount: 0,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n  }\n\n}\n\n\n",
            "properties": [
                {
                    "name": "budgetTreeNodes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BudgetTreeNode[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64
                },
                {
                    "name": "errorMessage",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63
                },
                {
                    "name": "failureReason",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "numberOfBudgetTreeNodes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 65
                },
                {
                    "name": "response",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "GroupBy",
            "id": "interface-GroupBy-70965ee21c0e838de03c524ca1d8534c39684b54d1e3f49d020939ee21de39f3a2e682fe13e11f4ad29ab11cedabca1c7097bc7d1806e2def7c403d7f4eae0c2",
            "file": "src/app/manual-categorization-view/manual-categorization-view.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {Component, ElementRef, OnInit, ViewChild} from '@angular/core';\nimport {MatPaginator} from \"@angular/material/paginator\";\nimport {MatSort} from \"@angular/material/sort\";\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from \"@angular/material/table\";\nimport {PaginationDataSource, SimpleDataSource} from \"@daanvdn/ngx-pagination-data-source\";\nimport {AppService} from \"../app.service\";\nimport {BehaviorSubject, map, Observable} from \"rxjs\";\nimport {MatButtonToggle, MatButtonToggleChange, MatButtonToggleGroup} from \"@angular/material/button-toggle\";\nimport {BankAccount, SimpleCategory, Transaction, TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\nimport {AmountType, CategoryMap, inferAmountType} from \"../model\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {AsyncPipe, NgIf} from '@angular/common';\nimport {CategoryTreeDropdownComponent} from '../category-tree-dropdown/category-tree-dropdown.component';\n\n\ninterface GroupBy {\n  counterparty: string;\n  isGroupBy: boolean;\n  transactions: Transaction[];\n  isExpense: boolean;\n}\n\nclass GroupByCounterpartyDataSource implements SimpleDataSource<Transaction | GroupBy> {\n\n\n\n  constructor(public backingPaginationDataSource: PaginationDataSource<Transaction, BankAccount>, private isExpense: boolean) {\n  }\n\n  connect(): Observable<Array<Transaction | GroupBy>> {\n    return this.backingPaginationDataSource.connect().pipe(map(data => {\n\n      let mapByCounterpartyName = new Map<string, Transaction[]>();\n\n      for (const transaction of data) {\n        let name = transaction.counterparty;\n        if (!name) {\n          name = \"\";\n        }\n        let transactionsForCounterparty = mapByCounterpartyName.has(name) ? mapByCounterpartyName.get(name) : [];\n        transactionsForCounterparty?.push(transaction);\n        mapByCounterpartyName.set(name, transactionsForCounterparty as Transaction[]);\n      }\n      let sortedKeys = Array.from(mapByCounterpartyName.keys()).sort();\n      let result = new Array<Transaction | GroupBy>();\n      for (const aKey of sortedKeys) {\n        let transactionsForKey = mapByCounterpartyName.get(aKey) as Transaction[];\n        let groupBy: GroupBy = {\n          counterparty: aKey, isGroupBy: true, transactions: transactionsForKey, isExpense: this.isExpense\n        };\n        result.push(groupBy)\n        result.push(...transactionsForKey)\n\n      }\n\n      return result;\n    }));\n  }\n\n  disconnect(): void {\n    this.backingPaginationDataSource.disconnect();\n  }\n\n\n  fetch(page: number, pageSize?: number): void {\n    this.backingPaginationDataSource.fetch(page, pageSize);\n  }\n\n\n}\n\n@Component({\n    selector: 'app-manual-categorization-view',\n    templateUrl: './manual-categorization-view.component.html',\n    styleUrls: ['./manual-categorization-view.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, BankAccountSelectionComponent, MatButtonToggleGroup, MatButtonToggle, NgIf, MatPaginator, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, CategoryTreeDropdownComponent, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, AsyncPipe]\n})\nexport class ManualCategorizationViewComponent implements OnInit {\n\n  @ViewChild(MatPaginator, { static: false }) paginator!: MatPaginator;\n  @ViewChild(MatSort, { static: false }) sort!: MatSort;\n  @ViewChild(MatTable) table!: MatTable<Transaction>;\n  @ViewChild('table', {read: ElementRef, static: false}) tableElement!: ElementRef;\n\n\n  dataSource!: GroupByCounterpartyDataSource;\n  categoryMap!: CategoryMap;\n\n  private bankAccount!: BankAccount;\n  displayedColumns = [\n    \"transaction\",\n    \"amount\",\n    \"category\"\n  ];\n  private activeView: BehaviorSubject<TransactionTypeEnum> = new BehaviorSubject<TransactionTypeEnum>(TransactionTypeEnum.EXPENSES);\n  private activeViewObservable = this.activeView.asObservable();\n  constructor(private appService: AppService) {\n    appService.selectedBankAccountObservable$.subscribe(account => {\n      if (account){\n        this.bankAccount = account;\n        this.dataSource = this.initDataSource(account, this.activeView.getValue());\n      }\n    });\n    appService.categoryMapObservable$.subscribe(categoryMap => {\n      if (categoryMap) {\n        this.categoryMap = categoryMap;\n      }}\n    )\n\n\n    this.activeViewObservable.subscribe(activeView => {\n      this.dataSource = this.initDataSource(this.bankAccount, activeView);\n    })\n\n  }\n\n  ngOnInit( ): void {\n  }\n\n  private initDataSource(account: BankAccount, transactionType: TransactionTypeEnum): GroupByCounterpartyDataSource {\n    if (transactionType == TransactionTypeEnum.BOTH){\n      throw new Error(\"TransactionType.BOTH not supported\")\n    }\n\n    let isExpense = transactionType === TransactionTypeEnum.EXPENSES;\n\n    let paginationDataSource = new PaginationDataSource<Transaction, BankAccount>(\n      (request, query) => {\n        request.size = 50;\n        return this.appService.pageTransactionsToManuallyReview(request, transactionType);\n      },\n      {property: 'counterparty', order: 'asc'}, account\n    );\n    return new GroupByCounterpartyDataSource(paginationDataSource, isExpense);\n  }\n\n\n  saveTransaction(transaction: Transaction) {\n    this.appService.saveTransaction(transaction)\n  }\n\n  setCategory(row: (Transaction | GroupBy), selectedCategoryQualifiedNameStr: string) {\n    // Get the SimpleCategory object from the CategoryMap\n    const category = this.categoryMap.getSimpleCategory(selectedCategoryQualifiedNameStr);\n\n    // Check if row is an interface that has key 'isGroupBy'\n    if (\"isGroupBy\" in row) {\n      (row as GroupBy).transactions.forEach(transaction => {\n        transaction.category = category;\n        this.saveTransaction(transaction);\n      });\n      return;\n    } else {\n      let transaction = row as Transaction;\n      transaction.category = category;\n      this.saveTransaction(transaction);\n    }\n  }\n\n  amountType(transaction: Transaction | GroupBy): AmountType {\n    if (\"isGroupBy\" in transaction) {\n      return transaction.isExpense ? AmountType.EXPENSES : AmountType.REVENUE;\n    }\n    if (transaction.amount === undefined || transaction.amount === null) {\n      throw new Error(\"Amount is undefined or null\");\n    }\n    return inferAmountType(transaction.amount)\n\n\n  }\n\n  isGroup(index: any, item: any): boolean {\n    return item.isGroupBy;\n  }\n\n  onToggleChange($event: MatButtonToggleChange) {\n    this.tableElement.nativeElement.scrollIntoView({behavior: 'smooth', block: 'start'});\n    const value = $event.value;\n    if (value === \"expenses\") {\n      this.activeView.next(TransactionTypeEnum.EXPENSES);\n    } else if (value === \"revenue\") {\n      this.activeView.next(TransactionTypeEnum.REVENUE);\n    } else {\n      throw new Error(\"Unknown value \" + value);\n    }\n\n\n\n  }\n}\n",
            "properties": [
                {
                    "name": "counterparty",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "isExpense",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 32
                },
                {
                    "name": "isGroupBy",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30
                },
                {
                    "name": "transactions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Transaction[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 31
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "LocalRuleMeta",
            "id": "interface-LocalRuleMeta-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "properties": [
                {
                    "name": "invalid",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 530
                },
                {
                    "name": "ruleset",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 529
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "LoginResponse",
            "id": "interface-LoginResponse-192661d47c17b7eb1c734b22cbe056f867c89d87cc6bad58faf033b9024ed6fef04162a89ba5a5cf0ab25861c66138ff049fbdac773d30e078492f42685f3a8d",
            "file": "src/app/auth/auth.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Router} from '@angular/router';\nimport {BehaviorSubject, map, Observable} from 'rxjs';\n\nimport {DUMMY_USER, User} from \"../model\";\nimport { HttpClient } from \"@angular/common/http\";\nimport {\n  ApiBudgetAssistantBackendClientService,\n  RegisterUser,\n  TokenObtainPair,\n} from '@daanvdn/budget-assistant-client';\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\n\nexport enum Response {\n  SUCCESS = \"SUCCESS\",\n  FAILED = \"FAILED\",\n}\n\nexport enum RegisterFailureReason{\n  USER_ALREADY_EXISTS,\n  EMPTY_FIELDS,\n  SERVER_ERROR\n}\nexport enum LoginFailureReason{\n  PASSWORD_USER_COMBINATION_IS_WRONG,\n  SERVER_ERROR\n}\n\nexport interface LoginResponse {\n\n  response: Response;\n  errorMessage: string;\n  user: User;\n  failureReason: LoginFailureReason | null;\n\n\n}\nexport interface RegisterResponse {\n\n  response: Response;\n  errorMessage: string;\n  user: User;\n  failureReason: RegisterFailureReason | null;\n\n\n}\n\n@Injectable({\n  providedIn: 'root',\n})\n\nexport class AuthService {\n  private loggedIn: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);\n  private user: BehaviorSubject<User> = new BehaviorSubject<User>(DUMMY_USER);\n\n\n  constructor(private router: Router, private apiBudgetAssistantBackendClientService: ApiBudgetAssistantBackendClientService,\n              private errorDialogService: ErrorDialogService,\n              ) {\n\n  }\n\n\n  get isLoggedIn() {\n    return this.loggedIn.asObservable();\n  }\n\n\n  public getUserObservable(): Observable<User> {\n\n    return this.user.asObservable();\n  }\n\n\n  public getUser(): User {\n    return this.user.getValue();\n  }\n\n\n  login(user: User): Observable<LoginResponse> {\n    const loginPayload: TokenObtainPair = {\n      username: user.userName as string,\n      password: user.password as string,\n      access: '',\n      refresh: ''\n    };\n    return this.apiBudgetAssistantBackendClientService.apiTokenCreate(loginPayload, 'response').pipe(map(response => {\n          if (!response.ok || !response.body?.access) {\n            this.loggedIn.next(false);\n            return {\n              response: Response.FAILED,\n              errorMessage: response.statusText,\n              user: DUMMY_USER,\n              failureReason: LoginFailureReason.PASSWORD_USER_COMBINATION_IS_WRONG\n            };\n\n          }\n          this.loggedIn.next(true);\n          this.user.next(user);\n          sessionStorage.setItem('jwtToken', response.body.access);\n          this.router.navigate(['/profiel']);\n          return {\n            response: Response.SUCCESS,\n            errorMessage: '',\n            user: user,\n            failureReason: null\n          }\n        })\n    );\n\n\n  }\n\n  register(user: User): Observable<RegisterResponse> {\n    let registerUser\n        :\n        RegisterUser = {\n      username: user.email as string,\n      password: user.password as string,\n      email: user.email as string,\n\n    }\n    return this.apiBudgetAssistantBackendClientService.apiRegisterCreate(registerUser, 'response', true).pipe(map(response => {\n      if (response.ok) {\n        this.loggedIn.next(true);\n        this.user.next(user);\n        this.router.navigate(['/login']);\n        return {\n            response: Response.SUCCESS,\n            errorMessage: '',\n            user: user,\n            failureReason: RegisterFailureReason.USER_ALREADY_EXISTS\n        }\n      }\n      else {\n        return {\n          response: Response.FAILED,\n          errorMessage: response.statusText,\n          user: DUMMY_USER,\n          failureReason: RegisterFailureReason.SERVER_ERROR\n        }\n      }\n    }));\n\n\n\n\n  }\n\n\n  private parseRegisterResponse(data: any): RegisterResponse {\n    return {\n      ...data,\n      failureReason: RegisterFailureReason[data.failureReason as keyof typeof RegisterFailureReason]\n    };\n  }\n\n\n  logout() {\n    this.loggedIn.next(false);\n    this.user.next(DUMMY_USER);\n    //Call this.logoutService.logoutCreate() and handle error response\n    this.apiBudgetAssistantBackendClientService.apiLogoutCreate('response').subscribe(response => {\n      if (response.ok) {\n        this.router.navigate(['/login']);\n\n      }\n      else {\n        this.errorDialogService.openErrorDialog(\"Logout failed!\", response.statusText);\n      }\n    });\n\n\n  }\n}",
            "properties": [
                {
                    "name": "errorMessage",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 32
                },
                {
                    "name": "failureReason",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LoginFailureReason | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                },
                {
                    "name": "response",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Response",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 31
                },
                {
                    "name": "user",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "User",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "Option",
            "id": "interface-Option-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "properties": [
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 444
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 445
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "Period",
            "id": "interface-Period-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "end",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 196
                },
                {
                    "name": "grouping",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Grouping",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 197
                },
                {
                    "name": "start",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 195
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 198
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "PeriodAndAmount",
            "id": "interface-PeriodAndAmount-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "amount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 31
                },
                {
                    "name": "period",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "QueryBuilderClassNames",
            "id": "interface-QueryBuilderClassNames-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "properties": [
                {
                    "name": "addIcon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 537
                },
                {
                    "name": "arrowIcon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 535
                },
                {
                    "name": "arrowIconButton",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 534
                },
                {
                    "name": "button",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 538
                },
                {
                    "name": "buttonGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 539
                },
                {
                    "name": "collapsed",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 549
                },
                {
                    "name": "connector",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 553
                },
                {
                    "name": "emptyWarning",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 557
                },
                {
                    "name": "fieldControl",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 558
                },
                {
                    "name": "fieldControlSize",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 559
                },
                {
                    "name": "inputControl",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 562
                },
                {
                    "name": "inputControlSize",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 563
                },
                {
                    "name": "invalidRuleSet",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 556
                },
                {
                    "name": "operatorControl",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 560
                },
                {
                    "name": "operatorControlSize",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 561
                },
                {
                    "name": "removeButton",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 540
                },
                {
                    "name": "removeButtonSize",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 541
                },
                {
                    "name": "removeIcon",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 536
                },
                {
                    "name": "rightAlign",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 547
                },
                {
                    "name": "row",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 552
                },
                {
                    "name": "rule",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 554
                },
                {
                    "name": "ruleSet",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 555
                },
                {
                    "name": "switchControl",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 546
                },
                {
                    "name": "switchGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 543
                },
                {
                    "name": "switchLabel",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 544
                },
                {
                    "name": "switchRadio",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 545
                },
                {
                    "name": "switchRow",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 542
                },
                {
                    "name": "transition",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 548
                },
                {
                    "name": "tree",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 551
                },
                {
                    "name": "treeContainer",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 550
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "QueryBuilderConfig",
            "id": "interface-QueryBuilderConfig-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "properties": [
                {
                    "name": "allowEmptyRulesets",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 568
                },
                {
                    "name": "fields",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FieldMap",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 567
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "RegisterResponse",
            "id": "interface-RegisterResponse-192661d47c17b7eb1c734b22cbe056f867c89d87cc6bad58faf033b9024ed6fef04162a89ba5a5cf0ab25861c66138ff049fbdac773d30e078492f42685f3a8d",
            "file": "src/app/auth/auth.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Router} from '@angular/router';\nimport {BehaviorSubject, map, Observable} from 'rxjs';\n\nimport {DUMMY_USER, User} from \"../model\";\nimport { HttpClient } from \"@angular/common/http\";\nimport {\n  ApiBudgetAssistantBackendClientService,\n  RegisterUser,\n  TokenObtainPair,\n} from '@daanvdn/budget-assistant-client';\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\n\nexport enum Response {\n  SUCCESS = \"SUCCESS\",\n  FAILED = \"FAILED\",\n}\n\nexport enum RegisterFailureReason{\n  USER_ALREADY_EXISTS,\n  EMPTY_FIELDS,\n  SERVER_ERROR\n}\nexport enum LoginFailureReason{\n  PASSWORD_USER_COMBINATION_IS_WRONG,\n  SERVER_ERROR\n}\n\nexport interface LoginResponse {\n\n  response: Response;\n  errorMessage: string;\n  user: User;\n  failureReason: LoginFailureReason | null;\n\n\n}\nexport interface RegisterResponse {\n\n  response: Response;\n  errorMessage: string;\n  user: User;\n  failureReason: RegisterFailureReason | null;\n\n\n}\n\n@Injectable({\n  providedIn: 'root',\n})\n\nexport class AuthService {\n  private loggedIn: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);\n  private user: BehaviorSubject<User> = new BehaviorSubject<User>(DUMMY_USER);\n\n\n  constructor(private router: Router, private apiBudgetAssistantBackendClientService: ApiBudgetAssistantBackendClientService,\n              private errorDialogService: ErrorDialogService,\n              ) {\n\n  }\n\n\n  get isLoggedIn() {\n    return this.loggedIn.asObservable();\n  }\n\n\n  public getUserObservable(): Observable<User> {\n\n    return this.user.asObservable();\n  }\n\n\n  public getUser(): User {\n    return this.user.getValue();\n  }\n\n\n  login(user: User): Observable<LoginResponse> {\n    const loginPayload: TokenObtainPair = {\n      username: user.userName as string,\n      password: user.password as string,\n      access: '',\n      refresh: ''\n    };\n    return this.apiBudgetAssistantBackendClientService.apiTokenCreate(loginPayload, 'response').pipe(map(response => {\n          if (!response.ok || !response.body?.access) {\n            this.loggedIn.next(false);\n            return {\n              response: Response.FAILED,\n              errorMessage: response.statusText,\n              user: DUMMY_USER,\n              failureReason: LoginFailureReason.PASSWORD_USER_COMBINATION_IS_WRONG\n            };\n\n          }\n          this.loggedIn.next(true);\n          this.user.next(user);\n          sessionStorage.setItem('jwtToken', response.body.access);\n          this.router.navigate(['/profiel']);\n          return {\n            response: Response.SUCCESS,\n            errorMessage: '',\n            user: user,\n            failureReason: null\n          }\n        })\n    );\n\n\n  }\n\n  register(user: User): Observable<RegisterResponse> {\n    let registerUser\n        :\n        RegisterUser = {\n      username: user.email as string,\n      password: user.password as string,\n      email: user.email as string,\n\n    }\n    return this.apiBudgetAssistantBackendClientService.apiRegisterCreate(registerUser, 'response', true).pipe(map(response => {\n      if (response.ok) {\n        this.loggedIn.next(true);\n        this.user.next(user);\n        this.router.navigate(['/login']);\n        return {\n            response: Response.SUCCESS,\n            errorMessage: '',\n            user: user,\n            failureReason: RegisterFailureReason.USER_ALREADY_EXISTS\n        }\n      }\n      else {\n        return {\n          response: Response.FAILED,\n          errorMessage: response.statusText,\n          user: DUMMY_USER,\n          failureReason: RegisterFailureReason.SERVER_ERROR\n        }\n      }\n    }));\n\n\n\n\n  }\n\n\n  private parseRegisterResponse(data: any): RegisterResponse {\n    return {\n      ...data,\n      failureReason: RegisterFailureReason[data.failureReason as keyof typeof RegisterFailureReason]\n    };\n  }\n\n\n  logout() {\n    this.loggedIn.next(false);\n    this.user.next(DUMMY_USER);\n    //Call this.logoutService.logoutCreate() and handle error response\n    this.apiBudgetAssistantBackendClientService.apiLogoutCreate('response').subscribe(response => {\n      if (response.ok) {\n        this.router.navigate(['/login']);\n\n      }\n      else {\n        this.errorDialogService.openErrorDialog(\"Logout failed!\", response.statusText);\n      }\n    });\n\n\n  }\n}",
            "properties": [
                {
                    "name": "errorMessage",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "failureReason",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RegisterFailureReason | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "response",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Response",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "user",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "User",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "RuleSetWrapper",
            "id": "interface-RuleSetWrapper-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "properties": [
                {
                    "name": "categoryType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TypeEnum",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 214
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": [
                "ClientRuleSetWrapper"
            ]
        },
        {
            "name": "Transaction",
            "id": "interface-Transaction-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "amount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Number | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "bankAccount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "bic",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57
                },
                {
                    "name": "bookingDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "category",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "communications",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "counterparty",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Counterparty | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52
                },
                {
                    "name": "countryCode",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "currency",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56
                },
                {
                    "name": "currencyDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54
                },
                {
                    "name": "isAdvanceSharedAccount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63
                },
                {
                    "name": "isManuallyReviewed",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64
                },
                {
                    "name": "isRecurring",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "manuallyAssignedCategory",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                },
                {
                    "name": "statementNumber",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 50
                },
                {
                    "name": "transaction",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "transaction_id",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "transactionNumber",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 51
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "TransactionQuery",
            "id": "interface-TransactionQuery-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "accountNumber",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 78
                },
                {
                    "name": "category",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 79
                },
                {
                    "name": "counterpartyAccountNumber",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 81
                },
                {
                    "name": "counterpartyName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 75
                },
                {
                    "name": "endDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 83
                },
                {
                    "name": "expenses",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74
                },
                {
                    "name": "freeText",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 80
                },
                {
                    "name": "maxAmount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Number | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 77
                },
                {
                    "name": "minAmount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Number | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 76
                },
                {
                    "name": "revenue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73
                },
                {
                    "name": "startDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 82
                },
                {
                    "name": "transactionOrCommunication",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 84
                },
                {
                    "name": "uploadTimestamp",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 85
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "TransactionsCategorizationResponse",
            "id": "interface-TransactionsCategorizationResponse-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "message",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 282
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 285
                },
                {
                    "name": "withCategoryCount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 283
                },
                {
                    "name": "withoutCategoryCount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 284
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "TransactionsFileUploadResponse",
            "id": "interface-TransactionsFileUploadResponse-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "message",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 116
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 117
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "TransactionsFileUploadResponseWrapper",
            "id": "interface-TransactionsFileUploadResponseWrapper-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "fileWrapper",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FileWrapper",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 124
                },
                {
                    "name": "response",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionsFileUploadResponse",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 123
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "TransactionsInContextQuery",
            "id": "interface-TransactionsInContextQuery-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "bankAccount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 91
                },
                {
                    "name": "category",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 94
                },
                {
                    "name": "period",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 92
                },
                {
                    "name": "transactionType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 93
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "UpdateBudgetEntryResponse",
            "id": "interface-UpdateBudgetEntryResponse-ab5802e1347f1b484d762ed6e73a59f110ab93d7f293d3abc926c94b10090e9aaed528e4bcd7224404a36df227182a0c26149eedd0309c7062054dec8e0225ba",
            "file": "src/app/budget/budget.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport {FlatTreeControl} from \"@angular/cdk/tree\";\nimport {MatTreeFlatDataSource, MatTreeFlattener} from \"@angular/material/tree\";\nimport {\n  AbstractControl,\n  FormBuilder,\n  FormControl,\n  FormGroup,\n  FormGroupDirective,\n  FormsModule,\n  NgForm,\n  ReactiveFormsModule,\n  ValidatorFn\n} from \"@angular/forms\";\nimport {ErrorStateMatcher} from '@angular/material/core';\nimport {MatDialog} from \"@angular/material/dialog\";\nimport {SaveErrorDialogComponent} from \"./save-error-dialog/save-error-dialog.component\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {MatButton, MatIconButton} from '@angular/material/button';\nimport {MatIcon, MatIconModule, MatIconRegistry} from '@angular/material/icon';\nimport {NgClass, NgIf} from '@angular/common';\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from '@angular/material/table';\nimport {MatError, MatFormField} from '@angular/material/form-field';\nimport {MatInput} from '@angular/material/input';\n\nexport interface BudgetTreeNode {\n  budgetTreeNodeAmount: number;\n  budgetTreeNodeId: number;\n  budgetTreeNodeParentId: number;\n  children: BudgetTreeNode[];\n  name: string;\n  qualifiedName: string;\n}\n\nexport class FlatBudgetTreeNode {\n  level!: number;\n  expandable!: boolean;\n  name!: string;\n  qualifiedName!: string;\n  budgetTreeNodeId!: number;\n  budgetTreeNodeAmount!: number;\n  budgetTreeNodeParentId!: number;\n}\n\n\n\nexport interface FindOrCreateBudgetResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n  budgetTreeNodes: BudgetTreeNode[];\n  numberOfBudgetTreeNodes: number;\n\n}\n\nexport interface UpdateBudgetEntryResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n\n\n}\n\n\nexport class MyErrorStateMatcher implements ErrorStateMatcher {\n  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid);\n  }\n}\n\n\n@Component({\n    selector: 'app-budget',\n    templateUrl: './budget.component.html',\n    styleUrls: ['./budget.component.scss'],\n    standalone: true,\n  imports: [MatToolbar, BankAccountSelectionComponent,\n    MatButton, MatIcon, NgIf, FormsModule, ReactiveFormsModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell,\n    MatCellDef, MatCell, MatIconButton, MatFormField, MatInput, MatError, MatHeaderRowDef,\n    MatHeaderRow, MatRowDef, MatRow, NgClass, MatIconModule, MatIcon],\n\n})\nexport class BudgetComponent implements OnInit {\n  TOTAL_NODE_ID: number = -1;\n  TOTAL_NODE_CATEGORY_NAME = 'Totaal';\n\n  totalBudget: number = 0;\n\n  matcher = new MyErrorStateMatcher();\n\n\n  /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n  idToNodeMap = new Map<number, BudgetTreeNode>();\n\n  /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n  nestedNodeMap = new Map<BudgetTreeNode, FlatBudgetTreeNode>();\n\n  qualifiedNameToNodeMap = new Map<string, BudgetTreeNode>();\n\n  treeControl!: FlatTreeControl<FlatBudgetTreeNode>\n  dataSource!: MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>;\n\n\n  treeFlattener: MatTreeFlattener<BudgetTreeNode, FlatBudgetTreeNode>;\n\n  displayedColumns: string[] = ['category', 'budget', 'yearlyBudget'];\n\n  rowsToHighlight: Set<number> = new Set<number>();\n\n  idToControlsMap: Map<number, FormControl> = new Map<number, FormControl>();\n  controlsToIdMap: Map<FormControl, number> = new Map<FormControl, number>();\n  allControls: FormControl[] = [];\n  mainForm: FormGroup;\n  idToBudgetNodeMap: Map<number, BudgetTreeNode> = new Map<number, BudgetTreeNode>();\n  currentSubTreeHasError: boolean = false;\n  isTreeExpanded = true;\n\n\n  constructor(private appService: AppService, private fb: FormBuilder, public dialog: MatDialog\n  ) {\n\n    this.mainForm = this.fb.group({});\n\n    this.treeFlattener = new MatTreeFlattener(\n      this.transformer,\n      this.getLevel,\n      this.isExpandable,\n      this.getChildren\n    );\n    this.treeControl = new FlatTreeControl<FlatBudgetTreeNode>(\n      this.getLevel,\n      this.isExpandable\n    );\n    this.dataSource = new MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>(\n      this.treeControl,\n      this.treeFlattener\n    );\n\n\n\n  }\n\n\n  transformer = (node: BudgetTreeNode, level: number) => {\n    const existingNode = this.nestedNodeMap.get(node);\n    const flatNode =\n      existingNode && existingNode.qualifiedName === node.qualifiedName\n        ? existingNode\n        : new FlatBudgetTreeNode();\n    flatNode.name = node.name;\n    flatNode.qualifiedName = node.qualifiedName;\n    flatNode.level = level;\n    flatNode.expandable = (node.children != undefined && node.children.length > 0);\n    flatNode.budgetTreeNodeAmount = node.budgetTreeNodeAmount;\n    flatNode.budgetTreeNodeId = node.budgetTreeNodeId;\n    flatNode.budgetTreeNodeParentId = node.budgetTreeNodeParentId;\n    this.idToNodeMap.set(node.budgetTreeNodeId, node);\n\n    this.nestedNodeMap.set(node, flatNode);\n    this.qualifiedNameToNodeMap.set(node.qualifiedName, node);\n    return flatNode;\n  };\n\n  getLevel = (node: FlatBudgetTreeNode) => node.level;\n\n  isExpandable = (node: FlatBudgetTreeNode) => node.expandable;\n\n  getChildren = (node: BudgetTreeNode): BudgetTreeNode[] => node.children;\n\n  hasChild = (_: number, _nodeData: FlatBudgetTreeNode) => _nodeData.expandable;\n\n  inputChanged: boolean = false;\n  dataLoaded: boolean = false;\n  isSaved: boolean = false;\n\n\n  getRowClass(data: FlatBudgetTreeNode): string {\n    if (data.name === this.TOTAL_NODE_CATEGORY_NAME) {\n      return 'highlight-total-row';\n    }\n    if (this.currentSubTreeHasError && this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-error';\n    }\n    if (this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-no-error';\n    }\n    return '';\n  }\n\n\n  ngOnInit(): void {\n    this.appService.selectedBankAccountObservable$.subscribe(selectedAccount => {\n      if (selectedAccount) {\n        this.appService.findOrCreateBudget(selectedAccount).subscribe((response: BudgetTreeNode[]) => {\n\n          let filteredData = response.filter(node => node.name !== 'NO CATEGORY' && node.name !== 'DUMMY CATEGORY');\n          let totalBudgetTreeNode = this.initTotalBudgetTreeNode();\n          filteredData.push(totalBudgetTreeNode);\n          this.dataSource.data = filteredData;\n          let allBudgetNodes: BudgetTreeNode[] = [];\n          for (const node of response) {\n            if (node.name === 'NO CATEGORY' || node.name === 'DUMMY CATEGORY') {\n              continue;\n            }\n            allBudgetNodes.push(node);\n            this.getAllDescendantsRecursively(node, allBudgetNodes);\n          }\n\n\n          for (const node of allBudgetNodes) {\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            let control = new FormControl<number>(node.budgetTreeNodeAmount, [this.budgetValidator(), this.negativeNumberValidator()]);\n            this.idToControlsMap.set(node.budgetTreeNodeId, control);\n            control.valueChanges.subscribe((value) => {\n              if ((value !== undefined)) {\n                // this.inputChanged = false;\n                this.validateAllControls();\n                this.calculateTotalBudget();\n\n                let flatNode = this.nestedNodeMap.get(node);\n                if (flatNode){\n                  if (flatNode.name === this.TOTAL_NODE_CATEGORY_NAME) {\n                    //we don't want to do anything when the total node is changed\n                    return;\n                  }\n                  this.determineSubTreeForNode(flatNode as FlatBudgetTreeNode);\n                  if (!this.currentSubTreeHasError){\n                    this.onBudgetChange(flatNode as FlatBudgetTreeNode);\n                  }\n                }\n              }\n            });\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            this.controlsToIdMap.set(control, node.budgetTreeNodeId);\n            this.allControls.push(control);\n            this.mainForm.addControl(node.budgetTreeNodeId.toString(), control);\n          }\n          this.calculateTotalBudget();\n          this.dataLoaded = true;\n          this.treeControl.expandAll();\n\n        });\n      }\n    });\n\n  }\n\n  getDescendantIds(node: BudgetTreeNode, allDescendantIds: number[]) {\n    if (node.children && node.children.length > 0) {\n      node.children.forEach(child => {\n        allDescendantIds.push(child.budgetTreeNodeId);\n        this.getDescendantIds(child, allDescendantIds);\n      });\n    }\n  }\n\n  validateAllControls() {\n    Object.keys(this.mainForm.controls).forEach(key => {\n      const control = this.mainForm.get(key);\n      if (control) {\n        control.updateValueAndValidity({onlySelf: false, emitEvent: false});\n\n      }\n    });\n    this.mainForm.markAllAsTouched();\n  }\n\n  budgetValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isLessThanSumOfDescendants = this.isLessThanSumOfDescendants(control as FormControl);\n      return isLessThanSumOfDescendants ? {'isLessThanItsDescendants': {value: control.value}} : null;\n    };\n  }\n\n  negativeNumberValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isNegative = control.value < 0;\n      return isNegative ? {'negativeNumber': {value: control.value}} : null;\n    };\n  }\n\n  isLessThanSumOfDescendants(control: FormControl): boolean {\n    let nodeId = this.controlsToIdMap.get(control);\n    if (!nodeId) {\n      return false;\n    }\n\n    let nodeValue = control.value;\n\n    if (nodeValue == undefined || nodeValue < 0) {\n      return false;\n    }\n    let sumOfDescendants = 0;\n\n    let payload = this.idToBudgetNodeMap.get(nodeId) as BudgetTreeNode;\n    let allDescendantIds: number[] = [];\n    this.getDescendantIds(payload, allDescendantIds);\n\n    for (const descendantId of allDescendantIds) {\n      let descendantValue = this.idToControlsMap.get(descendantId)?.value;\n      if (descendantValue) {\n        sumOfDescendants = sumOfDescendants + descendantValue;\n\n      }\n    }\n\n\n    let isLessThanSumOfDescendants = nodeValue < sumOfDescendants;\n    //unpacking boolean for debugging purposes\n    return isLessThanSumOfDescendants;\n\n  }\n\n\n  determineSubTreeForNode(data: FlatBudgetTreeNode) {\n    this.rowsToHighlight = new Set<number>();\n    this.currentSubTreeHasError = false;\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n    this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n    if (budgetTreeNode.budgetTreeNodeParentId) {\n      //go one level up the tree to the parent. Add the id of the parent and all its descendants to the set of rows to highlight\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeParentId);\n      let parentBudgetTreeNode = this.idToNodeMap.get(budgetTreeNode.budgetTreeNodeParentId);\n      if (parentBudgetTreeNode == undefined) {\n        return;\n      }\n\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(parentBudgetTreeNode, allDescendantIds);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n\n\n\n    } else {\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(budgetTreeNode, allDescendantIds);\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n    }\n    this.currentSubTreeHasError = this.anyFormControlIsInvalid(this.rowsToHighlight);\n\n\n  }\n\n  private anyFormControlIsInvalid(ids: Set<number>): boolean {\n    let idsArray = [...ids];\n    for (const number of idsArray) {\n      if(this.formControlIsInvalid(number)){\n        return true;\n      }\n    }\n\n    return false;\n\n\n\n\n  }\n\n  private formControlIsInvalid(budgetTreeNodeId: number): boolean {\n    let control = this.mainForm.get(budgetTreeNodeId.toString());\n    if (control) {\n      return control.invalid;\n    }\n    return false;\n  }\n\n\n  /*onBlur() {\n    this.inputChanged = true;\n  }\n\n  onKeyUpEnter(event: Event) {\n    let kbe = event as KeyboardEvent;\n    if (kbe.key === 'Enter') {\n      this.inputChanged = true;\n    }\n  }*/\n\n  getAllDescendantsRecursively(budgetTreeNode: BudgetTreeNode, descendants: BudgetTreeNode[]) {\n    if (budgetTreeNode.children && budgetTreeNode.children.length > 0) {\n      budgetTreeNode.children.forEach(child => {\n        descendants.push(child);\n        this.getAllDescendantsRecursively(child, descendants);\n      });\n    }\n  }\n\n\n\n\n  onBudgetChange(data: FlatBudgetTreeNode): void {\n\n    let budgetControl = this.mainForm.get(data.budgetTreeNodeId.toString()) as FormControl;\n    if (budgetControl == undefined) {\n      return;\n    }\n    if (data.budgetTreeNodeAmount === undefined || data.budgetTreeNodeAmount === null) {\n      data.budgetTreeNodeAmount = 0;\n      budgetControl.setValue(0);\n    }\n\n\n    if (!budgetControl.valid) {\n      return;\n    }\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n\n\n    if (budgetTreeNode.budgetTreeNodeAmount !== budgetControl.value) {\n      budgetTreeNode.budgetTreeNodeAmount = budgetControl.value;\n    }\n\n    this.appService.updateBudgetEntryAmount(budgetTreeNode).subscribe(\n      (\n        response: UpdateBudgetEntryResponse\n      ) => {\n        if (response.response.toLowerCase() !== \"success\") {\n          throw new Error(\"Failed to update budget entry amount\");\n        }\n        // this.recalculateCumulatedAmountsForAllNodes();\n        this.treeControl.expandAll();\n      });\n\n  }\n\n  sameSubTreeAsFocusedBudgetNode(data: FlatBudgetTreeNode): boolean {\n    return this.rowsToHighlight.has(data.budgetTreeNodeId);\n\n  }\n\n\n  /*onInputChange() {\n    this.inputChanged = true\n  }*/\n\n  saveAll() {\n    if (this.mainForm.invalid) {\n      let invalidCategories: BudgetTreeNode[] = [];\n      Object.keys(this.mainForm.controls).forEach(key => {\n        const control = this.mainForm.get(key);\n        if (control && control.invalid) {\n          let node = this.idToNodeMap.get(parseInt(key));\n          if (!node) {\n            throw new Error(\"Failed to find node for id \" + key);\n          }\n          node.budgetTreeNodeAmount = control.value;\n          invalidCategories.push(node);\n\n\n        }\n      });\n      this.dialog.open(SaveErrorDialogComponent, {\n        data: {\n          message: 'Sommige wijzingen kunnen niet worden opgeslaan! Corrigeer de inconsistente budgetbedragen voor onderstaande categorieën en probeer opnieuw:',\n          nodes: invalidCategories\n        }\n      });\n    } else {\n      let budgetTreeNodes = this.dataSource.data;\n      for (const budgetTreeNode of budgetTreeNodes) {\n        if (budgetTreeNode.budgetTreeNodeId === this.TOTAL_NODE_ID) {\n          continue;\n        }\n        let flatNode = this.nestedNodeMap.get(budgetTreeNode);\n        if (!flatNode) {\n          throw new Error(\"Failed to find flat node for budget tree node \" + budgetTreeNode);\n        } else {\n          this.onBudgetChange(flatNode);\n        }\n\n\n      }\n\n\n\n\n\n\n    }\n  }\n\n\n  toggleTree(): void {\n    if (this.isTreeExpanded) {\n      this.treeControl.collapseAll();\n    } else {\n      this.treeControl.expandAll();\n    }\n    this.isTreeExpanded = !this.isTreeExpanded;\n  }\n\n  calculateTotalBudget(): void {\n    this.totalBudget = Array.from(this.idToControlsMap.values()).filter(control => control.valid)\n      .reduce((sum, control) => sum + (control.value || 0), 0);\n    let totalNode = {\n      budgetTreeNodeAmount: this.totalBudget,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n    this.dataSource.data = [totalNode, ...this.dataSource.data.slice(1, this.dataSource.data.length - 1), totalNode];\n    this.mainForm.get(totalNode.budgetTreeNodeId.toString())?.setValue(totalNode.budgetTreeNodeAmount);\n  }\n\n  initTotalBudgetTreeNode(): BudgetTreeNode {\n    return {\n      budgetTreeNodeAmount: 0,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n  }\n\n}\n\n\n",
            "properties": [
                {
                    "name": "errorMessage",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 72
                },
                {
                    "name": "failureReason",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined | null",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 71
                },
                {
                    "name": "response",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 70
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        },
        {
            "name": "User",
            "id": "interface-User-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "interface",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "properties": [
                {
                    "name": "bankAccounts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[] | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 265
                },
                {
                    "name": "email",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 264
                },
                {
                    "name": "firstName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 260
                },
                {
                    "name": "lastName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 261
                },
                {
                    "name": "password",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 263
                },
                {
                    "name": "userName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 262
                }
            ],
            "indexSignatures": [],
            "kind": 171,
            "methods": [],
            "extends": []
        }
    ],
    "injectables": [
        {
            "name": "AppService",
            "id": "injectable-AppService-ac0e63f85ee14c2eb813f292d8cfdb06b88c2a4c10a165c921cbce6cfdae396150d17b3712fb29e36830b06a246217800b8635aed214f3c3e598937d2c45a8cd",
            "file": "src/app/app.service.ts",
            "properties": [
                {
                    "name": "backendUrl",
                    "defaultValue": "environment.API_BASE_PATH",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 81,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "categoryMapObservable$",
                    "defaultValue": "this.categoryMapSubject.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 77,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "categoryMapSubject",
                    "defaultValue": "new BehaviorSubject<CategoryMap | undefined >(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 76,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "categoryQueryForSelectedPeriod$",
                    "defaultValue": "new BehaviorSubject<RevenueExpensesQuery |undefined>(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 67,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "categoryQueryForSelectedPeriodObservable$",
                    "defaultValue": "this.categoryQueryForSelectedPeriod$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 68,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "currentBankAccounts$",
                    "defaultValue": "new BehaviorSubject<BankAccount[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "currentBankAccountsObservable$",
                    "defaultValue": "this.currentBankAccounts$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54
                },
                {
                    "name": "DUMMY_BANK_ACCOUNT",
                    "defaultValue": "\"dummy\"",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "endDate$",
                    "defaultValue": "new BehaviorSubject<Date |undefined>(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "expensesRecurrence$",
                    "defaultValue": "new BehaviorSubject<string  | undefined>(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "fileUploadComplete$",
                    "defaultValue": "new Subject<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "grouping$",
                    "defaultValue": "new BehaviorSubject<GroupingEnum | undefined>(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 59,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "revenueRecurrence$",
                    "defaultValue": "new BehaviorSubject<string |undefined>(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 65,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "selectedBankAccount$",
                    "defaultValue": "new BehaviorSubject<BankAccount | undefined>(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "selectedBankAccountObservable$",
                    "defaultValue": "this.selectedBankAccount$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 75,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "selectedEndDate$",
                    "defaultValue": "this.endDate$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "selectedExpensesRecurrence$",
                    "defaultValue": "this.expensesRecurrence$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64
                },
                {
                    "name": "selectedGrouping$",
                    "defaultValue": "this.grouping$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "selectedRevenueRecurrence$",
                    "defaultValue": "this.revenueRecurrence$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 66
                },
                {
                    "name": "selectedStartDate$",
                    "defaultValue": "this.startDate$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56
                },
                {
                    "name": "selectedTransactionType$",
                    "defaultValue": "this.transactionType$.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "sharedCategoryTreeExpensesObservable$",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Observable<CategoryNode[]>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 71,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "sharedCategoryTreeObservable$",
                    "defaultValue": "of([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Observable<CategoryNode[]>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 70,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "sharedCategoryTreeRevenueObservable$",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Observable<CategoryNode[]>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 72,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "startDate$",
                    "defaultValue": "new BehaviorSubject<Date | undefined>(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "transactionType$",
                    "defaultValue": "new BehaviorSubject<TransactionTypeEnum | undefined>(undefined)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "camelToSnake",
                    "args": [
                        {
                            "name": "str",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 263,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "str",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "categorizeTransactions",
                    "args": [
                        {
                            "name": "userName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<TransactionsCategorizationResponse>",
                    "typeParameters": [],
                    "line": 534,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "userName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "convertSimplifiedCategoryToCategoryNode",
                    "args": [
                        {
                            "name": "simplified",
                            "type": "SimplifiedCategory",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "type",
                            "type": "TypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "CategoryNode",
                    "typeParameters": [],
                    "line": 120,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "simplified",
                            "type": "SimplifiedCategory",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "type",
                            "type": "TypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "countTransactionToManuallyReview",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Number>",
                    "typeParameters": [],
                    "line": 209,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "fetchBankAccountsForUser",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<BankAccount[]>",
                    "typeParameters": [],
                    "line": 196,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "findOrCreateBudget",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<BudgetTreeNode[]>",
                    "typeParameters": [],
                    "line": 496,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getCategoriesForAccountAndTransactionType",
                    "args": [
                        {
                            "name": "accountNumber",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 565,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "accountNumber",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getCategoryDetailsForPeriod",
                    "args": [
                        {
                            "name": "revenueExpensesQuery",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "category",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<CategoryDetailsForPeriodHandlerResult>",
                    "typeParameters": [],
                    "line": 554,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "revenueExpensesQuery",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "category",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getDistinctCounterpartyAccounts",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 465,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getDistinctCounterpartyNames",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 458,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getMergedCategoryTreeData",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<CategoryNode[]>",
                    "typeParameters": [],
                    "line": 140,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ]
                },
                {
                    "name": "getOrCreateRuleSetWrapper",
                    "args": [
                        {
                            "name": "category",
                            "type": "CategoryNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "categoryType",
                            "type": "TypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<RuleSetWrapper>",
                    "typeParameters": [],
                    "line": 525,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "category",
                            "type": "CategoryNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "categoryType",
                            "type": "TypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getRevenueAndExpensesByYear",
                    "args": [
                        {
                            "name": "restQuery",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Page<ExpensesAndRevenueForPeriod>>",
                    "typeParameters": [],
                    "line": 217,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "restQuery",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getRevenueExpensesPerPeriodAndCategoryShow1MonthBeforeAndAfter",
                    "args": [
                        {
                            "name": "restQuery",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<DistributionByCategoryForPeriodHandlerResult2>",
                    "typeParameters": [],
                    "line": 434,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "restQuery",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getSharedCategoryTreeExpensesObservable$",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 109,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "getSharedCategoryTreeRevenueObservable$",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 98,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "pageTransactions",
                    "args": [
                        {
                            "name": "request",
                            "type": "PageRequest<Transaction>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "transactionQuery",
                            "type": "TransactionQuery | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Page<Transaction>>",
                    "typeParameters": [],
                    "line": 276,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "request",
                            "type": "PageRequest<Transaction>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "transactionQuery",
                            "type": "TransactionQuery | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "pageTransactionsInContext",
                    "args": [
                        {
                            "name": "request",
                            "type": "PageRequest<Transaction>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "query",
                            "type": "TransactionInContextQuery",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Page<Transaction>>",
                    "typeParameters": [],
                    "line": 308,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "request",
                            "type": "PageRequest<Transaction>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "query",
                            "type": "TransactionInContextQuery",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "pageTransactionsToManuallyReview",
                    "args": [
                        {
                            "name": "request",
                            "type": "PageRequest<Transaction>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<Page<Transaction>>",
                    "typeParameters": [],
                    "line": 357,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "request",
                            "type": "PageRequest<Transaction>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "parseDate",
                    "args": [
                        {
                            "name": "json",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Date",
                    "typeParameters": [],
                    "line": 236,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "json",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "resolveStartEndDateShortcut",
                    "args": [
                        {
                            "name": "startEnDateShortCut",
                            "type": "StartEndDateShortcut",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<ResolvedStartEndDateShortcut>",
                    "typeParameters": [],
                    "line": 447,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "startEnDateShortCut",
                            "type": "StartEndDateShortcut",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "saveBankAccountAlias",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<void>",
                    "typeParameters": [],
                    "line": 544,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "saveRuleSetWrapper",
                    "args": [
                        {
                            "name": "ruleSetWrapper",
                            "type": "RuleSetWrapper",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<SuccessfulOperationResponse>",
                    "typeParameters": [],
                    "line": 520,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "ruleSetWrapper",
                            "type": "RuleSetWrapper",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "saveTransaction",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 251,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setBankAccount",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 162,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setCategoryQueryForSelectedPeriod$",
                    "args": [
                        {
                            "name": "query",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 167,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "query",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setExpensesRecurrence",
                    "args": [
                        {
                            "name": "selectedType",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 179,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "selectedType",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setGrouping",
                    "args": [
                        {
                            "name": "grouping",
                            "type": "GroupingEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 191,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "grouping",
                            "type": "GroupingEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setRevenueRecurrence",
                    "args": [
                        {
                            "name": "selectedType",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 183,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "selectedType",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setStartAndEndDate",
                    "args": [
                        {
                            "name": "start",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "end",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 172,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "start",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "end",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setTransactionType",
                    "args": [
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 187,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toPage",
                    "args": [
                        {
                            "name": "transactionsPage",
                            "type": "TransactionsPage",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Page<Transaction>",
                    "typeParameters": [],
                    "line": 267,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "transactionsPage",
                            "type": "TransactionsPage",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "trackBudget",
                    "args": [
                        {
                            "name": "restQuery",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<BudgetTrackerResult>",
                    "typeParameters": [],
                    "line": 421,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "restQuery",
                            "type": "RevenueExpensesQuery",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "updateBudgetEntryAmount",
                    "args": [
                        {
                            "name": "budgetEntry",
                            "type": "BudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<UpdateBudgetEntryResponse>",
                    "typeParameters": [],
                    "line": 506,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "budgetEntry",
                            "type": "BudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "uploadTransactionFiles",
                    "args": [
                        {
                            "name": "fileWrappers",
                            "type": "FileWrapper[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "userName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<HttpEvent<CompositeTransactionsFileUploadResponse>>",
                    "typeParameters": [],
                    "line": 472,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "fileWrappers",
                            "type": "FileWrapper[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "userName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import {HttpClient, HttpEvent, HttpHeaders} from '@angular/common/http';\nimport {Injectable} from '@angular/core';\nimport {BehaviorSubject, catchError, map, Observable, of, Subject, tap, throwError} from 'rxjs';\n\nimport {Page, PageRequest} from \"@daanvdn/ngx-pagination-data-source\";\nimport {\n    BudgetTrackerResult,\n    CategoryDetailsForPeriodHandlerResult,\n    CategoryMap,\n    CategoryNode,\n    CompositeTransactionsFileUploadResponse,\n    DistributionByCategoryForPeriodHandlerResult2,\n    FileWrapper,\n    ResolvedStartEndDateShortcut,\n    StartEndDateShortcut,\n    TransactionsCategorizationResponse\n} from './model';\nimport {AuthService} from \"./auth/auth.service\";\nimport {BudgetTreeNode, UpdateBudgetEntryResponse} from \"./budget/budget.component\";\nimport {\n    ApiBudgetAssistantBackendClientService,\n    BankAccount,\n    GroupingEnum,\n    PageTransactionsInContextRequest,\n    PageTransactionsToManuallyReviewRequest,\n    RevenueExpensesQuery, RuleSetWrapper,\n    SimplifiedCategory,\n    Transaction,\n    TransactionQuery,\n    TransactionTypeEnum,\n    TypeEnum\n} from \"@daanvdn/budget-assistant-client\";\nimport {environment} from \"../environments/environment\";\nimport {\n    RevenueAndExpensesPerPeriodResponse\n} from \"@daanvdn/budget-assistant-client\";\nimport {ExpensesAndRevenueForPeriod} from \"@daanvdn/budget-assistant-client\";\nimport {PageTransactionsRequest} from \"@daanvdn/budget-assistant-client\";\nimport {SortOrderEnum} from \"@daanvdn/budget-assistant-client\";\nimport {SortPropertyEnum} from \"@daanvdn/budget-assistant-client\";\nimport {TransactionsPage} from \"@daanvdn/budget-assistant-client\";\nimport {TransactionInContextQuery} from \"@daanvdn/budget-assistant-client\";\nimport {SuccessfulOperationResponse} from \"@daanvdn/budget-assistant-client\";\nimport {GetOrCreateRuleSetWrapper} from \"@daanvdn/budget-assistant-client\";\n\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class AppService {\n\n    public DUMMY_BANK_ACCOUNT = \"dummy\";\n    currentBankAccounts$ = new BehaviorSubject<BankAccount[]>([]);\n    currentBankAccountsObservable$ = this.currentBankAccounts$.asObservable();\n    private startDate$ = new BehaviorSubject<Date | undefined>(undefined);\n    selectedStartDate$ = this.startDate$.asObservable();\n    private endDate$ = new BehaviorSubject<Date |undefined>(undefined);\n    selectedEndDate$ = this.endDate$.asObservable();\n    private grouping$ = new BehaviorSubject<GroupingEnum | undefined>(undefined);\n    selectedGrouping$ = this.grouping$.asObservable();\n    private transactionType$ = new BehaviorSubject<TransactionTypeEnum | undefined>(undefined);\n    public selectedTransactionType$ = this.transactionType$.asObservable();\n    private expensesRecurrence$ = new BehaviorSubject<string  | undefined>(undefined);\n    selectedExpensesRecurrence$ = this.expensesRecurrence$.asObservable();\n    private revenueRecurrence$ = new BehaviorSubject<string |undefined>(undefined);\n    selectedRevenueRecurrence$ = this.revenueRecurrence$.asObservable();\n    private categoryQueryForSelectedPeriod$ = new BehaviorSubject<RevenueExpensesQuery |undefined>(undefined);\n    public categoryQueryForSelectedPeriodObservable$ = this.categoryQueryForSelectedPeriod$.asObservable();\n\n    public sharedCategoryTreeObservable$: Observable<CategoryNode[]> = of([]);\n    public sharedCategoryTreeExpensesObservable$: Observable<CategoryNode[]>;\n    public sharedCategoryTreeRevenueObservable$: Observable<CategoryNode[]>;\n    public fileUploadComplete$ = new Subject<void>();\n    public selectedBankAccount$ = new BehaviorSubject<BankAccount | undefined>(undefined);\n    public selectedBankAccountObservable$ = this.selectedBankAccount$.asObservable();\n    public categoryMapSubject = new BehaviorSubject<CategoryMap | undefined >(undefined);\n    public categoryMapObservable$ = this.categoryMapSubject.asObservable();\n\n\n\n    private backendUrl = environment.API_BASE_PATH;\n\n    constructor(private http: HttpClient, private authService: AuthService,\n                private apiBudgetAssistantBackendClientService: ApiBudgetAssistantBackendClientService) {\n\n\n        this.sharedCategoryTreeExpensesObservable$ = this.getSharedCategoryTreeExpensesObservable$();\n        this.sharedCategoryTreeRevenueObservable$ = this.getSharedCategoryTreeRevenueObservable$();\n        (async () => {\n            let categoryNodes: CategoryNode[] = await this.getMergedCategoryTreeData();\n            this.categoryMapSubject.next(new CategoryMap(categoryNodes));\n            this.sharedCategoryTreeObservable$ = of(categoryNodes);\n        })();\n\n\n    }\n\n    private getSharedCategoryTreeRevenueObservable$() {\n        return this.apiBudgetAssistantBackendClientService.apiCategoryTreeRetrieve('REVENUE').pipe(\n            map(categoryTree => {\n                const nodes: CategoryNode[] = [];\n                const rootNode = this.convertSimplifiedCategoryToCategoryNode(categoryTree.root, \"REVENUE\");\n                nodes.push(...rootNode.children);\n                return nodes;\n            })\n        );\n    }\n\n    private getSharedCategoryTreeExpensesObservable$() {\n        return this.apiBudgetAssistantBackendClientService.apiCategoryTreeRetrieve('EXPENSES').pipe(\n            map(categoryTree => {\n                const nodes: CategoryNode[] = [];\n                const rootNode = this.convertSimplifiedCategoryToCategoryNode(categoryTree.root, \"EXPENSES\");\n                nodes.push(...rootNode.children);\n                return nodes;\n            })\n        );\n    }\n\n    private convertSimplifiedCategoryToCategoryNode(simplified: SimplifiedCategory, type: TypeEnum): CategoryNode {\n        const children: CategoryNode[] = simplified.children.map(childObj => {\n            const [name, value] = Object.entries(childObj)[0];\n            return this.convertSimplifiedCategoryToCategoryNode({\n                name: name,\n                qualifiedName: (value as unknown as SimplifiedCategory).qualifiedName,\n                children: (value as unknown as SimplifiedCategory).children || [],\n            id : (value as unknown as SimplifiedCategory).id\n            }, type);\n        });\n\n        return {\n            name: simplified.name,\n            qualifiedName: simplified.qualifiedName,\n            children: children,\n            type: type, id : simplified.id\n        };\n    }\n\n\n    private async getMergedCategoryTreeData(): Promise<CategoryNode[]> {\n\n        let allData: CategoryNode[] = [];\n        let expenses = await this.getSharedCategoryTreeExpensesObservable$().toPromise();\n        let revenue = await this.getSharedCategoryTreeRevenueObservable$().toPromise();\n\n        if (expenses == undefined || revenue == undefined) {\n            throw new Error(\"expenses or revenue is undefined!\");\n        }\n\n        allData = allData.concat(expenses);\n        for (const categoryNode of revenue) {\n            if (!(categoryNode.name === \"NO CATEGORY\" || categoryNode.name === \"DUMMY CATEGORY\")) {\n                allData.push(categoryNode);\n            }\n\n        }\n        return allData;\n\n\n    }\n\n    setBankAccount(bankAccount: BankAccount) {\n        this.selectedBankAccount$.next(bankAccount);\n    }\n\n\n    setCategoryQueryForSelectedPeriod$(query: RevenueExpensesQuery) {\n        this.categoryQueryForSelectedPeriod$.next(query);\n    }\n\n\n    setStartAndEndDate(start: Date, end: Date) {\n        this.startDate$.next(start);\n        this.endDate$.next(end);\n\n    }\n\n\n    setExpensesRecurrence(selectedType: string) {\n        this.expensesRecurrence$.next(selectedType)\n    }\n\n    setRevenueRecurrence(selectedType: string) {\n        this.revenueRecurrence$.next(selectedType)\n    }\n\n    setTransactionType(transactionType: TransactionTypeEnum) {\n        this.transactionType$.next(transactionType);\n    }\n\n    setGrouping(grouping: GroupingEnum) {\n        this.grouping$.next(grouping);\n    }\n\n\n    public fetchBankAccountsForUser(): Observable<BankAccount[]> {\n\n\n        this.apiBudgetAssistantBackendClientService.apiBankAccountsList().subscribe(result => {\n            this.currentBankAccounts$.next(result);\n        })\n\n\n        return this.currentBankAccountsObservable$;\n\n\n    }\n\n    public countTransactionToManuallyReview(bankAccount: BankAccount): Observable<Number> {\n        return this.apiBudgetAssistantBackendClientService.apiTransactionsCountTransactionsToManuallyReviewRetrieve(\n            bankAccount.accountNumber).pipe(map(count => count.count));\n\n\n    }\n\n\n    public getRevenueAndExpensesByYear(restQuery: RevenueExpensesQuery): Observable<Page<ExpensesAndRevenueForPeriod>> {\n\n        return this.apiBudgetAssistantBackendClientService.apiRevenueExpensesPerPeriodCreate(restQuery)\n            .pipe(map((response: RevenueAndExpensesPerPeriodResponse) => {\n                    let page: Page<ExpensesAndRevenueForPeriod> = {\n                        content: response.content,\n                        number: response.number,\n                        size: response.size,\n                        totalElements: response.totalElements\n\n                    }\n                    return page;\n\n\n                }\n            ));\n\n    }\n\n    private parseDate(json: string): Date {\n        let parts: string[] = json.split('-');\n        let day: number = parseInt(parts[0])\n        let month: number = parseInt(parts[1])\n        let year: number = parseInt(parts[2])\n        let dateObj = new Date();\n        dateObj.setDate(day);\n        dateObj.setMonth(month);\n        dateObj.setFullYear(year);\n\n\n        return dateObj;\n\n    }\n\n    public saveTransaction(transaction: Transaction): void {\n\n        this.apiBudgetAssistantBackendClientService.apiTransactionsSaveTransactionCreate(transaction).subscribe({\n            next: () => {\n            },\n            error: (error) => console.error('Error saving transaction:', error)\n        });\n\n\n\n    }\n\n    private camelToSnake(str: string): string {\n        return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);\n    }\n\n    private toPage(transactionsPage: TransactionsPage): Page<Transaction> {\n        return {\n            content: transactionsPage.content,\n            number: transactionsPage.number,\n            size: transactionsPage.size,\n            totalElements: transactionsPage.totalElements\n        };\n    }\n\n    public pageTransactions(request: PageRequest<Transaction>,\n                            transactionQuery: TransactionQuery | undefined): Observable<Page<Transaction>> {\n        let tmpSortOrder = \"asc\";\n        if (request.sort && request.sort.order) {\n            tmpSortOrder = request.sort.order;\n        }\n\n        let tmpSortProperty = \"bookingDate\";\n        if (request.sort && request.sort.property) {\n\n            tmpSortProperty = request.sort.property;\n        }\n        let pageTransactionsRequest: PageTransactionsRequest = {\n            page: request.page,\n            size: request.size,\n            sortOrder: tmpSortOrder as SortOrderEnum,\n            sortProperty: this.camelToSnake(tmpSortProperty) as SortPropertyEnum,\n            query: transactionQuery\n\n        }\n        return this.apiBudgetAssistantBackendClientService.apiTransactionsPageTransactionsCreate(\n            pageTransactionsRequest).pipe(map((result: TransactionsPage) => {\n\n            return this.toPage(result);\n\n\n        }));\n\n\n\n    }\n\n    public pageTransactionsInContext(request: PageRequest<Transaction>,\n                                     query: TransactionInContextQuery): Observable<Page<Transaction>> {\n        let tmpSortOrder = \"asc\";\n        if (request.sort && request.sort.order) {\n            tmpSortOrder = request.sort.order;\n        }\n\n        let tmpSortProperty = \"bookingDate\";\n        if (request.sort && request.sort.property) {\n\n            tmpSortProperty = request.sort.property;\n        }\n        let pageTransactionsInContextRequest: PageTransactionsInContextRequest = {\n            page: request.page,\n            size: request.size,\n            sortOrder: tmpSortOrder as SortOrderEnum,\n            sortProperty: this.camelToSnake(tmpSortProperty) as SortPropertyEnum,\n            query: query\n\n        }\n        return this.apiBudgetAssistantBackendClientService.apiTransactionsPageTransactionsInContextCreate(\n            pageTransactionsInContextRequest).pipe( map(result => {\n            return this.toPage(result);\n        }));\n/*        let orig = this.http.get<Page<string>>(`${this.backendUrl}/page_transactions_in_context`, {params});\n        return orig.pipe(map(p => {\n\n            let newContent: Transaction[] = p.content.map(t => JSON.parse(t, (k, v) => {\n\n                if (k == \"bookingDate\" || k == \"currencyDate\") {\n                    return this.parseDate(v)\n                }\n                else {\n                    return v;\n                }\n\n            }))\n\n\n            let newPage: Page<Transaction> = {\n                content: newContent, number: p.number, size: p.size, totalElements: p.totalElements\n\n            }\n\n            return newPage;\n\n        }))*/\n    }\n\n    public pageTransactionsToManuallyReview(request: PageRequest<Transaction>,\n                                            transactionType: TransactionTypeEnum): Observable<Page<Transaction>> {\n        let bankAccount = this.selectedBankAccount$.getValue();\n        if (bankAccount == null) {\n            throw new Error(\"Bank account is not defined!\");\n        }\n        let tmpSortOrder = \"asc\";\n        if (request.sort && request.sort.order) {\n            tmpSortOrder = request.sort.order;\n        }\n\n        let tmpSortProperty = \"counterparty\";\n        if (request.sort && request.sort.property) {\n\n            tmpSortProperty = request.sort.property;\n        }\n\n\n        let pageTransactionsToManuallyReviewRequest : PageTransactionsToManuallyReviewRequest = {\n            page: request.page,\n            size: request.size,\n            sortOrder: tmpSortOrder as SortOrderEnum,\n            sortProperty: this.camelToSnake(tmpSortProperty) as SortPropertyEnum,\n            bankAccount: bankAccount.accountNumber,\n            transactionType: transactionType\n\n\n        }\n        return this.apiBudgetAssistantBackendClientService.apiTransactionsPageTransactionsToManuallyReviewCreate(pageTransactionsToManuallyReviewRequest).pipe(\n            map(result => {\n                return this.toPage(result);\n            })\n\n        );\n\n        /*\n\n        return orig.pipe(map(p => {\n\n            let newContent: Transaction[] = p.content.map(t => JSON.parse(t, (k, v) => {\n\n                if (k == \"bookingDate\" || k == \"currencyDate\") {\n                    return this.parseDate(v)\n                }\n                else {\n                    return v;\n                }\n\n            }))\n\n\n            let newPage: Page<Transaction> = {\n                content: newContent, number: p.number, size: p.size, totalElements: p.totalElements\n\n            }\n\n            return newPage;\n\n        }))\n*/\n\n    }\n\n\n    public trackBudget(restQuery: RevenueExpensesQuery): Observable<BudgetTrackerResult> {\n        const params = {\n            query: JSON.stringify(restQuery), responseType: \"json\"\n        }\n        return this.http.get<BudgetTrackerResult>(`${this.backendUrl}/track_budget`, {params}).pipe(\n            catchError(error => {\n                console.error('Error occurred:', error);\n                return throwError(error);\n            })\n        );\n    }\n\n\n    public getRevenueExpensesPerPeriodAndCategoryShow1MonthBeforeAndAfter(restQuery: RevenueExpensesQuery): Observable<DistributionByCategoryForPeriodHandlerResult2> {\n\n\n        const params = {\n            query: JSON.stringify(restQuery), responseType: \"json\"\n\n        }\n        return this.http.get<DistributionByCategoryForPeriodHandlerResult2>(\n            `${this.backendUrl}/revenue_expenses_per_period_and_category_show_1_month_before_and_after`, {params})\n\n    }\n\n\n    public resolveStartEndDateShortcut(startEnDateShortCut: StartEndDateShortcut): Observable<ResolvedStartEndDateShortcut> {\n\n        const params = {\n            \"query\": startEnDateShortCut\n        }\n        return this.http.get<ResolvedStartEndDateShortcut>(`${this.backendUrl}/resolve_start_end_date_shortcut`,\n            {params})\n\n    }\n\n\n    public getDistinctCounterpartyNames(bankAccount: string): Observable<string[]> {\n        const params = {\n            account: bankAccount\n        }\n        return this.http.get<string[]>(`${this.backendUrl}/distinct_counterparty_names`, {params})\n    }\n\n    public getDistinctCounterpartyAccounts(bankAccount: string): Observable<string[]> {\n        const params = {\n            account: bankAccount\n        }\n        return this.http.get<string[]>(`${this.backendUrl}/distinct_counterparty_accounts`, {params})\n    }\n\n    public uploadTransactionFiles(fileWrappers: FileWrapper[],\n                                  userName: string): Observable<HttpEvent<CompositeTransactionsFileUploadResponse>> {\n\n        // Create a FormData instance\n        let formData = new FormData();\n\n\n        for (const fileWrapper of fileWrappers) {\n            fileWrapper.inProgress = true;\n            formData.append(\"files\", fileWrapper.file, fileWrapper.file.name);\n        }\n        formData.append(\"userName\", userName);\n\n\n        return this.http.post<CompositeTransactionsFileUploadResponse>(`${this.backendUrl}/upload_transactions`,\n            formData, {\n                reportProgress: true, observe: 'events'\n            }).pipe(tap(() => {\n            this.fetchBankAccountsForUser(); //fixme: need for subscription?\n            this.fileUploadComplete$.next();\n        }));\n\n    }\n\n    public findOrCreateBudget(bankAccount: BankAccount): Observable<BudgetTreeNode[]> {\n\n        const params = {\n            account: bankAccount.accountNumber\n        }\n        return this.http.get<BudgetTreeNode[]>(`${this.backendUrl}/find_or_create_budget`, {params})\n\n\n    }\n\n    public updateBudgetEntryAmount(budgetEntry: BudgetTreeNode): Observable<UpdateBudgetEntryResponse> {\n\n        const headers = new HttpHeaders().set('Content-Type', 'application/json; charset=utf-8');\n        const options = {headers: headers};\n\n        const body = JSON.stringify(budgetEntry);\n\n\n        return this.http.post<UpdateBudgetEntryResponse>(`${this.backendUrl}/update_budget_entry_amount`, body, options)\n\n\n    }\n\n\n    public saveRuleSetWrapper(ruleSetWrapper: RuleSetWrapper): Observable<SuccessfulOperationResponse> {\n        return this.apiBudgetAssistantBackendClientService.apiSaveRuleSetWrapperCreate(ruleSetWrapper)\n\n    }\n\n    public getOrCreateRuleSetWrapper(category: CategoryNode, categoryType: TypeEnum): Observable<RuleSetWrapper> {\n        const getOrCreateRuleSetWrapper: GetOrCreateRuleSetWrapper = {\n            categoryQualifiedName : category.qualifiedName,\n            type:  categoryType,\n        };\n        return this.apiBudgetAssistantBackendClientService.apiGetOrCreateRuleSetWrapperCreate(getOrCreateRuleSetWrapper)\n\n    }\n\n    public categorizeTransactions(userName: string): Observable<TransactionsCategorizationResponse> {\n\n        const params = {\n            userName: userName\n        }\n        return this.http.get<TransactionsCategorizationResponse>(`${this.backendUrl}/categorize_transactions`,\n            {params});\n\n    }\n\n    public saveBankAccountAlias(bankAccount: BankAccount): Observable<void> {\n        const headers = new HttpHeaders().set('Content-Type', 'application/json; charset=utf-8');\n        const options = {headers: headers};\n\n        const body = {\n            alias: bankAccount.alias, accountNumber: bankAccount.accountNumber\n        };\n        return this.http.post<void>(`${this.backendUrl}/save_bankacount_alias`, body, options)\n    }\n\n    public getCategoryDetailsForPeriod(revenueExpensesQuery: RevenueExpensesQuery, category:string): Observable<CategoryDetailsForPeriodHandlerResult>{\n        const params = {\n            query: JSON.stringify(revenueExpensesQuery),\n            category: category,\n            responseType: \"json\"\n\n        }\n        return this.http.get<CategoryDetailsForPeriodHandlerResult>(\n            `${this.backendUrl}/get_category_details_for_period`, {params})\n    }\n\n    public getCategoriesForAccountAndTransactionType(accountNumber: string, transactionType: TransactionTypeEnum): Observable<string[]>{\n\n        const params = {\n            accountNumber: accountNumber,\n            transactionType: transactionType\n        }\n        return this.http.get<string[]>(\n            `${this.backendUrl}/get_categories_for_account_and_transaction_type`, {params})\n\n    }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "apiBudgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 81,
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "apiBudgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "AuthGuard",
            "id": "injectable-AuthGuard-a3c1c4c47dbc763ecaa905821e6ca2c84af6dff79f15bf9d7ff2cd58e3b93abbeabde7403410731bab53faf5826a1ff2540854ae5dd4b9f673505b7cdc2f3945",
            "file": "src/app/auth/auth.guard.ts",
            "properties": [],
            "methods": [
                {
                    "name": "canActivate",
                    "args": [
                        {
                            "name": "next",
                            "type": "ActivatedRouteSnapshot",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "state",
                            "type": "RouterStateSnapshot",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<boolean>",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "next",
                            "type": "ActivatedRouteSnapshot",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "state",
                            "type": "RouterStateSnapshot",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport { ActivatedRouteSnapshot, Router, RouterStateSnapshot } from '@angular/router';\nimport {Observable} from 'rxjs';\nimport {AuthService} from \"./auth.service\";\nimport {map, take} from 'rxjs/operators';\n\n@Injectable()\nexport class AuthGuard  {\n  constructor(private authService: AuthService, private router: Router) {\n  }\n\n  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> {\n    return this.authService.isLoggedIn.pipe(\n      take(1),\n      map((isLoggedIn: boolean) => {\n        if (!isLoggedIn) {\n          this.router.navigate(['/login']);\n          return false;\n        }\n        return true;\n      })\n    );\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "router",
                        "type": "Router",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 8,
                "jsdoctags": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "router",
                        "type": "Router",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "AuthService",
            "id": "injectable-AuthService-192661d47c17b7eb1c734b22cbe056f867c89d87cc6bad58faf033b9024ed6fef04162a89ba5a5cf0ab25861c66138ff049fbdac773d30e078492f42685f3a8d",
            "file": "src/app/auth/auth.service.ts",
            "properties": [
                {
                    "name": "loggedIn",
                    "defaultValue": "new BehaviorSubject<boolean>(false)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BehaviorSubject<boolean>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "user",
                    "defaultValue": "new BehaviorSubject<User>(DUMMY_USER)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BehaviorSubject<User>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getUser",
                    "args": [],
                    "optional": false,
                    "returnType": "User",
                    "typeParameters": [],
                    "line": 75,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "getUserObservable",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<User>",
                    "typeParameters": [],
                    "line": 69,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "login",
                    "args": [
                        {
                            "name": "user",
                            "type": "User",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<LoginResponse>",
                    "typeParameters": [],
                    "line": 80,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "user",
                            "type": "User",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "logout",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 159,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "parseRegisterResponse",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "RegisterResponse",
                    "typeParameters": [],
                    "line": 151,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "register",
                    "args": [
                        {
                            "name": "user",
                            "type": "User",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<RegisterResponse>",
                    "typeParameters": [],
                    "line": 114,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "user",
                            "type": "User",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import {Injectable} from '@angular/core';\nimport {Router} from '@angular/router';\nimport {BehaviorSubject, map, Observable} from 'rxjs';\n\nimport {DUMMY_USER, User} from \"../model\";\nimport { HttpClient } from \"@angular/common/http\";\nimport {\n  ApiBudgetAssistantBackendClientService,\n  RegisterUser,\n  TokenObtainPair,\n} from '@daanvdn/budget-assistant-client';\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\n\nexport enum Response {\n  SUCCESS = \"SUCCESS\",\n  FAILED = \"FAILED\",\n}\n\nexport enum RegisterFailureReason{\n  USER_ALREADY_EXISTS,\n  EMPTY_FIELDS,\n  SERVER_ERROR\n}\nexport enum LoginFailureReason{\n  PASSWORD_USER_COMBINATION_IS_WRONG,\n  SERVER_ERROR\n}\n\nexport interface LoginResponse {\n\n  response: Response;\n  errorMessage: string;\n  user: User;\n  failureReason: LoginFailureReason | null;\n\n\n}\nexport interface RegisterResponse {\n\n  response: Response;\n  errorMessage: string;\n  user: User;\n  failureReason: RegisterFailureReason | null;\n\n\n}\n\n@Injectable({\n  providedIn: 'root',\n})\n\nexport class AuthService {\n  private loggedIn: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);\n  private user: BehaviorSubject<User> = new BehaviorSubject<User>(DUMMY_USER);\n\n\n  constructor(private router: Router, private apiBudgetAssistantBackendClientService: ApiBudgetAssistantBackendClientService,\n              private errorDialogService: ErrorDialogService,\n              ) {\n\n  }\n\n\n  get isLoggedIn() {\n    return this.loggedIn.asObservable();\n  }\n\n\n  public getUserObservable(): Observable<User> {\n\n    return this.user.asObservable();\n  }\n\n\n  public getUser(): User {\n    return this.user.getValue();\n  }\n\n\n  login(user: User): Observable<LoginResponse> {\n    const loginPayload: TokenObtainPair = {\n      username: user.userName as string,\n      password: user.password as string,\n      access: '',\n      refresh: ''\n    };\n    return this.apiBudgetAssistantBackendClientService.apiTokenCreate(loginPayload, 'response').pipe(map(response => {\n          if (!response.ok || !response.body?.access) {\n            this.loggedIn.next(false);\n            return {\n              response: Response.FAILED,\n              errorMessage: response.statusText,\n              user: DUMMY_USER,\n              failureReason: LoginFailureReason.PASSWORD_USER_COMBINATION_IS_WRONG\n            };\n\n          }\n          this.loggedIn.next(true);\n          this.user.next(user);\n          sessionStorage.setItem('jwtToken', response.body.access);\n          this.router.navigate(['/profiel']);\n          return {\n            response: Response.SUCCESS,\n            errorMessage: '',\n            user: user,\n            failureReason: null\n          }\n        })\n    );\n\n\n  }\n\n  register(user: User): Observable<RegisterResponse> {\n    let registerUser\n        :\n        RegisterUser = {\n      username: user.email as string,\n      password: user.password as string,\n      email: user.email as string,\n\n    }\n    return this.apiBudgetAssistantBackendClientService.apiRegisterCreate(registerUser, 'response', true).pipe(map(response => {\n      if (response.ok) {\n        this.loggedIn.next(true);\n        this.user.next(user);\n        this.router.navigate(['/login']);\n        return {\n            response: Response.SUCCESS,\n            errorMessage: '',\n            user: user,\n            failureReason: RegisterFailureReason.USER_ALREADY_EXISTS\n        }\n      }\n      else {\n        return {\n          response: Response.FAILED,\n          errorMessage: response.statusText,\n          user: DUMMY_USER,\n          failureReason: RegisterFailureReason.SERVER_ERROR\n        }\n      }\n    }));\n\n\n\n\n  }\n\n\n  private parseRegisterResponse(data: any): RegisterResponse {\n    return {\n      ...data,\n      failureReason: RegisterFailureReason[data.failureReason as keyof typeof RegisterFailureReason]\n    };\n  }\n\n\n  logout() {\n    this.loggedIn.next(false);\n    this.user.next(DUMMY_USER);\n    //Call this.logoutService.logoutCreate() and handle error response\n    this.apiBudgetAssistantBackendClientService.apiLogoutCreate('response').subscribe(response => {\n      if (response.ok) {\n        this.router.navigate(['/login']);\n\n      }\n      else {\n        this.errorDialogService.openErrorDialog(\"Logout failed!\", response.statusText);\n      }\n    });\n\n\n  }\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "router",
                        "type": "Router",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "apiBudgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 54,
                "jsdoctags": [
                    {
                        "name": "router",
                        "type": "Router",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "apiBudgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "accessors": {
                "isLoggedIn": {
                    "name": "isLoggedIn",
                    "getSignature": {
                        "name": "isLoggedIn",
                        "type": "",
                        "returnType": "",
                        "line": 64
                    }
                }
            },
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "ContextMenuService",
            "id": "injectable-ContextMenuService-20562cd5cae57d3c7655875ed70c4e5d58bd6abaf71cf8cf229e66e8d61c3a623bb92d8de6b6b8cd07e0fff39df1dfe2e6562130169c1053ab4da04569161918",
            "file": "src/app/revenue-expenses-per-period-and-category/context-menu.service.ts",
            "properties": [
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 12
                }
            ],
            "methods": [
                {
                    "name": "getData",
                    "args": [],
                    "optional": false,
                    "returnType": "CategoryAndPeriod",
                    "typeParameters": [],
                    "line": 18,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "setData",
                    "args": [
                        {
                            "name": "data",
                            "type": "CategoryAndPeriod",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 14,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "CategoryAndPeriod",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\n\nexport interface CategoryAndPeriod{\n    category: string;\n    period: string;\n\n}\n@Injectable({\n  providedIn: 'root'\n})\nexport class ContextMenuService {\n  data: any;\n\n  setData(data: CategoryAndPeriod): void {\n    this.data = data;\n  }\n\n  getData() : CategoryAndPeriod{\n    return this.data;\n  }\n}",
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "ErrorDialogService",
            "id": "injectable-ErrorDialogService-ebce826fc5d1fc0366827207c35a618afe3fa0fea15d7dd1e87da413978deac9cdacd4879b6fa810289044392a4c427c37ba9dce713ce14d00c43579f53234c0",
            "file": "src/app/error-dialog/error-dialog.service.ts",
            "properties": [],
            "methods": [
                {
                    "name": "openErrorDialog",
                    "args": [
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "reason",
                            "type": "string | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 11,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "message",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "reason",
                            "type": "string | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\nimport { MatDialog } from '@angular/material/dialog';\nimport { ErrorDialogComponent } from './error-dialog.component';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ErrorDialogService {\n  constructor(private dialog: MatDialog) {}\n\n  openErrorDialog(message: string, reason: string | undefined): void {\n    this.dialog.open(ErrorDialogComponent, {\n      data: { message: message, reason: reason },\n    });\n  }\n\n\n\n\n\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 8,
                "jsdoctags": [
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "type": "injectable"
        },
        {
            "name": "FileUploaderService",
            "id": "injectable-FileUploaderService-9b661f3ff62cb1f681eeb7609de5f96746c995a7fb0ac35469a6b9e3344c87b09ad4ab7546c59715a0d90d975609307e02f35e3e49a3d75f836682282d5d3491",
            "file": "src/app/file-uploader.service.ts",
            "properties": [
                {
                    "name": "_files",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FileQueueObject[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "_queue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BehaviorSubject<FileQueueObject[]>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 51,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "url",
                    "defaultValue": "'https://jsonplaceholder.typicode.com/posts'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "methods": [
                {
                    "name": "_addToQueue",
                    "args": [
                        {
                            "name": "file",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 90,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "file",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "_cancel",
                    "args": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 140,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "_removeFromQueue",
                    "args": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 103,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "_upload",
                    "args": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "FileQueueObject",
                    "typeParameters": [],
                    "line": 107,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "_uploadComplete",
                    "args": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "response",
                            "type": "HttpResponse<any>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 156,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "response",
                            "type": "HttpResponse<any>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "_uploadFailed",
                    "args": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "response",
                            "type": "HttpErrorResponse",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 165,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "response",
                            "type": "HttpErrorResponse",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "_uploadProgress",
                    "args": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "event",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 148,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "event",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "addToQueue",
                    "args": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 69,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "clearQueue",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "onCompleteItem",
                    "args": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "response",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 64,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "queueObj",
                            "type": "FileQueueObject",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "response",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "uploadAll",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 80,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import * as _ from 'lodash';\nimport { HttpClient, HttpErrorResponse, HttpEventType, HttpHeaders, HttpRequest, HttpResponse } from '@angular/common/http';\nimport { Injectable, Output } from '@angular/core';\nimport { BehaviorSubject, Subscription } from 'rxjs';\n\n\n\nexport enum FileQueueStatus {\n  Pending,\n  Success,\n  Error,\n  Progress\n}\n\nexport class FileQueueObject {\n  public file: any;\n  public status: FileQueueStatus = FileQueueStatus.Pending;\n  public progress: number = 0;\n  public request?: Subscription;\n  public response?: HttpResponse<any> | HttpErrorResponse;\n\n  constructor(file: any) {\n    this.file = file;\n    \n    \n  }\n\n  // actions\n  public upload = () => { /* set in service */ };\n  public cancel = () => { /* set in service */ };\n  public remove = () => { /* set in service */ };\n\n  // statuses\n  public isPending = () => this.status === FileQueueStatus.Pending;\n  public isSuccess = () => this.status === FileQueueStatus.Success;\n  public isError = () => this.status === FileQueueStatus.Error;\n  public inProgress = () => this.status === FileQueueStatus.Progress;\n  public isUploadable = () => this.status === FileQueueStatus.Pending || this.status === FileQueueStatus.Error;\n\n}\n\n// tslint:disable-next-line:max-classes-per-file\n@Injectable({\n  providedIn: 'root'\n})\nexport class FileUploaderService {\n\n\n  public url: string = 'https://jsonplaceholder.typicode.com/posts';\n\n  private _queue: BehaviorSubject<FileQueueObject[]>;\n  private _files: FileQueueObject[] = [];\n\n  constructor(private http: HttpClient) {\n    this._queue = <BehaviorSubject<FileQueueObject[]>>new BehaviorSubject(this._files);\n  }\n\n  // the queue\n  public get queue() {\n    return this._queue.asObservable();\n  }\n\n  // public events\n  public onCompleteItem(queueObj: FileQueueObject, response: any): any {\n    return { queueObj, response };\n  }\n\n  // public functions\n  public addToQueue(data: any) {\n    // add file to the queue\n    _.each(data, (file: any) => this._addToQueue(file));\n  }\n\n  public clearQueue() {\n    // clear the queue\n    this._files = [];\n    this._queue.next(this._files);\n  }\n\n  public uploadAll() {\n    // upload all except already successfull or in progress\n    _.each(this._files, (queueObj: FileQueueObject) => {\n      if (queueObj.isUploadable()) {\n        this._upload(queueObj);\n      }\n    });\n  }\n\n  // private functions\n  private _addToQueue(file: any) {\n    const queueObj = new FileQueueObject(file);\n\n    // set the individual object events\n    queueObj.upload = () => this._upload(queueObj);\n    queueObj.remove = () => this._removeFromQueue(queueObj);\n    queueObj.cancel = () => this._cancel(queueObj);\n\n    // push to the queue\n    this._files.push(queueObj);\n    this._queue.next(this._files);\n  }\n\n  private _removeFromQueue(queueObj: FileQueueObject) {\n    _.remove(this._files, queueObj);\n  }\n\n  private _upload(queueObj: FileQueueObject) {\n    // create form data for file\n    const form = new FormData();\n    form.append('file', queueObj.file, queueObj.file.name);\n\n    // upload file and report progress\n    const req = new HttpRequest('POST', this.url, form, {\n      reportProgress: true,\n    });\n\n    // upload file and report progress\n    queueObj.request = this.http.request(req).subscribe(\n      (event: any) => {\n        if (event.type === HttpEventType.UploadProgress) {\n          this._uploadProgress(queueObj, event);\n        } else if (event instanceof HttpResponse) {\n          this._uploadComplete(queueObj, event);\n        }\n      },\n      (err: HttpErrorResponse) => {\n        if (err.error instanceof Error) {\n          // A client-side or network error occurred. Handle it accordingly.\n          this._uploadFailed(queueObj, err);\n        } else {\n          // The backend returned an unsuccessful response code.\n          this._uploadFailed(queueObj, err);\n        }\n      }\n    );\n\n    return queueObj;\n  }\n\n  private _cancel(queueObj: FileQueueObject) {\n    // update the FileQueueObject as cancelled\n    queueObj.request?.unsubscribe();\n    queueObj.progress = 0;\n    queueObj.status = FileQueueStatus.Pending;\n    this._queue.next(this._files);\n  }\n\n  private _uploadProgress(queueObj: FileQueueObject, event: any) {\n    // update the FileQueueObject with the current progress\n    const progress = Math.round(100 * event.loaded / event.total);\n    queueObj.progress = progress;\n    queueObj.status = FileQueueStatus.Progress;\n    this._queue.next(this._files);\n  }\n\n  private _uploadComplete(queueObj: FileQueueObject, response: HttpResponse<any>) {\n    // update the FileQueueObject as completed\n    queueObj.progress = 100;\n    queueObj.status = FileQueueStatus.Success;\n    queueObj.response = response;\n    this._queue.next(this._files);\n    this.onCompleteItem(queueObj, response.body);\n  }\n\n  private _uploadFailed(queueObj: FileQueueObject, response: HttpErrorResponse) {\n    // update the FileQueueObject as errored\n    queueObj.progress = 0;\n    queueObj.status = FileQueueStatus.Error;\n    queueObj.response = response;\n    this._queue.next(this._files);\n  }\n\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 52,
                "jsdoctags": [
                    {
                        "name": "http",
                        "type": "HttpClient",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "accessors": {
                "queue": {
                    "name": "queue",
                    "getSignature": {
                        "name": "queue",
                        "type": "",
                        "returnType": "",
                        "line": 59
                    }
                }
            },
            "extends": [],
            "type": "injectable"
        }
    ],
    "guards": [],
    "interceptors": [
        {
            "name": "AuthInterceptor",
            "id": "injectable-AuthInterceptor-2e204443088941267219584a7294cee1215f71b13db44bf760638921dc7e436392e8bde6f90e250211d13a5d6374c36a2f9806a7fa8fc739266224a1317eac59",
            "file": "src/app/auth.interceptor.ts",
            "properties": [
                {
                    "name": "excludedUrls",
                    "defaultValue": "[\n    '/api/register/',\n    '/api/token/'\n\n  ]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10,
                    "modifierKind": [
                        123,
                        148
                    ]
                },
                {
                    "name": "jwtHelper",
                    "defaultValue": "new JwtHelperService()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getValidToken",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<string | null>",
                    "typeParameters": [],
                    "line": 40,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ]
                },
                {
                    "name": "intercept",
                    "args": [
                        {
                            "name": "req",
                            "type": "HttpRequest<any>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "next",
                            "type": "HttpHandler",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<HttpEvent<any>>",
                    "typeParameters": [],
                    "line": 24,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "req",
                            "type": "HttpRequest<any>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "next",
                            "type": "HttpHandler",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "refreshToken",
                    "args": [
                        {
                            "name": "token",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Promise<string | null>",
                    "typeParameters": [],
                    "line": 50,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ],
                    "jsdoctags": [
                        {
                            "name": "token",
                            "type": "string | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "retrieveNewToken",
                    "args": [],
                    "optional": false,
                    "returnType": "Promise<string | null>",
                    "typeParameters": [],
                    "line": 66,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123,
                        134
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { Injectable } from '@angular/core';\nimport { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor } from '@angular/common/http';\nimport {firstValueFrom, from, Observable, switchMap} from 'rxjs';\nimport {JwtHelperService} from \"@auth0/angular-jwt\";\nimport {Configuration, TokenObtainPair, ApiBudgetAssistantBackendClientService, TokenRefresh} from \"@daanvdn/budget-assistant-client\";\nimport {AuthService} from \"./auth/auth.service\";\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  private readonly excludedUrls: string[] = [\n    '/api/register/',\n    '/api/token/'\n\n  ];\n\n  private jwtHelper = new JwtHelperService();\n\n  constructor(\n      private budgetAssistantBackendClientService: ApiBudgetAssistantBackendClientService,\n      private config: Configuration,\n      private authService: AuthService  // Inject AppService for credentials\n  ) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (this.excludedUrls.some(url => req.url.includes(url))) {\n      return next.handle(req); // Skip adding the Authorization header\n    }\n    return from(this.getValidToken()).pipe(\n        switchMap(token => {\n          if (token) {\n            req = req.clone({\n              setHeaders: { Authorization: `Bearer ${token}` }\n            });\n          }\n          return next.handle(req);\n        })\n    );\n  }\n\n  private async getValidToken(): Promise<string | null> {\n    let token = this.config.lookupCredential('jwtAuth') || sessionStorage.getItem('jwtToken');\n\n    if (!token || this.jwtHelper.isTokenExpired(token)) {\n      const refreshedToken = await this.refreshToken(token);\n      return refreshedToken ? refreshedToken : this.retrieveNewToken();\n    }\n    return token;\n  }\n\n  private async refreshToken(token: string | null): Promise<string | null> {\n    if (!token) return null;\n\n    try {\n      const refreshPayload: TokenRefresh = { refresh: token, access: '' };\n      let source = this.budgetAssistantBackendClientService.apiTokenRefreshCreate(refreshPayload);\n      const response: TokenRefresh = await firstValueFrom(source);\n\n      this.config.credentials['jwtAuth'] = response.access;\n      sessionStorage.setItem('jwtToken', response.access);  // Store in localStorage\n      return response.access;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  private async retrieveNewToken(): Promise<string | null> {\n    try {\n      const user = await firstValueFrom(this.authService.getUserObservable());\n      if (!user) return null;\n\n      const loginPayload: TokenObtainPair = {\n        username: user.userName as string,\n        password: user.password as string,\n        access: '',\n        refresh: ''\n      };\n\n      const response: TokenObtainPair = await firstValueFrom(this.budgetAssistantBackendClientService.apiTokenCreate(loginPayload));\n\n      this.config.credentials['jwtAuth'] = response.access;\n      sessionStorage.setItem('jwtToken', response.access);  // Store in localStorage\n      return response.access;\n    } catch (error) {\n      return null;\n    }\n  }\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "budgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "config",
                        "type": "Configuration",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 16,
                "jsdoctags": [
                    {
                        "name": "budgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "config",
                        "type": "Configuration",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "type": "interceptor"
        },
        {
            "name": "JsonDateInterceptor",
            "id": "injectable-JsonDateInterceptor-62b4e3f127c2c03fb54ff99f08fe66a4b454d5ed84332b757ab3dddb55f17fdcf333544bd0348259e4753b516e6db7a0e7183e4d858dc26abeae314ecde977a5",
            "file": "src/app/JsonDateInterceptor.ts",
            "properties": [
                {
                    "name": "_isoDateFormat",
                    "defaultValue": "/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 10,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "convert",
                    "args": [
                        {
                            "name": "body",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 31,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "body",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "intercept",
                    "args": [
                        {
                            "name": "req",
                            "type": "HttpRequest<any>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "next",
                            "type": "HttpHandler",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<HttpEvent<any>>",
                    "typeParameters": [],
                    "line": 12,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "req",
                            "type": "HttpRequest<any>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "next",
                            "type": "HttpHandler",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isIsoDateString",
                    "args": [
                        {
                            "name": "value",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 23,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "description": "",
            "rawdescription": "\n",
            "sourceCode": "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n@Injectable()\nexport class JsonDateInterceptor implements HttpInterceptor {\n\n\n    private _isoDateFormat = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\n  \n    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n      return next.handle(req).pipe(map((val: HttpEvent<any>) => {\n        if (val instanceof HttpResponse) {\n          const body = val.body;\n          this.convert(body);\n        }\n        return val;\n      }));\n    }\n  \n  \n    isIsoDateString(value: any): boolean {\n      if (value === null || value === undefined) {\n        return false;\n      }\n      if (typeof value === 'string') {\n        return this._isoDateFormat.test(value);\n      } return false;\n    }\n    convert(body: any) {\n      if (body === null || body === undefined) {\n        return body;\n      }\n      if (typeof body !== 'object') {\n        return body;\n      }\n      for (const key of Object.keys(body)) {\n        const value = body[key];\n        if (this.isIsoDateString(value)) {\n          body[key] = new Date(value);\n        } else if (typeof value === 'object') {\n          this.convert(value);\n        }\n      }\n    }\n  }",
            "extends": [],
            "type": "interceptor"
        }
    ],
    "classes": [
        {
            "name": "BackingDatabase",
            "id": "class-BackingDatabase-32bf478a495183c644fb2a8f3cf7748e17ba31f7897af4b46118f618adae368a8edeca283ae501448a928b16fbcce92a6f62b6546bd3f3f8fe390bfd397e2547",
            "file": "src/app/category-tree-dropdown/category-tree-dropdown.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {SelectionModel} from '@angular/cdk/collections';\nimport {FlatTreeControl} from '@angular/cdk/tree';\nimport {Component, EventEmitter, Input, OnInit, Output, ViewChild} from '@angular/core';\nimport {\n  MatTree,\n  MatTreeFlatDataSource,\n  MatTreeFlattener,\n  MatTreeNode,\n  MatTreeNodeDef,\n  MatTreeNodePadding,\n  MatTreeNodeToggle\n} from '@angular/material/tree';\nimport {BehaviorSubject} from 'rxjs';\nimport {AppService} from '../app.service';\nimport {FormBuilder, FormGroup, FormsModule, ReactiveFormsModule} from \"@angular/forms\";\nimport {MatFormField} from \"@angular/material/form-field\";\nimport {MatAutocomplete, MatAutocompleteTrigger} from \"@angular/material/autocomplete\";\nimport {CategoryNode, FlatCategoryNode, NO_CATEGORY} from \"../model\";\nimport {MatInput} from '@angular/material/input';\nimport {MatOption} from '@angular/material/core';\nimport {MatIconButton} from '@angular/material/button';\nimport {MatCheckbox} from '@angular/material/checkbox';\nimport {MatIcon} from '@angular/material/icon';\nimport {TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\n\n\n// @Injectable({ providedIn: \"root\" })\nexport class BackingDatabase {\n  dataChange = new BehaviorSubject<CategoryNode[]>([]);\n  treeData?: any[];\n\n  get data(): CategoryNode[] {\n    return this.dataChange.value;\n  }\n\n  constructor(private appService: AppService, transactionTypeEnum: TransactionTypeEnum) {\n    this.initialize(transactionTypeEnum);\n  }\n\n\n\n  initialize(transactionTypeEnum: TransactionTypeEnum) {\n\n    switch (transactionTypeEnum) {\n      case TransactionTypeEnum.REVENUE:\n        this.appService.sharedCategoryTreeRevenueObservable$.subscribe(tree => {\n          this.treeData = tree;\n          // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n          //     file node as children.\n          const data = tree;\n\n          // Notify the change.\n          this.dataChange.next(data);\n\n        });\n        break;\n      case TransactionTypeEnum.EXPENSES:\n        this.appService.sharedCategoryTreeExpensesObservable$.subscribe(tree => {\n          this.treeData = tree;\n          // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n          //     file node as children.\n          const data = tree;\n\n          // Notify the change.\n          this.dataChange.next(data);\n\n        });\n        break;\n      case TransactionTypeEnum.BOTH:\n\n\n        this.appService.sharedCategoryTreeObservable$.subscribe(tree => {\n          this.treeData = tree;\n          // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n          //     file node as children.\n          const data = tree;\n\n          // Notify the change.\n          this.dataChange.next(data);\n\n        });\n        break;\n\n    }\n\n\n\n\n\n  }\n\n  public filter(filterText: string) {\n    let filteredTreeData;\n    if (filterText && filterText.trim().length > 0) {\n      // Filter the tree\n      function filter(array: any, text: any) {\n        const getChildren = (result: any[], object: { qualifiedName: string; children: any[]; }) => {\n\n          if (object.qualifiedName.toLowerCase() === text.toLowerCase() || object.qualifiedName.toLowerCase().includes(text.toLowerCase())) {\n            result.push(object);\n            return result;\n          }\n          if (Array.isArray(object.children)) {\n            const children = object.children.reduce(getChildren, []);\n            if (children.length) result.push({ ...object, children });\n          }\n          return result;\n        };\n\n        return array.reduce(getChildren, []);\n      }\n\n      filteredTreeData = filter(this.treeData, filterText);\n    } else {\n      // Return the initial tree\n      filteredTreeData = this.treeData;\n    }\n\n    // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n    // file node as children.\n    const data = filteredTreeData;\n    // Notify the change.\n    this.dataChange.next(data);\n  }\n}\n\n\n\n\n@Component({\n    selector: 'app-category-tree-dropdown',\n    templateUrl: './category-tree-dropdown.component.html',\n    styleUrls: ['./category-tree-dropdown.component.scss'],\n    standalone: true,\n    imports: [FormsModule, ReactiveFormsModule, MatFormField, MatInput, MatAutocompleteTrigger, MatAutocomplete, MatOption, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodeToggle, MatTreeNodePadding, MatIconButton, MatCheckbox, MatIcon]\n})\nexport class CategoryTreeDropdownComponent implements OnInit  {\n\n  /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n  flatNodeMap = new Map<FlatCategoryNode, CategoryNode>();\n\n  /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n  nestedNodeMap = new Map<CategoryNode, FlatCategoryNode>();\n\n  qualifiedNameToNodeMap = new Map<string, CategoryNode>();\n\n  @Input()\n  selectedCategoryQualifiedNameStr?: string;\n  selectedCategory?: CategoryNode;\n  selectedCategoryName?: string = \"select category\"\n  // treeControl = new NestedTreeControl<CategoryNode>(node => node.children);\n  treeControl!: FlatTreeControl<FlatCategoryNode>\n  dataSource!: MatTreeFlatDataSource<CategoryNode, FlatCategoryNode>;\n  @Input()\n  transactionTypeEnum?: TransactionTypeEnum;\n\n  @Output() selectionChange: EventEmitter<string> = new EventEmitter<string>();\n\n  @ViewChild('formField') formField!: MatFormField;\n  @ViewChild('autoCompleteTrigger') autoCompleteTrigger!: MatAutocompleteTrigger;\n\n\n\n\n  treeFlattener: MatTreeFlattener<CategoryNode, FlatCategoryNode>;\n\n  /** The selection for checklist */\n  checklistSelection = new SelectionModel<FlatCategoryNode>(false /* multiple */);\n  _database?: BackingDatabase;\n\n  constructor(private appService: AppService, private formBuilder: FormBuilder) {\n    this.categoryFormGroup = this.formBuilder.group({\n      queryForm: \"\", searchField: \"\"\n    });\n    this.treeFlattener = new MatTreeFlattener(\n      this.transformer,\n      this.getLevel,\n      this.isExpandable,\n      this.getChildren\n    );\n    this.treeControl = new FlatTreeControl<FlatCategoryNode>(\n      this.getLevel,\n      this.isExpandable\n    );\n    this.dataSource = new MatTreeFlatDataSource(\n      this.treeControl,\n      this.treeFlattener\n    );\n\n  }\n\n\n\n  ngOnInit(): void {\n\n    if (this.selectedCategoryQualifiedNameStr !== undefined) {\n      this.selectedCategory = this.qualifiedNameToNodeMap.get(this.selectedCategoryQualifiedNameStr);\n      if (this.selectedCategory !== undefined) {\n        let flatNode = this.nestedNodeMap.get(this.selectedCategory);\n        if (flatNode !== undefined) {\n          this.toggleSelectionWithoutEmittingChange(flatNode);\n\n        }\n      }\n\n    }\n    if (this.transactionTypeEnum !== undefined) {\n      this._database = new BackingDatabase(this.appService, this.transactionTypeEnum);\n      this._database.dataChange.subscribe(data => {\n        this.dataSource.data = data;\n      });\n    }\n\n\n  }\n\n\n  transformer = (node: CategoryNode, level: number) => {\n    const existingNode = this.nestedNodeMap.get(node);\n    const flatNode =\n      existingNode && existingNode.qualifiedName === node.qualifiedName\n        ? existingNode\n        : new FlatCategoryNode();\n    flatNode.name = node.name;\n    flatNode.nodeId = node.id;\n    flatNode.qualifiedName = node.qualifiedName;\n    flatNode.level = level;\n    flatNode.expandable = (node.children != undefined && node.children.length > 0);\n    flatNode.type = node.type;\n    this.flatNodeMap.set(flatNode, node);\n    this.nestedNodeMap.set(node, flatNode);\n    this.qualifiedNameToNodeMap.set(node.qualifiedName, node);\n    return flatNode;\n  };\n\n  getLevel = (node: FlatCategoryNode) => node.level;\n\n  isExpandable = (node: FlatCategoryNode) => node.expandable;\n\n  getChildren = (node: CategoryNode): CategoryNode[] => node.children;\n\n  hasChild = (_: number, _nodeData: FlatCategoryNode) => _nodeData.expandable;\n\n  hasNoContent = (_: number, _nodeData: FlatCategoryNode) => _nodeData.name === \"\";\n  categoryFormGroup: FormGroup;\n\n  filterChanged(event: Event) {\n\n    let filterText: string = (<HTMLInputElement>(event as InputEvent).target).value\n    // ChecklistDatabase.filter method which actually filters the tree and gives back a tree structure\n    this._database?.filter(filterText);\n    if (filterText) {\n      this.treeControl.expandAll();\n    } else {\n      this.treeControl.collapseAll();\n    }\n  }\n\n  toggleSelection(node: FlatCategoryNode): void {\n    this.checklistSelection.toggle(node);\n    if(this.checklistSelection.isSelected(node)){\n      this.selectedCategory = this.flatNodeMap.get(node);\n      this.selectedCategoryQualifiedNameStr = this.selectedCategory?.qualifiedName;\n      this.selectedCategoryName = this.selectedCategory?.name;\n      this.selectionChange.emit(this.selectedCategoryQualifiedNameStr);\n    } else{\n      this.selectedCategory = NO_CATEGORY;\n      this.selectedCategoryQualifiedNameStr = this.selectedCategory?.qualifiedName;\n      this.selectedCategoryName = \"selecteer categorie\";\n      this.selectionChange.emit(this.selectedCategoryQualifiedNameStr);\n    }\n    this.categoryFormGroup.controls['searchField'].reset();\n    this._database?.filter(\"\")\n    this.autoCompleteTrigger.closePanel();\n\n  }\n  toggleSelectionWithoutEmittingChange(node: FlatCategoryNode): void {\n    this.checklistSelection.toggle(node);\n    if(this.checklistSelection.isSelected(node)){\n      this.selectedCategory = this.flatNodeMap.get(node);\n      this.selectedCategoryQualifiedNameStr = this.selectedCategory?.qualifiedName;\n      this.selectedCategoryName = this.selectedCategory?.name;\n    } else {\n      this.selectedCategory = NO_CATEGORY;\n      this.selectedCategoryQualifiedNameStr = this.selectedCategory?.qualifiedName;\n      this.selectedCategoryName = \"selecteer categorie\";\n    }\n\n  }\n\n\n\n\n\n\n\n\n\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "transactionTypeEnum",
                        "type": "TransactionTypeEnum",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 34,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "transactionTypeEnum",
                        "type": "TransactionTypeEnum",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "dataChange",
                    "defaultValue": "new BehaviorSubject<CategoryNode[]>([])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29
                },
                {
                    "name": "treeData",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 30
                }
            ],
            "methods": [
                {
                    "name": "filter",
                    "args": [
                        {
                            "name": "filterText",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 92,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "filterText",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initialize",
                    "args": [
                        {
                            "name": "transactionTypeEnum",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 42,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transactionTypeEnum",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "accessors": {
                "data": {
                    "name": "data",
                    "getSignature": {
                        "name": "data",
                        "type": "[]",
                        "returnType": "CategoryNode[]",
                        "line": 32
                    }
                }
            },
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "CategoricalOperators",
            "id": "class-CategoricalOperators-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "ALL",
                    "defaultValue": "[CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Operator[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 95,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "EQUALS",
                    "defaultValue": "new Operator('equals', 'equals', 'categorical')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 94,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "IN",
                    "defaultValue": "new Operator('in', 'in', 'categorical')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 92,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "NOT_IN",
                    "defaultValue": "new Operator('not in', 'not in', 'categorical')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 93,
                    "modifierKind": [
                        126
                    ]
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "CategoryMap",
            "id": "class-CategoryMap-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "nodes",
                        "type": "CategoryNode[]",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 376,
                "jsdoctags": [
                    {
                        "name": "nodes",
                        "type": "CategoryNode[]",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "idToNameMap",
                    "defaultValue": "new Map<number, string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<number | string>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 373,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "qualifiedNameToIdMap",
                    "defaultValue": "new Map<string, number>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | number>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 374,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "qualifiedNameToNameMap",
                    "defaultValue": "new Map<string, string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | string>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 375,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "simpleCategoryMap",
                    "defaultValue": "new Map<string, SimpleCategory>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | SimpleCategory>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 376,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "getId",
                    "args": [
                        {
                            "name": "qualifiedName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "number",
                    "typeParameters": [],
                    "line": 409,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "qualifiedName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getName",
                    "args": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 401,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "id",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getSimpleCategory",
                    "args": [
                        {
                            "name": "qualifiedName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "SimpleCategory | null",
                    "typeParameters": [],
                    "line": 417,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "qualifiedName",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "populateMaps",
                    "args": [
                        {
                            "name": "node",
                            "type": "CategoryNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 384,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "node",
                            "type": "CategoryNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "CategoryTreeWrapper",
            "id": "class-CategoryTreeWrapper-4f05e9743491edc839389e7a4c4703c5b26e6de1bfb250d6e4a9d5a6917040fa285784e66e693611a7565ff325da8300bb8680be6443acb24dba40f080d064ac",
            "file": "src/app/rules-view/rules-view.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {NestedTreeControl} from '@angular/cdk/tree';\nimport {Component, Inject, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport { MatTreeNestedDataSource, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodeToggle, MatNestedTreeNode, MatTreeNodeOutlet } from \"@angular/material/tree\";\nimport {faNetworkWired, faPlay} from \"@fortawesome/free-solid-svg-icons\";\nimport { MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggle } from \"@angular/material/button-toggle\";\nimport { MAT_DIALOG_DATA, MatDialog, MatDialogRef, MatDialogTitle, MatDialogContent, MatDialogActions } from \"@angular/material/dialog\";\nimport {ActiveView, CategoryNode, TransactionsCategorizationResponse} from \"../model\";\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport {AuthService} from \"../auth/auth.service\";\nimport {faSearch} from \"@fortawesome/free-solid-svg-icons/faSearch\";\nimport { MatToolbar } from '@angular/material/toolbar';\nimport { MatIconButton, MatButton } from '@angular/material/button';\nimport { FaIconComponent } from '@fortawesome/angular-fontawesome';\nimport { MatTooltip } from '@angular/material/tooltip';\nimport { NgSwitch, NgSwitchCase } from '@angular/common';\nimport { MatIcon } from '@angular/material/icon';\nimport { RulesBuilderComponent } from '../rules-builder/rules-builder.component';\nimport { CdkScrollable } from '@angular/cdk/scrolling';\n\n\n@Component({\n    selector: 'app-dialog', templateUrl: './run-categorization-dialog-component.component.html',\n    standalone: true,\n    imports: [\n        MatDialogTitle,\n        CdkScrollable,\n        MatDialogContent,\n        MatDialogActions,\n        MatButton,\n    ],\n})\nexport class RunCategorizationDialogComponent {\n\n  constructor(public dialogRef: MatDialogRef<RunCategorizationDialogComponent>,\n              @Inject(MAT_DIALOG_DATA) public data: TransactionsCategorizationResponse) {\n  }\n\n  onOkClick(): void {\n    this.dialogRef.close();\n  }\n\n}\n\n@Component({\n    selector: 'app-expenses-rules-view',\n    templateUrl: './rules-view.component.html',\n    styleUrls: ['./rules-view.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, MatIconButton, FaIconComponent, MatTooltip, NgSwitch, NgSwitchCase, MatButtonToggleGroup, MatButtonToggle, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodeToggle, MatIcon, MatNestedTreeNode, MatTreeNodeOutlet, MatButton, RulesBuilderComponent]\n})\nexport class RulesViewComponent implements OnInit {\n\n  activeView: ActiveView = ActiveView.EXPENSES;\n  expensesCategoryWrapper!: CategoryTreeWrapper;\n  revenueCategoryTreeWrapper!: CategoryTreeWrapper;\n\n  selectedCategoryNode!: CategoryNode;\n\n\n  showCategoryTree: boolean = true;\n\n\n  constructor(private appService: AppService, public dialog: MatDialog,\n              private errorDialogService: ErrorDialogService, private authService: AuthService){\n  }\n\n\n  onClickCreateRule(node: CategoryNode){\n    this.selectedCategoryNode = node;\n    this.showCategoryTree= false;\n  }\n\n  ngOnInit(): void {\n    this.expensesCategoryWrapper = new CategoryTreeWrapper(this.appService, \"expenses\");\n    this.revenueCategoryTreeWrapper = new CategoryTreeWrapper(this.appService, \"revenue\");\n  }\n\n  hasChild = (_: number, node: CategoryNode) => !!node.children && node.children.length > 0;\n\n\n  protected readonly faNetworkWired = faNetworkWired;\n  protected readonly faPlay = faPlay;\n\n\n  getTooltip(node: any): string {\n    let qualifiedName = (node as CategoryNode).qualifiedName;\n    return `create rule for category ${qualifiedName}`\n\n  }\n\n  onToggleChange($event: MatButtonToggleChange) {\n    const value = $event.value;\n    if (value === \"expenses\") {\n      this.activeView = ActiveView.EXPENSES;\n    } else if (value === \"revenue\") {\n      this.activeView = ActiveView.REVENUE;\n    } else {\n      throw new Error(\"Unknown value \" + value);\n    }\n  }\n\n  protected readonly ActiveView = ActiveView;\n\n  onClickNavigateBackToCategories() {\n    this.showCategoryTree = true;\n  }\n\n  runRules() {\n    try {\n      let user = this.authService.getUser();\n      if (!user ||!user.userName) {\n        this.errorDialogService.openErrorDialog(\"Cannot run rules\", \"User is not defined!\");\n        return;\n      }\n\n      this.appService.categorizeTransactions(user.userName).subscribe(response => {\n          this.openDialog(response);\n        },\n\n        error => {\n          this.errorDialogService.openErrorDialog(\"Error running categorization\", error.message)\n        })\n    } catch (e) {\n\n      this.errorDialogService.openErrorDialog(\"Error running categorization\", (e as Error).message);\n    }\n  }\n\n  openDialog(data: TransactionsCategorizationResponse): void {\n    const dialogRef = this.dialog.open(RunCategorizationDialogComponent, {\n      minWidth: '400px', data: data\n    });\n\n\n  }\n\n  onChangeSelectedBankAccountsForCurrentRule($event: string[]) {\n\n  }\n\n  protected readonly faSearch = faSearch;\n}\n\n\nclass CategoryTreeWrapper {\n\n  treeControl = new NestedTreeControl<CategoryNode>(node => node.children);\n  dataSource = new MatTreeNestedDataSource<CategoryNode>();\n\n\n  constructor(private appService: AppService, type: string) {\n    const illegalNodes = [\"NO CATEGORY\", \"DUMMY CATEGORY\"]\n\n    const filterAndSortNodes = (nodes: CategoryNode[]) => {\n      return nodes.filter(n => !illegalNodes.includes(n.name)).sort((a, b) => a.name.localeCompare(b.name));\n    }\n\n\n    switch (type) {\n      case \"revenue\":\n        this.appService.sharedCategoryTreeRevenueObservable$.subscribe(nodes => {\n          this.dataSource.data = filterAndSortNodes(nodes);\n        })\n        break;\n      case \"expenses\":\n        this.appService.sharedCategoryTreeExpensesObservable$.subscribe(nodes => {\n          this.dataSource.data = filterAndSortNodes(nodes);\n        })\n        break;\n      default:\n        throw new Error(\"Unknown type \" + type + \"!\");\n    }\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "type",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 149,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "type",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "dataSource",
                    "defaultValue": "new MatTreeNestedDataSource<CategoryNode>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 149
                },
                {
                    "name": "treeControl",
                    "defaultValue": "new NestedTreeControl<CategoryNode>(node => node.children)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 148
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "Comparator",
            "id": "class-Comparator-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [],
            "methods": [
                {
                    "name": "bothAreArrays",
                    "args": [
                        {
                            "name": "o1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "o2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 844,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "o1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "o2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "checkArraysAreEqual",
                    "args": [
                        {
                            "name": "arr1",
                            "type": "any[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "arr2",
                            "type": "any[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 819,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "arr1",
                            "type": "any[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "arr2",
                            "type": "any[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "equals",
                    "args": [
                        {
                            "name": "o1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "o2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 804,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "o1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "o2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isObject",
                    "args": [
                        {
                            "name": "object",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 848,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "object",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isUndefinedOrNull",
                    "args": [
                        {
                            "name": "o",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 799,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "o",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "objectsAreEqual",
                    "args": [
                        {
                            "name": "obj1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "obj2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 852,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "obj1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "obj2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "Criteria",
            "id": "class-Criteria-d425afc1d11694167649cc509790fa84e34a5cf2fefe56fd50399ce310af670706a27ad1d2283640a2cca3d904779b3608ded31b024e780621033de09e72e8ef",
            "file": "src/app/model/criteria.model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { BankAccount, GroupingEnum, TransactionTypeEnum } from \"@daanvdn/budget-assistant-client\";\r\n\r\nexport class Criteria {\r\n    bankAccount: BankAccount;\r\n    grouping: GroupingEnum;\r\n    startDate: Date;\r\n    endDate: Date;\r\n    transactionType: TransactionTypeEnum | undefined;\r\n\r\n    constructor(bankAccount: BankAccount, grouping: GroupingEnum, startDate: Date, endDate: Date,\r\n                transactionType: TransactionTypeEnum | undefined) {\r\n        this.bankAccount = bankAccount;\r\n        this.grouping = grouping;\r\n        this.startDate = startDate;\r\n        this.endDate = endDate;\r\n        this.transactionType = transactionType;\r\n    }\r\n\r\n    public equals(criteria: Criteria): boolean {\r\n        if (!criteria || !criteria.bankAccount || !criteria.grouping || !criteria.startDate || !criteria.endDate) {\r\n            return false;\r\n        }\r\n        if (this.transactionType !== criteria.transactionType) {\r\n            return false;\r\n        }\r\n        return this.bankAccount.accountNumber === criteria.bankAccount.accountNumber &&\r\n            this.grouping === criteria.grouping &&\r\n            this.startDate === criteria.startDate &&\r\n            this.endDate === criteria.endDate &&\r\n            this.transactionType === criteria.transactionType;\r\n    }\r\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "bankAccount",
                        "type": "BankAccount",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "grouping",
                        "type": "GroupingEnum",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "startDate",
                        "type": "Date",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "endDate",
                        "type": "Date",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "transactionType",
                        "type": "TransactionTypeEnum | undefined",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 8,
                "jsdoctags": [
                    {
                        "name": "bankAccount",
                        "type": "BankAccount",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "grouping",
                        "type": "GroupingEnum",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "startDate",
                        "type": "Date",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "endDate",
                        "type": "Date",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "transactionType",
                        "type": "TransactionTypeEnum | undefined",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "bankAccount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccount",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 4
                },
                {
                    "name": "endDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 7
                },
                {
                    "name": "grouping",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "GroupingEnum",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 5
                },
                {
                    "name": "startDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 6
                },
                {
                    "name": "transactionType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionTypeEnum | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 8
                }
            ],
            "methods": [
                {
                    "name": "equals",
                    "args": [
                        {
                            "name": "criteria",
                            "type": "Criteria",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "criteria",
                            "type": "Criteria",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "Field",
            "id": "class-Field-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "name",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "pathFromTransaction",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "type",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "value",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "nullable",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "options",
                        "type": "Option[]",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "operators",
                        "type": "Operator[]",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 462,
                "jsdoctags": [
                    {
                        "name": "name",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "pathFromTransaction",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "type",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "value",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "nullable",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "options",
                        "type": "Option[]",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "operators",
                        "type": "Operator[]",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 455
                },
                {
                    "name": "nullable",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 459
                },
                {
                    "name": "operators",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Operator[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 462
                },
                {
                    "name": "options",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Option[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 461
                },
                {
                    "name": "pathFromTransaction",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 456
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 458
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 457
                }
            ],
            "methods": [
                {
                    "name": "clone",
                    "args": [],
                    "optional": false,
                    "returnType": "Field",
                    "typeParameters": [],
                    "line": 476,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "equals",
                    "args": [
                        {
                            "name": "field",
                            "type": "Field",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 489,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "Field",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "FieldsMetaData",
            "id": "class-FieldsMetaData-1e1147c4509ff29e4477775298d115a94a87726aec3cf64cb8cd8cf9946916cf01c5fe330c55ffa32e538e98f0c8f48bcb05c838b962fcf674b8c8d5617aa1fb",
            "file": "src/app/query-builder/query-builder.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { AbstractControl, ControlValueAccessor, FormBuilder, NG_VALIDATORS, NG_VALUE_ACCESSOR, ValidationErrors, Validator, ValidatorFn, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport {\n  CategoricalOperators, Comparator,\n  Field, FieldType,\n  LocalRuleMeta,\n  MATCH_TYPES, MatchTypes,\n  MultiMap, NumericalOperators, Operator,\n  Option,\n  QueryBuilderClassNames,\n  QueryBuilderConfig,\n  Rule,\n  RuleSet,\n  RuleUtils, StringOperators\n} from './query-builder.interfaces';\nimport {\n  ChangeDetectorRef, Component, ElementRef, forwardRef, HostBinding, Input, OnChanges, SimpleChanges, ViewChild\n} from '@angular/core';\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport {AppService} from \"../app.service\";\nimport { MatExpansionPanel, MatExpansionPanelHeader } from \"@angular/material/expansion\";\nimport { NgClass, NgIf, NgFor, NgSwitch, NgSwitchCase } from '@angular/common';\nimport { MatButton, MatIconButton } from '@angular/material/button';\nimport { MatFormField, MatError } from '@angular/material/form-field';\nimport { MatSelect } from '@angular/material/select';\nimport { MatOption } from '@angular/material/core';\nimport { MatInput } from '@angular/material/input';\nimport { MatIcon } from '@angular/material/icon';\nimport { MatCheckbox } from '@angular/material/checkbox';\nimport {FieldTypeEnum, RuleMatchType, RuleOperator} from \"@daanvdn/budget-assistant-client\";\nimport {ConditionEnum} from \"@daanvdn/budget-assistant-client\";\n\n\nexport class FieldsMetaData {\n\n  type2fields = new MultiMap<string, Field>();\n  field2Type = new Map<string, string>;\n\n\n  fieldToOptions = new MultiMap<string, Option>();\n\n  public registerField(field: Field): void {\n    this.type2fields.set(field.type, field);\n    this.field2Type.set(field.name as string, field.type);\n\n    if (field.options) {\n      for (const option of field.options) {\n        this.fieldToOptions.set(field.name as string, option);\n      }\n    }\n\n  }\n\n  public getFieldTypes(): string[] {\n    return this.type2fields.keys();\n  }\n\n  public getFieldType(field: string) {\n    let type = this.field2Type.get(field);\n    if (!type) {\n      return null;\n    }\n\n    return type;\n  }\n\n\n}\n\nexport const CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => QueryBuilderComponent),\n  multi: true\n};\n\nexport const VALIDATOR: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => QueryBuilderComponent),\n  multi: true\n};\n\n\n@Component({\n    selector: 'query-builder',\n    templateUrl: './query-builder.component.html',\n    styleUrls: ['./query-builder.component.scss'],\n    providers: [CONTROL_VALUE_ACCESSOR, VALIDATOR],\n    standalone: true,\n    imports: [NgClass, NgIf, FormsModule, NgFor, MatButton, ReactiveFormsModule, MatFormField, MatSelect, MatOption, NgSwitch, NgSwitchCase, MatError, MatExpansionPanel, MatExpansionPanelHeader, MatInput, MatIconButton, MatIcon, MatCheckbox]\n})\nexport class QueryBuilderComponent implements OnChanges, ControlValueAccessor, Validator {\n\n  protected readonly MATCH_TYPES = MATCH_TYPES;\n  protected readonly RuleUtils = RuleUtils;\n  public typeToFieldMapWrapper = new FieldsMetaData();\n  public fields: Field[];\n  public filterFields: Field[];\n  public fieldNames: string[];\n  public panelOpenState: boolean = true;\n\n  public defaultClassNames: QueryBuilderClassNames = {\n    arrowIconButton: 'q-arrow-icon-button',\n    arrowIcon: 'q-icon q-arrow-icon',\n    removeIcon: 'q-icon q-remove-icon',\n    addIcon: 'q-icon q-add-icon',\n    button: 'q-button',\n    buttonGroup: 'q-button-group',\n    removeButton: 'q-remove-button',\n    switchGroup: 'q-switch-group',\n    switchLabel: 'q-switch-label',\n    switchRadio: 'q-switch-radio',\n    rightAlign: 'q-right-align',\n    transition: 'q-transition',\n    collapsed: 'q-collapsed',\n    treeContainer: 'q-tree-container',\n    tree: 'q-tree',\n    row: 'q-row',\n    connector: 'q-connector',\n    rule: 'q-rule',\n    ruleSet: 'q-ruleset',\n    invalidRuleSet: 'q-invalid-ruleset',\n    emptyWarning: 'q-empty-warning',\n    fieldControl: 'q-field-control',\n    fieldControlSize: 'q-control-size',\n    operatorControl: 'q-operator-control',\n    operatorControlSize: 'q-control-size',\n    inputControl: 'q-input-control',\n    inputControlSize: 'q-control-size'\n  };\n  @Input() disabled = false;\n  @Input() data: RuleSet = new RuleSet('and', []);\n\n\n  @HostBinding('attr.query-builder-condition') get condition() {\n    return this.data?.condition;\n  }\n\n  // For ControlValueAccessor interface\n  public onChangeCallback!: () => void;\n  public onTouchedCallback!: () => any;\n\n  @Input() allowRuleset = true;\n  @Input() allowCollapse = false;\n  @Input() emptyMessage = 'A ruleset cannot be empty. Please add a rule or remove it all together.';\n  @Input() classNames: QueryBuilderClassNames = {};\n  @Input() operatorMap: { [key: string]: string[] } = {};\n  @Input() parentValue?: RuleSet;\n  @Input() config: QueryBuilderConfig = {fields: {}};\n\n\n  @Input() parentChangeCallback!: () => void;\n  @Input() parentTouchedCallback!: () => void;\n  @Input() persistValueOnFieldChange = false;\n\n  @ViewChild('treeContainer', {static: true}) treeContainer!: ElementRef;\n\n\n  constructor(private changeDetectorRef: ChangeDetectorRef, private formBuilder: FormBuilder,\n              private errorDialogService: ErrorDialogService, private appService: AppService\n  ) {\n    this.fields = [];\n    this.fieldNames = [];\n    this.filterFields = [];\n\n  }\n\n  // ----------OnInit Implementation----------\n\n  // ----------OnChanges Implementation----------\n\n\n  compareMatSelectItems(o1: any, o2: any): boolean {\n\n    return new Comparator().equals(o1, o2);\n\n  }\n\n  recurivelySetRuleFormField(ruleSet: RuleSet): void {\n    if (ruleSet.rules) {\n      for (let rule of ruleSet.rules) {\n        if (rule.rules) {\n          this.recurivelySetRuleFormField(rule as RuleSet);\n        } else {\n          this.handleFormForRule(rule as Rule);\n        }\n      }\n    }\n\n    this.changeInput();\n\n  }\n\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['data'] && changes['data'].currentValue !== changes['data'].previousValue) {\n      let currentRuleSet: RuleSet = changes['data'].currentValue as RuleSet;\n      this.recurivelySetRuleFormField(currentRuleSet);\n\n    }\n    const config = this.config;\n    const type = typeof config;\n    if (type === 'object') {\n\n      this.fields = Object.keys(config.fields).map((value) => {\n        const field = config.fields[value];\n        field.value = field.value || value;\n        if (field.type && field.type !== 'category') {\n          this.typeToFieldMapWrapper.registerField(field);\n        }\n        return field;\n      });\n\n    } else {\n      throw new Error(`Expected 'config' must be a valid object, got ${type} instead.`);\n    }\n\n  }\n\n  removeStringValueFromStringField(index: number, rule: Rule): void {\n\n    if (this.disabled) {\n      return;\n    }\n    //remove the item in rule.value at the index position\n    rule.value?.splice(index, 1);\n    this.handleDataChange();\n    this.handleTouched();\n  }\n\n  submitHandler(e: any) {\n    e.preventDefault();\n  }\n\n  addStringValue(rule: Rule, expansionPanel: MatExpansionPanel): void {\n    let formcontrol = rule.ruleForm?.get('fieldValueGroup')?.get('inputTextForStringField');\n    if (!formcontrol) {\n      throw new Error(\"Form control not found!\");\n    }\n    let input = formcontrol?.value;\n    if (!input || input === '') {\n\n\n      this.changeDetectorRef.detectChanges(); // Add this line\n      // Wrap the expansionPanel.open() call inside a setTimeout function\n      setTimeout(() => {\n        expansionPanel.open();\n      }, 0);\n      return;\n    }\n    if (rule.value === undefined) {\n      rule.value = [];\n    }\n\n\n    // Check if the value is not already in the array\n    if (rule.value.indexOf(input) === -1) {\n      // Directly push the value to the rule.value array\n      rule.value.push(input);\n      // formcontrol.reset();\n      this.handleTouched();\n      this.handleDataChange();\n      this.changeDetectorRef.detectChanges(); // Add this line\n      // Wrap the expansionPanel.open() call inside a setTimeout function\n      setTimeout(() => {\n        expansionPanel.open();\n      }, 0);\n    }\n    formcontrol.reset();\n\n    this.changeDetectorRef.detectChanges(); // Add this line\n    // Wrap the expansionPanel.open() call inside a setTimeout function\n    setTimeout(() => {\n      expansionPanel.open();\n    }, 0);\n\n  }\n\n  // ----------Validator Implementation----------\n\n  validate(control: AbstractControl): ValidationErrors | null {\n    const errors: { [key: string]: any } = {};\n    const ruleErrorStore = [] as any;\n    let hasErrors = false;\n\n    if (!this.config.allowEmptyRulesets && this.checkEmptyRuleInRuleset(this.data)) {\n      errors['empty'] = 'Empty rulesets are not allowed.';\n      hasErrors = true;\n    }\n\n\n    if (ruleErrorStore.length) {\n      errors['rules'] = ruleErrorStore;\n      hasErrors = true;\n    }\n    return hasErrors ? errors : null;\n  }\n\n  // ----------ControlValueAccessor Implementation----------\n\n  @Input()\n  get value(): RuleSet {\n    return this.data;\n  }\n\n  set value(value: RuleSet) {\n    // When component is initialized without a formControl, null is passed to value\n    this.data = value || new RuleSet('and', []);\n    this.recurivelySetRuleFormField(this.data);\n    this.handleDataChange();\n  }\n\n  writeValue(obj: any): void {\n    this.value = obj;\n  }\n\n  registerOnChange(fn: any): void {\n    this.onChangeCallback = () => fn(this.data);\n  }\n\n  registerOnTouched(fn: any): void {\n    this.onTouchedCallback = () => fn(this.data);\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this.changeDetectorRef.detectChanges();\n  }\n\n  // ----------END----------\n\n  getDisabledState = (): boolean => {\n    return this.disabled;\n  }\n\n\n  getFieldsForSelectedType(rule: Rule): Field[] {\n    if (rule.fieldType) {\n      let fields = this.typeToFieldMapWrapper.type2fields.get(rule.fieldType) as Field[];\n      return fields;\n    }\n    return [];\n  }\n\n  getOptionsForField(rule: Rule): Option[] {\n\n    if (!rule.field) {\n      return [];\n    }\n    if (RuleUtils.fieldIsArray(rule) && (rule.field as any).length > 1) {\n      throw new Error('Expected field to not be an array!');\n\n    }\n\n\n    //get random element from set and get options\n\n    let options = (rule.field as any).options;\n    if (!options) {\n      return [];\n    }\n    return options as Option[];\n\n  }\n\n\n  getOperatorsForSelectedType(rule: Rule): Operator[] {\n    const fieldType = rule.fieldType;\n    if (!fieldType) {\n      return [];\n    }\n    switch (fieldType) {\n      case \"string\":\n        return StringOperators.ALL;\n      case \"number\":\n        return NumericalOperators.ALL;\n      case \"categorical\":\n        return CategoricalOperators.ALL;\n      default:\n        throw new Error(`Unexpected field type: ${fieldType}`);\n\n    }\n\n\n  }\n\n\n  getClassNames(...args: string[]): any | string[] {\n    const clsLookup = this.classNames ? this.classNames : this.defaultClassNames as any;\n    const defaultClassNames = this.defaultClassNames as any;\n    const classNames = args.map((id: any) => clsLookup[id] || defaultClassNames[id]).filter((c: any) => !!c);\n    return classNames.length ? classNames.join(' ') : [];\n  }\n\n\n  public oneControlIsNotEmptyValidator(controlNames: string[]): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      let controls = new Array<AbstractControl>();\n      for (const controlName of controlNames) {\n        controls.push(control.get(controlName) as AbstractControl);\n      }\n\n      //logic to count how many controls are empty\n      let emptyCount = 0;\n      for (const control of controls) {\n        if (control.value == null || control.value === '') {\n          emptyCount++;\n        }\n      }\n      // If all controls are empty, return an error\n      if (emptyCount === controls.length) {\n        // return {oneControlRequired: true};\n        return {oneControlRequired: true};\n      }\n\n      // If at least one control is non-empty, no error\n      return null;\n    };\n  }\n\n  currentRuleSetIsInvalid(ruleSet: RuleSet): boolean {\n    if (ruleSet.rules) {\n      return ruleSet.rules.some((item: RuleSet | any) => {\n        if (item.rules) {\n          return this.currentRuleSetIsInvalid(item);\n        } else {\n          return this.currentRuleIsInvalid(item);\n        }\n      });\n    }\n    return false;\n  }\n\n  currentRuleIsInvalid(rule: Rule): boolean {\n    return !RuleUtils.isValid(rule);\n  }\n\n  addRule(parent?: RuleSet): void {\n    if (this.disabled) {\n      return;\n    }\n\n    parent = parent || this.data;\n    if (parent.rules && parent.rules.length > 0) {\n      //get last item of rules\n      let lastItem = parent.rules[parent.rules.length - 1];\n      if (!(RuleUtils.isRuleSetObject(lastItem)) && this.currentRuleIsInvalid(lastItem as Rule)) {\n        this.errorDialogService.openErrorDialog(\"Error\", \"Please fill out the current rule before adding a new one!\");\n        return;\n      }\n\n\n    }\n\n\n    let rule: Rule = new Rule([], 'string', undefined, [], undefined, undefined, undefined);\n    this.handleFormForRule(rule);\n\n    parent.rules = parent.rules.concat([rule]);\n\n    this.handleTouched();\n    this.handleDataChange();\n  }\n\n  handleFormForRule(rule: Rule) {\n    if (rule.ruleForm) {\n      //the form is already created; nothing to do\n      return;\n    }\n    rule.ruleForm = this.formBuilder.group({\n      fieldType: ['string', Validators.required],\n      fieldMatchType: ['', Validators.required],\n      fieldGroup: this.formBuilder.group({\n        fieldSingle: ['', Validators.required], fieldMultiple: ['', Validators.required],\n      }, {validators: this.oneControlIsNotEmptyValidator(['fieldSingle', 'fieldMultiple'])}),\n      operator: ['', Validators.required],\n      valueMatchType: ['', Validators.required],\n      fieldValueGroup: this.formBuilder.group({\n        inputTextForStringField: ['', /*Validators.required*/], // fieldValueNumber: ['', /*Validators.required*/],\n        // fieldValueDate: ['', /*Validators.required*/],\n        // fieldValueTime: ['', /*Validators.required*/],\n        fieldValueCategorical: ['', /*Validators.required*/], // fieldValueBoolean: ['', /*Validators.required*/],\n      })\n\n    });\n\n    if (rule.fieldType) {\n      let fieldType: AbstractControl = rule.ruleForm.get('fieldType') as AbstractControl;\n      fieldType.setValue(rule.fieldType);\n    }\n\n    rule.ruleForm.get('fieldType')?.valueChanges.subscribe((value) => {\n      this.changeFieldType(value, rule);\n    });\n\n    if (rule.fieldMatchType) {\n      let fieldMatchType = rule.ruleForm.get('fieldMatchType') as AbstractControl;\n      fieldMatchType.setValue(rule.fieldMatchType);\n    }\n    rule.ruleForm.get('fieldMatchType')?.valueChanges.subscribe((value) => {\n      this.changeFieldMatchType(value, rule);\n\n    });\n\n    if (rule.field) {\n      if (RuleUtils.allowMultipleFields(rule)) {\n\n        rule.ruleForm.get(\"fieldGroup\")?.get('fieldMultiple')?.setValue(rule.field);\n      } else {\n\n        rule.ruleForm.get(\"fieldGroup\")?.get('fieldSingle')?.setValue(rule.field);\n      }\n    }\n\n    rule.ruleForm.get(\"fieldGroup\")?.get('fieldMultiple')?.valueChanges.subscribe((value) => {\n      this.changeFieldArray(value, rule);\n    });\n    rule.ruleForm.get(\"fieldGroup\")?.get('fieldSingle')?.valueChanges.subscribe((value) => {\n      this.changeField(value, rule);\n    });\n\n    if (rule.operator) {\n      rule.ruleForm.get('operator')?.setValue(rule.operator);\n    }\n\n    rule.ruleForm.get('operator')?.valueChanges.subscribe((value) => {\n      this.changeOperator(value, rule);\n\n    });\n\n    if (rule.valueMatchType) {\n      rule.ruleForm.get('valueMatchType')?.setValue(rule.valueMatchType);\n    }\n\n    rule.ruleForm.get('valueMatchType')?.valueChanges.subscribe((value) => {\n      this.changeValueMatchType(value, rule);\n\n    });\n    rule.ruleForm.get('fieldValueGroup')?.get('inputTextForStringField')?.valueChanges.subscribe((value) => {\n\n    });\n\n    /*rule.ruleForm.get('fieldValueGroup')?.get('fieldValueNumber')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });\n    rule.ruleForm.get('fieldValueGroup')?.get('fieldValueDate')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });\n    rule.ruleForm.get('fieldValueGroup')?.get('fieldValueTime')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });*/\n    rule.ruleForm.get('fieldValueGroup')?.get('fieldValueCategorical')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });\n\n    /*rule.ruleForm.get('fieldValueGroup')?.get('fieldValueBoolean')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });*/\n  }\n\n  removeRule(rule: Rule, parent?: RuleSet): void {\n    if (this.disabled) {\n      return;\n    }\n\n    parent = parent || this.data;\n\n    parent.rules = parent.rules.filter((r) => r !== rule);\n\n\n    this.handleTouched();\n    this.handleDataChange();\n  }\n\n  addRuleSet(parent?: RuleSet): void {\n    if (this.disabled) {\n      return;\n    }\n\n    parent = parent || this.data;\n    //set lastItem to last item of rules or undefined if RuleSet.rules is undefined\n    let lastItem = parent.rules=== undefined? undefined : parent.rules[parent.rules.length - 1];\n\n    // let lastItem = parent.rules[parent.rules.length - 1];\n    if ( lastItem && (RuleUtils.isRuleSetObject(lastItem)) && this.currentRuleSetIsInvalid(lastItem as RuleSet)) {\n      this.errorDialogService.openErrorDialog(\"Error\", \"Please fill out the current rule before adding a new one!\");\n      return;\n    } else if ( lastItem &&!(RuleUtils.isRuleSetObject(lastItem)) && this.currentRuleIsInvalid(lastItem as Rule)) {\n      this.errorDialogService.openErrorDialog(\"Error\", \"Please fill out the current rule before adding a new one!\");\n      return;\n    }\n\n\n    let ruleSet: RuleSet = new RuleSet('and', []);\n    parent.rules = parent.rules.concat([ruleSet]);\n\n\n    this.handleTouched();\n    this.handleDataChange();\n  }\n\n  removeRuleSet(ruleset?: RuleSet, parent?: RuleSet): void {\n    if (this.disabled) {\n      return;\n    }\n\n    ruleset = ruleset || this.data;\n    parent = parent || this.parentValue;\n    if (parent) {\n      parent.rules = parent.rules.filter((r) => r !== ruleset);\n    }\n\n    this.handleTouched();\n    this.handleDataChange();\n  }\n\n  transitionEnd(e: Event): void {\n    this.treeContainer.nativeElement.style.maxHeight = null;\n  }\n\n  toggleCollapse(): void {\n    this.computedTreeContainerHeight();\n    setTimeout(() => {\n      this.data.collapsed = !this.data.collapsed;\n    }, 100);\n  }\n\n  computedTreeContainerHeight(): void {\n    const nativeElement: HTMLElement = this.treeContainer.nativeElement;\n    if (nativeElement && nativeElement.firstElementChild) {\n      nativeElement.style.maxHeight = (nativeElement.firstElementChild.clientHeight + 8) + 'px';\n    }\n  }\n\n  changeCondition(value: string): void {\n    if (this.disabled) {\n      return;\n    }\n    //check that value satisfies ConditionEnum\n    if (value.toLowerCase() !== 'and' && value.toLowerCase() !== 'or') {\n      throw new Error('Invalid condition value');\n    }\n    this.data.condition = value.toUpperCase() as  ConditionEnum;\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges();\n  }\n\n  changeOperator(value: Operator, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n    rule.operator = value;\n\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n\n  changeFieldMatchType(fieldMatchType: RuleMatchType, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n\n    rule.fieldMatchType = fieldMatchType;\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n  changeValueMatchType(valueMatchType: RuleMatchType, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n\n    rule.valueMatchType = valueMatchType;\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n\n  changeInput(): void {\n    if (this.disabled) {\n      return;\n    }\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n  changeField(field: Field, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n    if (!field || !rule) {\n      return;\n    }\n\n\n    // delete rule.value;\n    rule.field = [field.name];\n    if (field.operators?.[0] !== undefined){\n\n      rule.operator = field.operators?.[0].asOperator() as RuleOperator;\n    }\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n  changeFieldArray(field: Field[], rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n\n\n    rule.value = [];\n    if (!rule.field) {\n      rule.field = [];\n    } else {\n      if (!RuleUtils.fieldIsArray(rule)) {\n        throw new Error('Expected field to be an array!');\n      }\n    }\n    //check if field is already in rule array\n    let fieldArray: Field[] = rule.field as any;\n    for (const fieldItem of field) {\n      if (fieldArray.indexOf(fieldItem) === -1) {\n        fieldArray.push(fieldItem);\n      }\n    }\n    rule.field = fieldArray.map((f) => f.name);\n\n    let operator = field[0]?.operators?.[0];\n    if (operator){\n\n      rule.operator = operator;\n    } else {\n        rule.operator = StringOperators.CONTAINS;\n    }\n\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n  changeFieldType(fieldType: FieldType, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n    if(fieldType === null){\n      return;\n    }\n\n\n    rule.fieldType = fieldType as FieldTypeEnum;\n    rule.field = [];\n    rule.fieldMatchType = MatchTypes.ANY_OF;\n    // delete rule.value;\n    rule.valueMatchType = MatchTypes.ANY_OF;\n    rule.operator = StringOperators.CONTAINS;\n\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n\n  getQueryItemClassName(local: LocalRuleMeta): string {\n    let cls = this.getClassNames('row', 'connector', 'transition');\n    cls += ' ' + this.getClassNames(local.ruleset ? 'ruleSet' : 'rule');\n    if (local.invalid) {\n      cls += ' ' + this.getClassNames('invalidRuleSet');\n    }\n    return cls as string;\n  }\n\n  private checkEmptyRuleInRuleset(ruleset: RuleSet): boolean {\n    if (!ruleset || !ruleset.rules || ruleset.rules.length === 0) {\n      return true;\n    } else {\n      return ruleset.rules.some((item: RuleSet | any) => {\n        if (item.rules) {\n          return this.checkEmptyRuleInRuleset(item);\n        } else {\n          return false;\n        }\n      });\n    }\n  }\n\n  private handleDataChange(): void {\n    this.changeDetectorRef.markForCheck();\n    if (this.onChangeCallback) {\n      this.onChangeCallback();\n    }\n    if (this.parentChangeCallback) {\n      this.parentChangeCallback();\n    }\n  }\n\n  private handleTouched(): void {\n    if (this.onTouchedCallback) {\n      this.onTouchedCallback();\n    }\n    if (this.parentTouchedCallback) {\n      this.parentTouchedCallback();\n    }\n  }\n\n  getFieldTypes(): string[] {\n    return this.typeToFieldMapWrapper.getFieldTypes();\n\n\n  }\n\n\n\n\n  showEmptyFieldNameError(rule: Rule): boolean {\n    let fieldGroup = rule.ruleForm?.get(\"fieldGroup\");\n    if (RuleUtils.allowMultipleFields(rule)) {\n      let errors = fieldGroup?.get('fieldMultiple')?.errors;\n      if (errors && errors['required']) {\n        return true;\n      }\n    } else {\n      let errors = fieldGroup?.get('fieldSingle')?.errors;\n      if (errors && errors['required']) {\n        return true;\n      }\n    }\n    return false;\n\n\n  }\n\n  showFieldMatchTypeError(rule: Rule) {\n    let fieldMatchType = rule.ruleForm?.get(\"fieldMatchType\");\n    if (fieldMatchType && fieldMatchType.errors) {\n      if (fieldMatchType.errors['required']) {\n        return true;\n      }\n\n    }\n\n    return false;\n  }\n\n  showOperatorError(rule: Rule) {\n    let operator = rule.ruleForm?.get(\"operator\");\n    if (operator && operator.errors) {\n      if (operator.errors['required']) {\n        return true;\n      }\n\n    }\n\n    return false;\n  }\n\n  showValueMatchTypeError(rule: Rule) {\n    let valueMatchType = rule.ruleForm?.get(\"valueMatchType\");\n    if (valueMatchType && valueMatchType.errors) {\n      if (valueMatchType.errors['required']) {\n        return true;\n      }\n\n    }\n\n    return false;\n  }\n\n  fieldValueIsEmpty(rule: Rule) {\n    if (!rule.value) {\n      return true;\n    }\n    if (Array.isArray(rule.value) && rule.value.length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n\n  requireExpansionPanelOpen(rule: Rule) {\n    let value = rule.value;\n    if (!value){\n\n      return false;\n\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false;\n    }\n    return true;\n\n\n  }\n}\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "field2Type",
                    "defaultValue": "new Map<string, string>",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "fieldToOptions",
                    "defaultValue": "new MultiMap<string, Option>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "type2fields",
                    "defaultValue": "new MultiMap<string, Field>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                }
            ],
            "methods": [
                {
                    "name": "getFieldType",
                    "args": [
                        {
                            "name": "field",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 57,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFieldTypes",
                    "args": [],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 53,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "registerField",
                    "args": [
                        {
                            "name": "field",
                            "type": "Field",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "Field",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "FileQueueObject",
            "id": "class-FileQueueObject-9b661f3ff62cb1f681eeb7609de5f96746c995a7fb0ac35469a6b9e3344c87b09ad4ab7546c59715a0d90d975609307e02f35e3e49a3d75f836682282d5d3491",
            "file": "src/app/file-uploader.service.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import * as _ from 'lodash';\nimport { HttpClient, HttpErrorResponse, HttpEventType, HttpHeaders, HttpRequest, HttpResponse } from '@angular/common/http';\nimport { Injectable, Output } from '@angular/core';\nimport { BehaviorSubject, Subscription } from 'rxjs';\n\n\n\nexport enum FileQueueStatus {\n  Pending,\n  Success,\n  Error,\n  Progress\n}\n\nexport class FileQueueObject {\n  public file: any;\n  public status: FileQueueStatus = FileQueueStatus.Pending;\n  public progress: number = 0;\n  public request?: Subscription;\n  public response?: HttpResponse<any> | HttpErrorResponse;\n\n  constructor(file: any) {\n    this.file = file;\n    \n    \n  }\n\n  // actions\n  public upload = () => { /* set in service */ };\n  public cancel = () => { /* set in service */ };\n  public remove = () => { /* set in service */ };\n\n  // statuses\n  public isPending = () => this.status === FileQueueStatus.Pending;\n  public isSuccess = () => this.status === FileQueueStatus.Success;\n  public isError = () => this.status === FileQueueStatus.Error;\n  public inProgress = () => this.status === FileQueueStatus.Progress;\n  public isUploadable = () => this.status === FileQueueStatus.Pending || this.status === FileQueueStatus.Error;\n\n}\n\n// tslint:disable-next-line:max-classes-per-file\n@Injectable({\n  providedIn: 'root'\n})\nexport class FileUploaderService {\n\n\n  public url: string = 'https://jsonplaceholder.typicode.com/posts';\n\n  private _queue: BehaviorSubject<FileQueueObject[]>;\n  private _files: FileQueueObject[] = [];\n\n  constructor(private http: HttpClient) {\n    this._queue = <BehaviorSubject<FileQueueObject[]>>new BehaviorSubject(this._files);\n  }\n\n  // the queue\n  public get queue() {\n    return this._queue.asObservable();\n  }\n\n  // public events\n  public onCompleteItem(queueObj: FileQueueObject, response: any): any {\n    return { queueObj, response };\n  }\n\n  // public functions\n  public addToQueue(data: any) {\n    // add file to the queue\n    _.each(data, (file: any) => this._addToQueue(file));\n  }\n\n  public clearQueue() {\n    // clear the queue\n    this._files = [];\n    this._queue.next(this._files);\n  }\n\n  public uploadAll() {\n    // upload all except already successfull or in progress\n    _.each(this._files, (queueObj: FileQueueObject) => {\n      if (queueObj.isUploadable()) {\n        this._upload(queueObj);\n      }\n    });\n  }\n\n  // private functions\n  private _addToQueue(file: any) {\n    const queueObj = new FileQueueObject(file);\n\n    // set the individual object events\n    queueObj.upload = () => this._upload(queueObj);\n    queueObj.remove = () => this._removeFromQueue(queueObj);\n    queueObj.cancel = () => this._cancel(queueObj);\n\n    // push to the queue\n    this._files.push(queueObj);\n    this._queue.next(this._files);\n  }\n\n  private _removeFromQueue(queueObj: FileQueueObject) {\n    _.remove(this._files, queueObj);\n  }\n\n  private _upload(queueObj: FileQueueObject) {\n    // create form data for file\n    const form = new FormData();\n    form.append('file', queueObj.file, queueObj.file.name);\n\n    // upload file and report progress\n    const req = new HttpRequest('POST', this.url, form, {\n      reportProgress: true,\n    });\n\n    // upload file and report progress\n    queueObj.request = this.http.request(req).subscribe(\n      (event: any) => {\n        if (event.type === HttpEventType.UploadProgress) {\n          this._uploadProgress(queueObj, event);\n        } else if (event instanceof HttpResponse) {\n          this._uploadComplete(queueObj, event);\n        }\n      },\n      (err: HttpErrorResponse) => {\n        if (err.error instanceof Error) {\n          // A client-side or network error occurred. Handle it accordingly.\n          this._uploadFailed(queueObj, err);\n        } else {\n          // The backend returned an unsuccessful response code.\n          this._uploadFailed(queueObj, err);\n        }\n      }\n    );\n\n    return queueObj;\n  }\n\n  private _cancel(queueObj: FileQueueObject) {\n    // update the FileQueueObject as cancelled\n    queueObj.request?.unsubscribe();\n    queueObj.progress = 0;\n    queueObj.status = FileQueueStatus.Pending;\n    this._queue.next(this._files);\n  }\n\n  private _uploadProgress(queueObj: FileQueueObject, event: any) {\n    // update the FileQueueObject with the current progress\n    const progress = Math.round(100 * event.loaded / event.total);\n    queueObj.progress = progress;\n    queueObj.status = FileQueueStatus.Progress;\n    this._queue.next(this._files);\n  }\n\n  private _uploadComplete(queueObj: FileQueueObject, response: HttpResponse<any>) {\n    // update the FileQueueObject as completed\n    queueObj.progress = 100;\n    queueObj.status = FileQueueStatus.Success;\n    queueObj.response = response;\n    this._queue.next(this._files);\n    this.onCompleteItem(queueObj, response.body);\n  }\n\n  private _uploadFailed(queueObj: FileQueueObject, response: HttpErrorResponse) {\n    // update the FileQueueObject as errored\n    queueObj.progress = 0;\n    queueObj.status = FileQueueStatus.Error;\n    queueObj.response = response;\n    this._queue.next(this._files);\n  }\n\n}",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "file",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 20,
                "jsdoctags": [
                    {
                        "name": "file",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "cancel",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "file",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "inProgress",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 37,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "isError",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "isPending",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "isSuccess",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "isUploadable",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "progress",
                    "defaultValue": "0",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "remove",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "request",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Subscription",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 19,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "response",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "HttpResponse<any> | HttpErrorResponse",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 20,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "status",
                    "defaultValue": "FileQueueStatus.Pending",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FileQueueStatus",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "upload",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "FlatBudgetTreeNode",
            "id": "class-FlatBudgetTreeNode-ab5802e1347f1b484d762ed6e73a59f110ab93d7f293d3abc926c94b10090e9aaed528e4bcd7224404a36df227182a0c26149eedd0309c7062054dec8e0225ba",
            "file": "src/app/budget/budget.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport {FlatTreeControl} from \"@angular/cdk/tree\";\nimport {MatTreeFlatDataSource, MatTreeFlattener} from \"@angular/material/tree\";\nimport {\n  AbstractControl,\n  FormBuilder,\n  FormControl,\n  FormGroup,\n  FormGroupDirective,\n  FormsModule,\n  NgForm,\n  ReactiveFormsModule,\n  ValidatorFn\n} from \"@angular/forms\";\nimport {ErrorStateMatcher} from '@angular/material/core';\nimport {MatDialog} from \"@angular/material/dialog\";\nimport {SaveErrorDialogComponent} from \"./save-error-dialog/save-error-dialog.component\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {MatButton, MatIconButton} from '@angular/material/button';\nimport {MatIcon, MatIconModule, MatIconRegistry} from '@angular/material/icon';\nimport {NgClass, NgIf} from '@angular/common';\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from '@angular/material/table';\nimport {MatError, MatFormField} from '@angular/material/form-field';\nimport {MatInput} from '@angular/material/input';\n\nexport interface BudgetTreeNode {\n  budgetTreeNodeAmount: number;\n  budgetTreeNodeId: number;\n  budgetTreeNodeParentId: number;\n  children: BudgetTreeNode[];\n  name: string;\n  qualifiedName: string;\n}\n\nexport class FlatBudgetTreeNode {\n  level!: number;\n  expandable!: boolean;\n  name!: string;\n  qualifiedName!: string;\n  budgetTreeNodeId!: number;\n  budgetTreeNodeAmount!: number;\n  budgetTreeNodeParentId!: number;\n}\n\n\n\nexport interface FindOrCreateBudgetResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n  budgetTreeNodes: BudgetTreeNode[];\n  numberOfBudgetTreeNodes: number;\n\n}\n\nexport interface UpdateBudgetEntryResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n\n\n}\n\n\nexport class MyErrorStateMatcher implements ErrorStateMatcher {\n  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid);\n  }\n}\n\n\n@Component({\n    selector: 'app-budget',\n    templateUrl: './budget.component.html',\n    styleUrls: ['./budget.component.scss'],\n    standalone: true,\n  imports: [MatToolbar, BankAccountSelectionComponent,\n    MatButton, MatIcon, NgIf, FormsModule, ReactiveFormsModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell,\n    MatCellDef, MatCell, MatIconButton, MatFormField, MatInput, MatError, MatHeaderRowDef,\n    MatHeaderRow, MatRowDef, MatRow, NgClass, MatIconModule, MatIcon],\n\n})\nexport class BudgetComponent implements OnInit {\n  TOTAL_NODE_ID: number = -1;\n  TOTAL_NODE_CATEGORY_NAME = 'Totaal';\n\n  totalBudget: number = 0;\n\n  matcher = new MyErrorStateMatcher();\n\n\n  /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n  idToNodeMap = new Map<number, BudgetTreeNode>();\n\n  /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n  nestedNodeMap = new Map<BudgetTreeNode, FlatBudgetTreeNode>();\n\n  qualifiedNameToNodeMap = new Map<string, BudgetTreeNode>();\n\n  treeControl!: FlatTreeControl<FlatBudgetTreeNode>\n  dataSource!: MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>;\n\n\n  treeFlattener: MatTreeFlattener<BudgetTreeNode, FlatBudgetTreeNode>;\n\n  displayedColumns: string[] = ['category', 'budget', 'yearlyBudget'];\n\n  rowsToHighlight: Set<number> = new Set<number>();\n\n  idToControlsMap: Map<number, FormControl> = new Map<number, FormControl>();\n  controlsToIdMap: Map<FormControl, number> = new Map<FormControl, number>();\n  allControls: FormControl[] = [];\n  mainForm: FormGroup;\n  idToBudgetNodeMap: Map<number, BudgetTreeNode> = new Map<number, BudgetTreeNode>();\n  currentSubTreeHasError: boolean = false;\n  isTreeExpanded = true;\n\n\n  constructor(private appService: AppService, private fb: FormBuilder, public dialog: MatDialog\n  ) {\n\n    this.mainForm = this.fb.group({});\n\n    this.treeFlattener = new MatTreeFlattener(\n      this.transformer,\n      this.getLevel,\n      this.isExpandable,\n      this.getChildren\n    );\n    this.treeControl = new FlatTreeControl<FlatBudgetTreeNode>(\n      this.getLevel,\n      this.isExpandable\n    );\n    this.dataSource = new MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>(\n      this.treeControl,\n      this.treeFlattener\n    );\n\n\n\n  }\n\n\n  transformer = (node: BudgetTreeNode, level: number) => {\n    const existingNode = this.nestedNodeMap.get(node);\n    const flatNode =\n      existingNode && existingNode.qualifiedName === node.qualifiedName\n        ? existingNode\n        : new FlatBudgetTreeNode();\n    flatNode.name = node.name;\n    flatNode.qualifiedName = node.qualifiedName;\n    flatNode.level = level;\n    flatNode.expandable = (node.children != undefined && node.children.length > 0);\n    flatNode.budgetTreeNodeAmount = node.budgetTreeNodeAmount;\n    flatNode.budgetTreeNodeId = node.budgetTreeNodeId;\n    flatNode.budgetTreeNodeParentId = node.budgetTreeNodeParentId;\n    this.idToNodeMap.set(node.budgetTreeNodeId, node);\n\n    this.nestedNodeMap.set(node, flatNode);\n    this.qualifiedNameToNodeMap.set(node.qualifiedName, node);\n    return flatNode;\n  };\n\n  getLevel = (node: FlatBudgetTreeNode) => node.level;\n\n  isExpandable = (node: FlatBudgetTreeNode) => node.expandable;\n\n  getChildren = (node: BudgetTreeNode): BudgetTreeNode[] => node.children;\n\n  hasChild = (_: number, _nodeData: FlatBudgetTreeNode) => _nodeData.expandable;\n\n  inputChanged: boolean = false;\n  dataLoaded: boolean = false;\n  isSaved: boolean = false;\n\n\n  getRowClass(data: FlatBudgetTreeNode): string {\n    if (data.name === this.TOTAL_NODE_CATEGORY_NAME) {\n      return 'highlight-total-row';\n    }\n    if (this.currentSubTreeHasError && this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-error';\n    }\n    if (this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-no-error';\n    }\n    return '';\n  }\n\n\n  ngOnInit(): void {\n    this.appService.selectedBankAccountObservable$.subscribe(selectedAccount => {\n      if (selectedAccount) {\n        this.appService.findOrCreateBudget(selectedAccount).subscribe((response: BudgetTreeNode[]) => {\n\n          let filteredData = response.filter(node => node.name !== 'NO CATEGORY' && node.name !== 'DUMMY CATEGORY');\n          let totalBudgetTreeNode = this.initTotalBudgetTreeNode();\n          filteredData.push(totalBudgetTreeNode);\n          this.dataSource.data = filteredData;\n          let allBudgetNodes: BudgetTreeNode[] = [];\n          for (const node of response) {\n            if (node.name === 'NO CATEGORY' || node.name === 'DUMMY CATEGORY') {\n              continue;\n            }\n            allBudgetNodes.push(node);\n            this.getAllDescendantsRecursively(node, allBudgetNodes);\n          }\n\n\n          for (const node of allBudgetNodes) {\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            let control = new FormControl<number>(node.budgetTreeNodeAmount, [this.budgetValidator(), this.negativeNumberValidator()]);\n            this.idToControlsMap.set(node.budgetTreeNodeId, control);\n            control.valueChanges.subscribe((value) => {\n              if ((value !== undefined)) {\n                // this.inputChanged = false;\n                this.validateAllControls();\n                this.calculateTotalBudget();\n\n                let flatNode = this.nestedNodeMap.get(node);\n                if (flatNode){\n                  if (flatNode.name === this.TOTAL_NODE_CATEGORY_NAME) {\n                    //we don't want to do anything when the total node is changed\n                    return;\n                  }\n                  this.determineSubTreeForNode(flatNode as FlatBudgetTreeNode);\n                  if (!this.currentSubTreeHasError){\n                    this.onBudgetChange(flatNode as FlatBudgetTreeNode);\n                  }\n                }\n              }\n            });\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            this.controlsToIdMap.set(control, node.budgetTreeNodeId);\n            this.allControls.push(control);\n            this.mainForm.addControl(node.budgetTreeNodeId.toString(), control);\n          }\n          this.calculateTotalBudget();\n          this.dataLoaded = true;\n          this.treeControl.expandAll();\n\n        });\n      }\n    });\n\n  }\n\n  getDescendantIds(node: BudgetTreeNode, allDescendantIds: number[]) {\n    if (node.children && node.children.length > 0) {\n      node.children.forEach(child => {\n        allDescendantIds.push(child.budgetTreeNodeId);\n        this.getDescendantIds(child, allDescendantIds);\n      });\n    }\n  }\n\n  validateAllControls() {\n    Object.keys(this.mainForm.controls).forEach(key => {\n      const control = this.mainForm.get(key);\n      if (control) {\n        control.updateValueAndValidity({onlySelf: false, emitEvent: false});\n\n      }\n    });\n    this.mainForm.markAllAsTouched();\n  }\n\n  budgetValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isLessThanSumOfDescendants = this.isLessThanSumOfDescendants(control as FormControl);\n      return isLessThanSumOfDescendants ? {'isLessThanItsDescendants': {value: control.value}} : null;\n    };\n  }\n\n  negativeNumberValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isNegative = control.value < 0;\n      return isNegative ? {'negativeNumber': {value: control.value}} : null;\n    };\n  }\n\n  isLessThanSumOfDescendants(control: FormControl): boolean {\n    let nodeId = this.controlsToIdMap.get(control);\n    if (!nodeId) {\n      return false;\n    }\n\n    let nodeValue = control.value;\n\n    if (nodeValue == undefined || nodeValue < 0) {\n      return false;\n    }\n    let sumOfDescendants = 0;\n\n    let payload = this.idToBudgetNodeMap.get(nodeId) as BudgetTreeNode;\n    let allDescendantIds: number[] = [];\n    this.getDescendantIds(payload, allDescendantIds);\n\n    for (const descendantId of allDescendantIds) {\n      let descendantValue = this.idToControlsMap.get(descendantId)?.value;\n      if (descendantValue) {\n        sumOfDescendants = sumOfDescendants + descendantValue;\n\n      }\n    }\n\n\n    let isLessThanSumOfDescendants = nodeValue < sumOfDescendants;\n    //unpacking boolean for debugging purposes\n    return isLessThanSumOfDescendants;\n\n  }\n\n\n  determineSubTreeForNode(data: FlatBudgetTreeNode) {\n    this.rowsToHighlight = new Set<number>();\n    this.currentSubTreeHasError = false;\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n    this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n    if (budgetTreeNode.budgetTreeNodeParentId) {\n      //go one level up the tree to the parent. Add the id of the parent and all its descendants to the set of rows to highlight\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeParentId);\n      let parentBudgetTreeNode = this.idToNodeMap.get(budgetTreeNode.budgetTreeNodeParentId);\n      if (parentBudgetTreeNode == undefined) {\n        return;\n      }\n\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(parentBudgetTreeNode, allDescendantIds);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n\n\n\n    } else {\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(budgetTreeNode, allDescendantIds);\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n    }\n    this.currentSubTreeHasError = this.anyFormControlIsInvalid(this.rowsToHighlight);\n\n\n  }\n\n  private anyFormControlIsInvalid(ids: Set<number>): boolean {\n    let idsArray = [...ids];\n    for (const number of idsArray) {\n      if(this.formControlIsInvalid(number)){\n        return true;\n      }\n    }\n\n    return false;\n\n\n\n\n  }\n\n  private formControlIsInvalid(budgetTreeNodeId: number): boolean {\n    let control = this.mainForm.get(budgetTreeNodeId.toString());\n    if (control) {\n      return control.invalid;\n    }\n    return false;\n  }\n\n\n  /*onBlur() {\n    this.inputChanged = true;\n  }\n\n  onKeyUpEnter(event: Event) {\n    let kbe = event as KeyboardEvent;\n    if (kbe.key === 'Enter') {\n      this.inputChanged = true;\n    }\n  }*/\n\n  getAllDescendantsRecursively(budgetTreeNode: BudgetTreeNode, descendants: BudgetTreeNode[]) {\n    if (budgetTreeNode.children && budgetTreeNode.children.length > 0) {\n      budgetTreeNode.children.forEach(child => {\n        descendants.push(child);\n        this.getAllDescendantsRecursively(child, descendants);\n      });\n    }\n  }\n\n\n\n\n  onBudgetChange(data: FlatBudgetTreeNode): void {\n\n    let budgetControl = this.mainForm.get(data.budgetTreeNodeId.toString()) as FormControl;\n    if (budgetControl == undefined) {\n      return;\n    }\n    if (data.budgetTreeNodeAmount === undefined || data.budgetTreeNodeAmount === null) {\n      data.budgetTreeNodeAmount = 0;\n      budgetControl.setValue(0);\n    }\n\n\n    if (!budgetControl.valid) {\n      return;\n    }\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n\n\n    if (budgetTreeNode.budgetTreeNodeAmount !== budgetControl.value) {\n      budgetTreeNode.budgetTreeNodeAmount = budgetControl.value;\n    }\n\n    this.appService.updateBudgetEntryAmount(budgetTreeNode).subscribe(\n      (\n        response: UpdateBudgetEntryResponse\n      ) => {\n        if (response.response.toLowerCase() !== \"success\") {\n          throw new Error(\"Failed to update budget entry amount\");\n        }\n        // this.recalculateCumulatedAmountsForAllNodes();\n        this.treeControl.expandAll();\n      });\n\n  }\n\n  sameSubTreeAsFocusedBudgetNode(data: FlatBudgetTreeNode): boolean {\n    return this.rowsToHighlight.has(data.budgetTreeNodeId);\n\n  }\n\n\n  /*onInputChange() {\n    this.inputChanged = true\n  }*/\n\n  saveAll() {\n    if (this.mainForm.invalid) {\n      let invalidCategories: BudgetTreeNode[] = [];\n      Object.keys(this.mainForm.controls).forEach(key => {\n        const control = this.mainForm.get(key);\n        if (control && control.invalid) {\n          let node = this.idToNodeMap.get(parseInt(key));\n          if (!node) {\n            throw new Error(\"Failed to find node for id \" + key);\n          }\n          node.budgetTreeNodeAmount = control.value;\n          invalidCategories.push(node);\n\n\n        }\n      });\n      this.dialog.open(SaveErrorDialogComponent, {\n        data: {\n          message: 'Sommige wijzingen kunnen niet worden opgeslaan! Corrigeer de inconsistente budgetbedragen voor onderstaande categorieën en probeer opnieuw:',\n          nodes: invalidCategories\n        }\n      });\n    } else {\n      let budgetTreeNodes = this.dataSource.data;\n      for (const budgetTreeNode of budgetTreeNodes) {\n        if (budgetTreeNode.budgetTreeNodeId === this.TOTAL_NODE_ID) {\n          continue;\n        }\n        let flatNode = this.nestedNodeMap.get(budgetTreeNode);\n        if (!flatNode) {\n          throw new Error(\"Failed to find flat node for budget tree node \" + budgetTreeNode);\n        } else {\n          this.onBudgetChange(flatNode);\n        }\n\n\n      }\n\n\n\n\n\n\n    }\n  }\n\n\n  toggleTree(): void {\n    if (this.isTreeExpanded) {\n      this.treeControl.collapseAll();\n    } else {\n      this.treeControl.expandAll();\n    }\n    this.isTreeExpanded = !this.isTreeExpanded;\n  }\n\n  calculateTotalBudget(): void {\n    this.totalBudget = Array.from(this.idToControlsMap.values()).filter(control => control.valid)\n      .reduce((sum, control) => sum + (control.value || 0), 0);\n    let totalNode = {\n      budgetTreeNodeAmount: this.totalBudget,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n    this.dataSource.data = [totalNode, ...this.dataSource.data.slice(1, this.dataSource.data.length - 1), totalNode];\n    this.mainForm.get(totalNode.budgetTreeNodeId.toString())?.setValue(totalNode.budgetTreeNodeAmount);\n  }\n\n  initTotalBudgetTreeNode(): BudgetTreeNode {\n    return {\n      budgetTreeNodeAmount: 0,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n  }\n\n}\n\n\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "budgetTreeNodeAmount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54
                },
                {
                    "name": "budgetTreeNodeId",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "budgetTreeNodeParentId",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "expandable",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 50
                },
                {
                    "name": "level",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 51
                },
                {
                    "name": "qualifiedName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "FlatCategoryNode",
            "id": "class-FlatCategoryNode-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "expandable",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 349
                },
                {
                    "name": "level",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 348
                },
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 350
                },
                {
                    "name": "nodeId",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 352
                },
                {
                    "name": "qualifiedName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 351
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TypeEnum | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 353
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "GroupByCounterpartyDataSource",
            "id": "class-GroupByCounterpartyDataSource-70965ee21c0e838de03c524ca1d8534c39684b54d1e3f49d020939ee21de39f3a2e682fe13e11f4ad29ab11cedabca1c7097bc7d1806e2def7c403d7f4eae0c2",
            "file": "src/app/manual-categorization-view/manual-categorization-view.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {Component, ElementRef, OnInit, ViewChild} from '@angular/core';\nimport {MatPaginator} from \"@angular/material/paginator\";\nimport {MatSort} from \"@angular/material/sort\";\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from \"@angular/material/table\";\nimport {PaginationDataSource, SimpleDataSource} from \"@daanvdn/ngx-pagination-data-source\";\nimport {AppService} from \"../app.service\";\nimport {BehaviorSubject, map, Observable} from \"rxjs\";\nimport {MatButtonToggle, MatButtonToggleChange, MatButtonToggleGroup} from \"@angular/material/button-toggle\";\nimport {BankAccount, SimpleCategory, Transaction, TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\nimport {AmountType, CategoryMap, inferAmountType} from \"../model\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {AsyncPipe, NgIf} from '@angular/common';\nimport {CategoryTreeDropdownComponent} from '../category-tree-dropdown/category-tree-dropdown.component';\n\n\ninterface GroupBy {\n  counterparty: string;\n  isGroupBy: boolean;\n  transactions: Transaction[];\n  isExpense: boolean;\n}\n\nclass GroupByCounterpartyDataSource implements SimpleDataSource<Transaction | GroupBy> {\n\n\n\n  constructor(public backingPaginationDataSource: PaginationDataSource<Transaction, BankAccount>, private isExpense: boolean) {\n  }\n\n  connect(): Observable<Array<Transaction | GroupBy>> {\n    return this.backingPaginationDataSource.connect().pipe(map(data => {\n\n      let mapByCounterpartyName = new Map<string, Transaction[]>();\n\n      for (const transaction of data) {\n        let name = transaction.counterparty;\n        if (!name) {\n          name = \"\";\n        }\n        let transactionsForCounterparty = mapByCounterpartyName.has(name) ? mapByCounterpartyName.get(name) : [];\n        transactionsForCounterparty?.push(transaction);\n        mapByCounterpartyName.set(name, transactionsForCounterparty as Transaction[]);\n      }\n      let sortedKeys = Array.from(mapByCounterpartyName.keys()).sort();\n      let result = new Array<Transaction | GroupBy>();\n      for (const aKey of sortedKeys) {\n        let transactionsForKey = mapByCounterpartyName.get(aKey) as Transaction[];\n        let groupBy: GroupBy = {\n          counterparty: aKey, isGroupBy: true, transactions: transactionsForKey, isExpense: this.isExpense\n        };\n        result.push(groupBy)\n        result.push(...transactionsForKey)\n\n      }\n\n      return result;\n    }));\n  }\n\n  disconnect(): void {\n    this.backingPaginationDataSource.disconnect();\n  }\n\n\n  fetch(page: number, pageSize?: number): void {\n    this.backingPaginationDataSource.fetch(page, pageSize);\n  }\n\n\n}\n\n@Component({\n    selector: 'app-manual-categorization-view',\n    templateUrl: './manual-categorization-view.component.html',\n    styleUrls: ['./manual-categorization-view.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, BankAccountSelectionComponent, MatButtonToggleGroup, MatButtonToggle, NgIf, MatPaginator, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, CategoryTreeDropdownComponent, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, AsyncPipe]\n})\nexport class ManualCategorizationViewComponent implements OnInit {\n\n  @ViewChild(MatPaginator, { static: false }) paginator!: MatPaginator;\n  @ViewChild(MatSort, { static: false }) sort!: MatSort;\n  @ViewChild(MatTable) table!: MatTable<Transaction>;\n  @ViewChild('table', {read: ElementRef, static: false}) tableElement!: ElementRef;\n\n\n  dataSource!: GroupByCounterpartyDataSource;\n  categoryMap!: CategoryMap;\n\n  private bankAccount!: BankAccount;\n  displayedColumns = [\n    \"transaction\",\n    \"amount\",\n    \"category\"\n  ];\n  private activeView: BehaviorSubject<TransactionTypeEnum> = new BehaviorSubject<TransactionTypeEnum>(TransactionTypeEnum.EXPENSES);\n  private activeViewObservable = this.activeView.asObservable();\n  constructor(private appService: AppService) {\n    appService.selectedBankAccountObservable$.subscribe(account => {\n      if (account){\n        this.bankAccount = account;\n        this.dataSource = this.initDataSource(account, this.activeView.getValue());\n      }\n    });\n    appService.categoryMapObservable$.subscribe(categoryMap => {\n      if (categoryMap) {\n        this.categoryMap = categoryMap;\n      }}\n    )\n\n\n    this.activeViewObservable.subscribe(activeView => {\n      this.dataSource = this.initDataSource(this.bankAccount, activeView);\n    })\n\n  }\n\n  ngOnInit( ): void {\n  }\n\n  private initDataSource(account: BankAccount, transactionType: TransactionTypeEnum): GroupByCounterpartyDataSource {\n    if (transactionType == TransactionTypeEnum.BOTH){\n      throw new Error(\"TransactionType.BOTH not supported\")\n    }\n\n    let isExpense = transactionType === TransactionTypeEnum.EXPENSES;\n\n    let paginationDataSource = new PaginationDataSource<Transaction, BankAccount>(\n      (request, query) => {\n        request.size = 50;\n        return this.appService.pageTransactionsToManuallyReview(request, transactionType);\n      },\n      {property: 'counterparty', order: 'asc'}, account\n    );\n    return new GroupByCounterpartyDataSource(paginationDataSource, isExpense);\n  }\n\n\n  saveTransaction(transaction: Transaction) {\n    this.appService.saveTransaction(transaction)\n  }\n\n  setCategory(row: (Transaction | GroupBy), selectedCategoryQualifiedNameStr: string) {\n    // Get the SimpleCategory object from the CategoryMap\n    const category = this.categoryMap.getSimpleCategory(selectedCategoryQualifiedNameStr);\n\n    // Check if row is an interface that has key 'isGroupBy'\n    if (\"isGroupBy\" in row) {\n      (row as GroupBy).transactions.forEach(transaction => {\n        transaction.category = category;\n        this.saveTransaction(transaction);\n      });\n      return;\n    } else {\n      let transaction = row as Transaction;\n      transaction.category = category;\n      this.saveTransaction(transaction);\n    }\n  }\n\n  amountType(transaction: Transaction | GroupBy): AmountType {\n    if (\"isGroupBy\" in transaction) {\n      return transaction.isExpense ? AmountType.EXPENSES : AmountType.REVENUE;\n    }\n    if (transaction.amount === undefined || transaction.amount === null) {\n      throw new Error(\"Amount is undefined or null\");\n    }\n    return inferAmountType(transaction.amount)\n\n\n  }\n\n  isGroup(index: any, item: any): boolean {\n    return item.isGroupBy;\n  }\n\n  onToggleChange($event: MatButtonToggleChange) {\n    this.tableElement.nativeElement.scrollIntoView({behavior: 'smooth', block: 'start'});\n    const value = $event.value;\n    if (value === \"expenses\") {\n      this.activeView.next(TransactionTypeEnum.EXPENSES);\n    } else if (value === \"revenue\") {\n      this.activeView.next(TransactionTypeEnum.REVENUE);\n    } else {\n      throw new Error(\"Unknown value \" + value);\n    }\n\n\n\n  }\n}\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "backingPaginationDataSource",
                        "type": "PaginationDataSource<Transaction | BankAccount>",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "isExpense",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 35,
                "jsdoctags": [
                    {
                        "name": "backingPaginationDataSource",
                        "type": "PaginationDataSource<Transaction | BankAccount>",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "isExpense",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "backingPaginationDataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "PaginationDataSource<Transaction | BankAccount>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "methods": [
                {
                    "name": "connect",
                    "args": [],
                    "optional": false,
                    "returnType": "Observable<Array<Transaction | GroupBy>>",
                    "typeParameters": [],
                    "line": 42,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "disconnect",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 72,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "fetch",
                    "args": [
                        {
                            "name": "page",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "pageSize",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 77,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "page",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "pageSize",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "SimpleDataSource"
            ]
        },
        {
            "name": "MatchTypes",
            "id": "class-MatchTypes-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "ALL",
                    "defaultValue": "[MatchTypes.ANY_OF, MatchTypes.ALL_OF]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RuleMatchType[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 225,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "ALL_OF",
                    "defaultValue": "{name: 'all of', value: 'all of'}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 224,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "ANY_OF",
                    "defaultValue": "{name: 'any of', value:'any of'}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RuleMatchType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 223,
                    "modifierKind": [
                        126
                    ]
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "MultiMap",
            "id": "class-MultiMap-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "map",
                    "defaultValue": "new Map<K, V[]>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 495,
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "methods": [
                {
                    "name": "clear",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 518,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "delete",
                    "args": [
                        {
                            "name": "key",
                            "type": "K",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 514,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "K",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "get",
                    "args": [
                        {
                            "name": "key",
                            "type": "K",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "[] | undefined",
                    "typeParameters": [],
                    "line": 506,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "K",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "has",
                    "args": [
                        {
                            "name": "key",
                            "type": "K",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 510,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "K",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "keys",
                    "args": [],
                    "optional": false,
                    "returnType": "K[]",
                    "typeParameters": [],
                    "line": 522,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "set",
                    "args": [
                        {
                            "name": "key",
                            "type": "K",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "value",
                            "type": "V",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 497,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "K",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "value",
                            "type": "V",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "MyErrorStateMatcher",
            "id": "class-MyErrorStateMatcher-ab5802e1347f1b484d762ed6e73a59f110ab93d7f293d3abc926c94b10090e9aaed528e4bcd7224404a36df227182a0c26149eedd0309c7062054dec8e0225ba",
            "file": "src/app/budget/budget.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport {FlatTreeControl} from \"@angular/cdk/tree\";\nimport {MatTreeFlatDataSource, MatTreeFlattener} from \"@angular/material/tree\";\nimport {\n  AbstractControl,\n  FormBuilder,\n  FormControl,\n  FormGroup,\n  FormGroupDirective,\n  FormsModule,\n  NgForm,\n  ReactiveFormsModule,\n  ValidatorFn\n} from \"@angular/forms\";\nimport {ErrorStateMatcher} from '@angular/material/core';\nimport {MatDialog} from \"@angular/material/dialog\";\nimport {SaveErrorDialogComponent} from \"./save-error-dialog/save-error-dialog.component\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {MatButton, MatIconButton} from '@angular/material/button';\nimport {MatIcon, MatIconModule, MatIconRegistry} from '@angular/material/icon';\nimport {NgClass, NgIf} from '@angular/common';\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from '@angular/material/table';\nimport {MatError, MatFormField} from '@angular/material/form-field';\nimport {MatInput} from '@angular/material/input';\n\nexport interface BudgetTreeNode {\n  budgetTreeNodeAmount: number;\n  budgetTreeNodeId: number;\n  budgetTreeNodeParentId: number;\n  children: BudgetTreeNode[];\n  name: string;\n  qualifiedName: string;\n}\n\nexport class FlatBudgetTreeNode {\n  level!: number;\n  expandable!: boolean;\n  name!: string;\n  qualifiedName!: string;\n  budgetTreeNodeId!: number;\n  budgetTreeNodeAmount!: number;\n  budgetTreeNodeParentId!: number;\n}\n\n\n\nexport interface FindOrCreateBudgetResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n  budgetTreeNodes: BudgetTreeNode[];\n  numberOfBudgetTreeNodes: number;\n\n}\n\nexport interface UpdateBudgetEntryResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n\n\n}\n\n\nexport class MyErrorStateMatcher implements ErrorStateMatcher {\n  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid);\n  }\n}\n\n\n@Component({\n    selector: 'app-budget',\n    templateUrl: './budget.component.html',\n    styleUrls: ['./budget.component.scss'],\n    standalone: true,\n  imports: [MatToolbar, BankAccountSelectionComponent,\n    MatButton, MatIcon, NgIf, FormsModule, ReactiveFormsModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell,\n    MatCellDef, MatCell, MatIconButton, MatFormField, MatInput, MatError, MatHeaderRowDef,\n    MatHeaderRow, MatRowDef, MatRow, NgClass, MatIconModule, MatIcon],\n\n})\nexport class BudgetComponent implements OnInit {\n  TOTAL_NODE_ID: number = -1;\n  TOTAL_NODE_CATEGORY_NAME = 'Totaal';\n\n  totalBudget: number = 0;\n\n  matcher = new MyErrorStateMatcher();\n\n\n  /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n  idToNodeMap = new Map<number, BudgetTreeNode>();\n\n  /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n  nestedNodeMap = new Map<BudgetTreeNode, FlatBudgetTreeNode>();\n\n  qualifiedNameToNodeMap = new Map<string, BudgetTreeNode>();\n\n  treeControl!: FlatTreeControl<FlatBudgetTreeNode>\n  dataSource!: MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>;\n\n\n  treeFlattener: MatTreeFlattener<BudgetTreeNode, FlatBudgetTreeNode>;\n\n  displayedColumns: string[] = ['category', 'budget', 'yearlyBudget'];\n\n  rowsToHighlight: Set<number> = new Set<number>();\n\n  idToControlsMap: Map<number, FormControl> = new Map<number, FormControl>();\n  controlsToIdMap: Map<FormControl, number> = new Map<FormControl, number>();\n  allControls: FormControl[] = [];\n  mainForm: FormGroup;\n  idToBudgetNodeMap: Map<number, BudgetTreeNode> = new Map<number, BudgetTreeNode>();\n  currentSubTreeHasError: boolean = false;\n  isTreeExpanded = true;\n\n\n  constructor(private appService: AppService, private fb: FormBuilder, public dialog: MatDialog\n  ) {\n\n    this.mainForm = this.fb.group({});\n\n    this.treeFlattener = new MatTreeFlattener(\n      this.transformer,\n      this.getLevel,\n      this.isExpandable,\n      this.getChildren\n    );\n    this.treeControl = new FlatTreeControl<FlatBudgetTreeNode>(\n      this.getLevel,\n      this.isExpandable\n    );\n    this.dataSource = new MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>(\n      this.treeControl,\n      this.treeFlattener\n    );\n\n\n\n  }\n\n\n  transformer = (node: BudgetTreeNode, level: number) => {\n    const existingNode = this.nestedNodeMap.get(node);\n    const flatNode =\n      existingNode && existingNode.qualifiedName === node.qualifiedName\n        ? existingNode\n        : new FlatBudgetTreeNode();\n    flatNode.name = node.name;\n    flatNode.qualifiedName = node.qualifiedName;\n    flatNode.level = level;\n    flatNode.expandable = (node.children != undefined && node.children.length > 0);\n    flatNode.budgetTreeNodeAmount = node.budgetTreeNodeAmount;\n    flatNode.budgetTreeNodeId = node.budgetTreeNodeId;\n    flatNode.budgetTreeNodeParentId = node.budgetTreeNodeParentId;\n    this.idToNodeMap.set(node.budgetTreeNodeId, node);\n\n    this.nestedNodeMap.set(node, flatNode);\n    this.qualifiedNameToNodeMap.set(node.qualifiedName, node);\n    return flatNode;\n  };\n\n  getLevel = (node: FlatBudgetTreeNode) => node.level;\n\n  isExpandable = (node: FlatBudgetTreeNode) => node.expandable;\n\n  getChildren = (node: BudgetTreeNode): BudgetTreeNode[] => node.children;\n\n  hasChild = (_: number, _nodeData: FlatBudgetTreeNode) => _nodeData.expandable;\n\n  inputChanged: boolean = false;\n  dataLoaded: boolean = false;\n  isSaved: boolean = false;\n\n\n  getRowClass(data: FlatBudgetTreeNode): string {\n    if (data.name === this.TOTAL_NODE_CATEGORY_NAME) {\n      return 'highlight-total-row';\n    }\n    if (this.currentSubTreeHasError && this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-error';\n    }\n    if (this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-no-error';\n    }\n    return '';\n  }\n\n\n  ngOnInit(): void {\n    this.appService.selectedBankAccountObservable$.subscribe(selectedAccount => {\n      if (selectedAccount) {\n        this.appService.findOrCreateBudget(selectedAccount).subscribe((response: BudgetTreeNode[]) => {\n\n          let filteredData = response.filter(node => node.name !== 'NO CATEGORY' && node.name !== 'DUMMY CATEGORY');\n          let totalBudgetTreeNode = this.initTotalBudgetTreeNode();\n          filteredData.push(totalBudgetTreeNode);\n          this.dataSource.data = filteredData;\n          let allBudgetNodes: BudgetTreeNode[] = [];\n          for (const node of response) {\n            if (node.name === 'NO CATEGORY' || node.name === 'DUMMY CATEGORY') {\n              continue;\n            }\n            allBudgetNodes.push(node);\n            this.getAllDescendantsRecursively(node, allBudgetNodes);\n          }\n\n\n          for (const node of allBudgetNodes) {\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            let control = new FormControl<number>(node.budgetTreeNodeAmount, [this.budgetValidator(), this.negativeNumberValidator()]);\n            this.idToControlsMap.set(node.budgetTreeNodeId, control);\n            control.valueChanges.subscribe((value) => {\n              if ((value !== undefined)) {\n                // this.inputChanged = false;\n                this.validateAllControls();\n                this.calculateTotalBudget();\n\n                let flatNode = this.nestedNodeMap.get(node);\n                if (flatNode){\n                  if (flatNode.name === this.TOTAL_NODE_CATEGORY_NAME) {\n                    //we don't want to do anything when the total node is changed\n                    return;\n                  }\n                  this.determineSubTreeForNode(flatNode as FlatBudgetTreeNode);\n                  if (!this.currentSubTreeHasError){\n                    this.onBudgetChange(flatNode as FlatBudgetTreeNode);\n                  }\n                }\n              }\n            });\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            this.controlsToIdMap.set(control, node.budgetTreeNodeId);\n            this.allControls.push(control);\n            this.mainForm.addControl(node.budgetTreeNodeId.toString(), control);\n          }\n          this.calculateTotalBudget();\n          this.dataLoaded = true;\n          this.treeControl.expandAll();\n\n        });\n      }\n    });\n\n  }\n\n  getDescendantIds(node: BudgetTreeNode, allDescendantIds: number[]) {\n    if (node.children && node.children.length > 0) {\n      node.children.forEach(child => {\n        allDescendantIds.push(child.budgetTreeNodeId);\n        this.getDescendantIds(child, allDescendantIds);\n      });\n    }\n  }\n\n  validateAllControls() {\n    Object.keys(this.mainForm.controls).forEach(key => {\n      const control = this.mainForm.get(key);\n      if (control) {\n        control.updateValueAndValidity({onlySelf: false, emitEvent: false});\n\n      }\n    });\n    this.mainForm.markAllAsTouched();\n  }\n\n  budgetValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isLessThanSumOfDescendants = this.isLessThanSumOfDescendants(control as FormControl);\n      return isLessThanSumOfDescendants ? {'isLessThanItsDescendants': {value: control.value}} : null;\n    };\n  }\n\n  negativeNumberValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isNegative = control.value < 0;\n      return isNegative ? {'negativeNumber': {value: control.value}} : null;\n    };\n  }\n\n  isLessThanSumOfDescendants(control: FormControl): boolean {\n    let nodeId = this.controlsToIdMap.get(control);\n    if (!nodeId) {\n      return false;\n    }\n\n    let nodeValue = control.value;\n\n    if (nodeValue == undefined || nodeValue < 0) {\n      return false;\n    }\n    let sumOfDescendants = 0;\n\n    let payload = this.idToBudgetNodeMap.get(nodeId) as BudgetTreeNode;\n    let allDescendantIds: number[] = [];\n    this.getDescendantIds(payload, allDescendantIds);\n\n    for (const descendantId of allDescendantIds) {\n      let descendantValue = this.idToControlsMap.get(descendantId)?.value;\n      if (descendantValue) {\n        sumOfDescendants = sumOfDescendants + descendantValue;\n\n      }\n    }\n\n\n    let isLessThanSumOfDescendants = nodeValue < sumOfDescendants;\n    //unpacking boolean for debugging purposes\n    return isLessThanSumOfDescendants;\n\n  }\n\n\n  determineSubTreeForNode(data: FlatBudgetTreeNode) {\n    this.rowsToHighlight = new Set<number>();\n    this.currentSubTreeHasError = false;\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n    this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n    if (budgetTreeNode.budgetTreeNodeParentId) {\n      //go one level up the tree to the parent. Add the id of the parent and all its descendants to the set of rows to highlight\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeParentId);\n      let parentBudgetTreeNode = this.idToNodeMap.get(budgetTreeNode.budgetTreeNodeParentId);\n      if (parentBudgetTreeNode == undefined) {\n        return;\n      }\n\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(parentBudgetTreeNode, allDescendantIds);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n\n\n\n    } else {\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(budgetTreeNode, allDescendantIds);\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n    }\n    this.currentSubTreeHasError = this.anyFormControlIsInvalid(this.rowsToHighlight);\n\n\n  }\n\n  private anyFormControlIsInvalid(ids: Set<number>): boolean {\n    let idsArray = [...ids];\n    for (const number of idsArray) {\n      if(this.formControlIsInvalid(number)){\n        return true;\n      }\n    }\n\n    return false;\n\n\n\n\n  }\n\n  private formControlIsInvalid(budgetTreeNodeId: number): boolean {\n    let control = this.mainForm.get(budgetTreeNodeId.toString());\n    if (control) {\n      return control.invalid;\n    }\n    return false;\n  }\n\n\n  /*onBlur() {\n    this.inputChanged = true;\n  }\n\n  onKeyUpEnter(event: Event) {\n    let kbe = event as KeyboardEvent;\n    if (kbe.key === 'Enter') {\n      this.inputChanged = true;\n    }\n  }*/\n\n  getAllDescendantsRecursively(budgetTreeNode: BudgetTreeNode, descendants: BudgetTreeNode[]) {\n    if (budgetTreeNode.children && budgetTreeNode.children.length > 0) {\n      budgetTreeNode.children.forEach(child => {\n        descendants.push(child);\n        this.getAllDescendantsRecursively(child, descendants);\n      });\n    }\n  }\n\n\n\n\n  onBudgetChange(data: FlatBudgetTreeNode): void {\n\n    let budgetControl = this.mainForm.get(data.budgetTreeNodeId.toString()) as FormControl;\n    if (budgetControl == undefined) {\n      return;\n    }\n    if (data.budgetTreeNodeAmount === undefined || data.budgetTreeNodeAmount === null) {\n      data.budgetTreeNodeAmount = 0;\n      budgetControl.setValue(0);\n    }\n\n\n    if (!budgetControl.valid) {\n      return;\n    }\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n\n\n    if (budgetTreeNode.budgetTreeNodeAmount !== budgetControl.value) {\n      budgetTreeNode.budgetTreeNodeAmount = budgetControl.value;\n    }\n\n    this.appService.updateBudgetEntryAmount(budgetTreeNode).subscribe(\n      (\n        response: UpdateBudgetEntryResponse\n      ) => {\n        if (response.response.toLowerCase() !== \"success\") {\n          throw new Error(\"Failed to update budget entry amount\");\n        }\n        // this.recalculateCumulatedAmountsForAllNodes();\n        this.treeControl.expandAll();\n      });\n\n  }\n\n  sameSubTreeAsFocusedBudgetNode(data: FlatBudgetTreeNode): boolean {\n    return this.rowsToHighlight.has(data.budgetTreeNodeId);\n\n  }\n\n\n  /*onInputChange() {\n    this.inputChanged = true\n  }*/\n\n  saveAll() {\n    if (this.mainForm.invalid) {\n      let invalidCategories: BudgetTreeNode[] = [];\n      Object.keys(this.mainForm.controls).forEach(key => {\n        const control = this.mainForm.get(key);\n        if (control && control.invalid) {\n          let node = this.idToNodeMap.get(parseInt(key));\n          if (!node) {\n            throw new Error(\"Failed to find node for id \" + key);\n          }\n          node.budgetTreeNodeAmount = control.value;\n          invalidCategories.push(node);\n\n\n        }\n      });\n      this.dialog.open(SaveErrorDialogComponent, {\n        data: {\n          message: 'Sommige wijzingen kunnen niet worden opgeslaan! Corrigeer de inconsistente budgetbedragen voor onderstaande categorieën en probeer opnieuw:',\n          nodes: invalidCategories\n        }\n      });\n    } else {\n      let budgetTreeNodes = this.dataSource.data;\n      for (const budgetTreeNode of budgetTreeNodes) {\n        if (budgetTreeNode.budgetTreeNodeId === this.TOTAL_NODE_ID) {\n          continue;\n        }\n        let flatNode = this.nestedNodeMap.get(budgetTreeNode);\n        if (!flatNode) {\n          throw new Error(\"Failed to find flat node for budget tree node \" + budgetTreeNode);\n        } else {\n          this.onBudgetChange(flatNode);\n        }\n\n\n      }\n\n\n\n\n\n\n    }\n  }\n\n\n  toggleTree(): void {\n    if (this.isTreeExpanded) {\n      this.treeControl.collapseAll();\n    } else {\n      this.treeControl.expandAll();\n    }\n    this.isTreeExpanded = !this.isTreeExpanded;\n  }\n\n  calculateTotalBudget(): void {\n    this.totalBudget = Array.from(this.idToControlsMap.values()).filter(control => control.valid)\n      .reduce((sum, control) => sum + (control.value || 0), 0);\n    let totalNode = {\n      budgetTreeNodeAmount: this.totalBudget,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n    this.dataSource.data = [totalNode, ...this.dataSource.data.slice(1, this.dataSource.data.length - 1), totalNode];\n    this.mainForm.get(totalNode.budgetTreeNodeId.toString())?.setValue(totalNode.budgetTreeNodeAmount);\n  }\n\n  initTotalBudgetTreeNode(): BudgetTreeNode {\n    return {\n      budgetTreeNodeAmount: 0,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n  }\n\n}\n\n\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [],
            "methods": [
                {
                    "name": "isErrorState",
                    "args": [
                        {
                            "name": "control",
                            "type": "FormControl | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "form",
                            "type": "FormGroupDirective | NgForm | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 79,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "control",
                            "type": "FormControl | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "form",
                            "type": "FormGroupDirective | NgForm | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "ErrorStateMatcher"
            ]
        },
        {
            "name": "NumericalOperators",
            "id": "class-NumericalOperators-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "ALL",
                    "defaultValue": "[NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Operator[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 105,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "EQUALS",
                    "defaultValue": "new Operator('equals', '=', 'number')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 99,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "GREATER_THAN",
                    "defaultValue": "new Operator('greater than', '>', 'number')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 101,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "GREATER_THAN_OR_EQUALS",
                    "defaultValue": "new Operator('greater than or equals', '>=', 'number')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 102,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "LESS_THAN",
                    "defaultValue": "new Operator('less than', '<', 'number')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 103,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "LESS_THAN_OR_EQUALS",
                    "defaultValue": "new Operator('less than or equals', '<=', 'number')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 104,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "NOT_EQUALS",
                    "defaultValue": "new Operator('not equals', '!=', 'number')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 100,
                    "modifierKind": [
                        126
                    ]
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "Operator",
            "id": "class-Operator-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "name",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "value",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "fieldType",
                        "type": "FieldType",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 66,
                "jsdoctags": [
                    {
                        "name": "name",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "value",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "fieldType",
                        "type": "FieldType",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "name",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 66,
                    "modifierKind": [
                        148
                    ]
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 65,
                    "modifierKind": [
                        148
                    ]
                }
            ],
            "methods": [
                {
                    "name": "asOperator",
                    "args": [],
                    "optional": false,
                    "returnType": "RuleOperator",
                    "typeParameters": [],
                    "line": 77,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "equals",
                    "args": [
                        {
                            "name": "operator",
                            "type": "Operator",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "operator",
                            "type": "Operator",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "RuleOperator"
            ]
        },
        {
            "name": "PickDateAdapter",
            "id": "class-PickDateAdapter-9e17116a133eb210925dcc890127c847c0354fd226e1ef726cca053e94cf7ddee3bb4260cdbbbef15f6d06371856420bc709ea7f13868304023501247319f9f1",
            "file": "src/app/filters/filters.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport { FormBuilder, FormControl, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport {AppService} from '../app.service';\nimport {StartEndDateShortcut} from '../model';\n\nimport { DateAdapter, MAT_DATE_FORMATS, NativeDateAdapter, MatOption } from '@angular/material/core';\nimport { formatDate, NgFor } from '@angular/common';\nimport {Subject, takeUntil} from \"rxjs\";\nimport {BankAccount, GroupingEnum, TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\nimport { MatFormField, MatLabel, MatHint, MatSuffix } from '@angular/material/form-field';\nimport { MatSelect } from '@angular/material/select';\nimport { MatDateRangeInput, MatStartDate, MatEndDate, MatDatepickerToggle, MatDateRangePicker } from '@angular/material/datepicker';\nimport { MatButton } from '@angular/material/button';\n\nexport const PICK_FORMATS = {\n  parse: {dateInput: {month: 'short', year: 'numeric', day: 'numeric'}},\n  display: {\n    dateInput: 'input',\n    monthYearLabel: {year: 'numeric', month: 'short'},\n    dateA11yLabel: {year: 'numeric', month: 'long', day: 'numeric'},\n    monthYearA11yLabel: {year: 'numeric', month: 'long'}\n  }\n};\n\nclass PickDateAdapter extends NativeDateAdapter {\n\n  override format(date: Date, displayFormat: Object): string {\n    if (displayFormat === 'input') {\n      return formatDate(date, 'dd-MMM-yyyy', this.locale);\n\n    } else {\n      return date.toDateString();\n    }\n  }\n}\n\n@Component({\n    selector: 'app-filters',\n    templateUrl: './filters.component.html',\n    styleUrls: ['./filters.component.scss'],\n    providers: [\n        { provide: DateAdapter, useClass: PickDateAdapter },\n        { provide: MAT_DATE_FORMATS, useValue: PICK_FORMATS }\n    ],\n    standalone: true,\n    imports: [FormsModule, ReactiveFormsModule, MatFormField, MatLabel, MatSelect, NgFor, MatOption, MatDateRangeInput, MatStartDate, MatEndDate, MatHint, MatDatepickerToggle, MatSuffix, MatDateRangePicker, MatButton]\n})\nexport class FiltersComponent implements OnInit {\n\n\n  bankAccountFormFieldGroup: FormGroup;\n\n\n  bankAccounts: BankAccount[] = [];\n\n  startEndDateFormFieldGroup: FormGroup;\n\n  groupingTypesFormFieldGroup: FormGroup;\n\n  groupingTypes: Map<string, GroupingEnum> = new Map<string, GroupingEnum>();\n  groupingTypeStringValues: string[];\n\n\n  transactionTypeFormFieldGroup: FormGroup;\n  transactionTypes: Map<string, TransactionTypeEnum> = new Map<string, TransactionTypeEnum>();\n  transactionTypeStringValues: string[];\n\n  startEndDateShortCuts: Map<string, StartEndDateShortcut> = new Map<string, StartEndDateShortcut>();\n  startEndDateShortCutStringValues: string[];\n\n\n  startDate = new FormControl<Date | null>(null);\n  endDate = new FormControl<Date | null>(null);\n  private destroy$ = new Subject<void>();\n\n  constructor(private appService: AppService, private formBuilder: FormBuilder) {\n    this.appService.fetchBankAccountsForUser()\n      .pipe(takeUntil(this.destroy$))\n\n      .subscribe(result => {\n          if (result == undefined) {\n            return;\n          }\n          this.appService.setBankAccount(result[0]);\n          return this.bankAccounts = result\n        }\n      )\n    this.bankAccountFormFieldGroup = formBuilder.group({queryForm: \"\"});\n    this.startEndDateFormFieldGroup = formBuilder.group({queryForm: \"\"});\n    this.transactionTypeFormFieldGroup = formBuilder.group({queryForm: \"\"});\n    this.transactionTypeFormFieldGroup = formBuilder.group({queryForm: \"\"});\n    this.groupingTypesFormFieldGroup = formBuilder.group({queryForm: \"\"});\n\n    this.groupingTypes.set(\"month\", GroupingEnum.month)\n    this.groupingTypes.set(\"year\", GroupingEnum.year)\n    this.groupingTypes.set(\"quarter\", GroupingEnum.quarter)\n    this.groupingTypeStringValues = Array.from(this.groupingTypes.keys());\n\n\n    this.startEndDateShortCuts.set(\"huidige maand\", StartEndDateShortcut.CURRENT_MONTH);\n    this.startEndDateShortCuts.set(\"huidig kwartaal\", StartEndDateShortcut.CURRENT_QUARTER);\n    this.startEndDateShortCuts.set(\"huidig jaar\", StartEndDateShortcut.CURRENT_YEAR);\n    this.startEndDateShortCuts.set(\"alles\", StartEndDateShortcut.ALL);\n    this.startEndDateShortCutStringValues = Array.from(this.startEndDateShortCuts.keys());\n\n\n    this.transactionTypes.set(\"in- & uitkomsten\", TransactionTypeEnum.BOTH)\n    this.transactionTypes.set(\"uitgaven\", TransactionTypeEnum.EXPENSES)\n    this.transactionTypes.set(\"inkomsten\", TransactionTypeEnum.REVENUE)\n    this.transactionTypeStringValues = Array.from(this.transactionTypes.keys());\n\n\n  }\n\n  ngOnInit() {\n  }\n\n  dateClass = (d: Date) => {\n    const date = d.getDay();\n    // Highlight saturday and sunday.\n    return (date === 0 || date === 6) ? 'highlight-dates' : undefined;\n  }\n\n  onBankAccountChange(bankAccount: BankAccount) {\n    this.appService.setBankAccount(bankAccount);\n\n\n  }\n\n\n  setStartAndEndDate() {\n    console.log(this.startDate.value);\n    console.log(this.endDate.value);\n    if (this.startDate.value && this.endDate.value) {\n\n      this.appService.setStartAndEndDate(this.startDate.value, this.endDate.value)\n    }\n  }\n\n  onTransactionTypeChange(transactionTypeStr: string) {\n    console.log(transactionTypeStr);\n    var transactionType: TransactionTypeEnum | undefined = this.transactionTypes.get(transactionTypeStr)\n    if (transactionType == undefined) {\n      transactionType = TransactionTypeEnum.BOTH;\n    }\n    this.appService.setTransactionType(transactionType);\n  }\n\n  onGroupingChange(groupingStr: string) {\n    console.log(groupingStr);\n    var groupingType: GroupingEnum | undefined = this.groupingTypes.get(groupingStr)\n    if (groupingType == undefined) {\n      groupingType = GroupingEnum.month;\n    }\n    this.appService.setGrouping(groupingType);\n  }\n\n  onPeriodShortCutClick(periodStr: string) {\n    var shortCut: StartEndDateShortcut | undefined = this.startEndDateShortCuts.get(periodStr);\n\n\n    if (shortCut == undefined) {\n      shortCut = StartEndDateShortcut.ALL;\n    }\n\n    this.appService.resolveStartEndDateShortcut(shortCut).subscribe(resolved => {\n\n      this.startDate.setValue(resolved.start);\n      this.endDate.setValue(resolved.end);\n    })\n\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n\n}\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [],
            "methods": [
                {
                    "name": "format",
                    "args": [
                        {
                            "name": "date",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "displayFormat",
                            "type": "Object",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        164
                    ],
                    "jsdoctags": [
                        {
                            "name": "date",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "displayFormat",
                            "type": "Object",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [
                "NativeDateAdapter"
            ],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "PickDateAdapter",
            "id": "class-PickDateAdapter-335aca2c1e090f252828a8a930335c97ab771705d2b4d4c11058724da057ad96d7d6da160ecd008b1d470e42b1ddb32d8a86475ab2b36bad5228c8844d964583-1",
            "file": "src/app/period-selection/period-selection.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import { formatDate, NgIf, NgFor } from '@angular/common';\nimport {Component, EventEmitter, OnChanges, OnInit, Output, ViewChild} from '@angular/core';\nimport { FormBuilder, FormControl, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { DateAdapter, MAT_DATE_FORMATS, NativeDateAdapter, MatOption } from '@angular/material/core';\nimport {NgSelectComponent} from '@ng-select/ng-select';\nimport {AppService} from '../app.service';\nimport {StartEndDateShortcut} from '../model';\nimport { DateFilterFn, MatDateRangeInput, MatStartDate, MatEndDate, MatDatepickerToggle, MatDateRangePicker } from \"@angular/material/datepicker\";\nimport { MatFormField, MatLabel, MatSuffix } from '@angular/material/form-field';\nimport { MatButton } from '@angular/material/button';\nimport { MatSelect } from '@angular/material/select';\n\nexport const PICK_FORMATS = {\n  parse: { dateInput: { month: 'short', year: 'numeric', day: 'numeric' } },\n  display: {\n    dateInput: 'input',\n    monthYearLabel: { year: 'numeric', month: 'short' },\n    dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },\n    monthYearA11yLabel: { year: 'numeric', month: 'long' }\n  }\n};\n\nclass PickDateAdapter extends NativeDateAdapter {\n\n  override format(date: Date, displayFormat: Object): string {\n    if (displayFormat === 'input') {\n      return formatDate(date, 'dd-MMM-yyyy', this.locale);\n    } else {\n      return date.toDateString();\n    }\n  }\n}\n\n@Component({\n    selector: 'period-selection',\n    templateUrl: './period-selection.component.html',\n    styleUrls: ['./period-selection.component.scss'],\n    providers: [\n        { provide: DateAdapter, useClass: PickDateAdapter },\n        { provide: MAT_DATE_FORMATS, useValue: PICK_FORMATS }\n    ],\n    standalone: true,\n    imports: [MatFormField, MatLabel, MatDateRangeInput, FormsModule, ReactiveFormsModule, MatStartDate, MatEndDate, MatDatepickerToggle, MatSuffix, MatDateRangePicker, NgIf, MatButton, MatSelect, NgFor, MatOption]\n})\nexport class PeriodSelectionComponent implements OnInit, OnChanges {\n\n  formFieldGroup: FormGroup;\n  startDate: any;\n  endDate: any;\n\n\n  startEndDateShortCuts: Map<string, StartEndDateShortcut> = new Map<string, StartEndDateShortcut>();\n  startEndDateShortCutStringValues: string[];\n\n  range = new FormGroup({\n    start: new FormControl<Date | null>(null),\n    end: new FormControl<Date | null>(null),\n  });\n\n  @Output() change: EventEmitter<Date[]> = new EventEmitter<Date[]>(true);\n\n  displayShortcutsAsDropdown: boolean = true;\n  periodShortcutDropDownSelection!: string;\n  @ViewChild(NgSelectComponent) ngSelect!: NgSelectComponent;\n\n  allowDate: DateFilterFn<any> = function (date: Date | null): boolean {\n    if (!date) {\n      return false;\n    }\n    //check if date is first day of month or last day of month\n    return date.getDate() === 1 || new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate() === date.getDate();\n\n\n\n  };\n\n  constructor(private appService: AppService, private formBuilder: FormBuilder) {\n      this.formFieldGroup = formBuilder.group({ queryForm: \"\" });\n\n    this.startEndDateShortCuts.set(\"huidige maand\", StartEndDateShortcut.CURRENT_MONTH);\n    this.startEndDateShortCuts.set(\"vorige maand\", StartEndDateShortcut.PREVIOUS_MONTH);\n    this.startEndDateShortCuts.set(\"huidig kwartaal\", StartEndDateShortcut.CURRENT_QUARTER);\n    this.startEndDateShortCuts.set(\"vorig kwartaal\", StartEndDateShortcut.PREVIOUS_QUARTER);\n    this.startEndDateShortCuts.set(\"huidig jaar\", StartEndDateShortcut.CURRENT_YEAR);\n    this.startEndDateShortCuts.set(\"vorig jaar\", StartEndDateShortcut.PREVIOUS_YEAR);\n    this.startEndDateShortCuts.set(\"alles\", StartEndDateShortcut.ALL);\n    this.startEndDateShortCutStringValues = Array.from(this.startEndDateShortCuts.keys());\n\n\n  }\n\n  ngOnInit() {\n    this.appService.resolveStartEndDateShortcut(StartEndDateShortcut.ALL).subscribe(resolved => {\n      this.range.controls.start = new FormControl<Date>(new Date(resolved.start));\n      this.range.controls.end = new FormControl<Date>(new Date(resolved.end));\n      this.startDate = resolved.start;\n      this.endDate = resolved.end;\n      this.change.emit([this.startDate, this.endDate]);\n      this.appService.setStartAndEndDate(this.startDate, this.endDate);\n\n    })\n\n\n\n  }\n\n  getDropdownKeys(): string[] {\n    return Array.from(this.startEndDateShortCuts.keys())\n  }\n\n  ngOnChanges() {\n    let startDate = new Date(this.startDate);\n    let endDate = new Date(this.endDate);\n    this.change.emit([startDate, endDate]);\n    this.appService.setStartAndEndDate(startDate, endDate);\n  }\n\n\n\n  onPeriodShortCutClick(periodStr: string) {\n\n    var shortCut: StartEndDateShortcut | undefined = this.startEndDateShortCuts.get(periodStr);\n    if (shortCut == undefined) {\n      shortCut = StartEndDateShortcut.ALL;\n    }\n\n    this.appService.resolveStartEndDateShortcut(shortCut).subscribe(resolved => {\n\n      this.range.controls.start.setValue(new Date(resolved.start));\n      this.range.controls.end.setValue(new Date(resolved.end));\n      this.startDate = resolved.start;\n      this.endDate = resolved.end;\n      this.ngOnChanges();\n\n    })\n\n\n  }\n\n\n  /**\n   * we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n   * @returns\n   */\n  onDropDownChange() {\n    if (this.periodShortcutDropDownSelection === null || this.periodShortcutDropDownSelection === undefined) {\n        return;\n    }\n\n    var shortCut: StartEndDateShortcut | undefined = this.startEndDateShortCuts.get(this.periodShortcutDropDownSelection);\n    if (shortCut == undefined) {\n      shortCut = StartEndDateShortcut.ALL;\n    }\n\n    this.appService.resolveStartEndDateShortcut(shortCut).subscribe(resolved => {\n\n      this.range.controls.start.setValue(new Date(resolved.start));\n      this.range.controls.end.setValue(new Date(resolved.end));\n      this.startDate = resolved.start;\n      this.endDate = resolved.end;\n      this.ngOnChanges();\n\n    })\n\n\n\n\n\n  }\n\n\n  doFileter() {\n\n\n  }\n}\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [],
            "methods": [
                {
                    "name": "format",
                    "args": [
                        {
                            "name": "date",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "displayFormat",
                            "type": "Object",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 25,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        164
                    ],
                    "jsdoctags": [
                        {
                            "name": "date",
                            "type": "Date",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "displayFormat",
                            "type": "Object",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [
                "NativeDateAdapter"
            ],
            "hostBindings": [],
            "hostListeners": [],
            "isDuplicate": true,
            "duplicateId": 1,
            "duplicateName": "PickDateAdapter-1"
        },
        {
            "name": "PieChartData",
            "id": "class-PieChartData-22f23af21ebbd36b25dc449f65d4362f535099da61bcc7f1d48775b93e168fae84d2378f08dfdbb0ebc2f11f916aa179bb55a1b8c106184dc17ba033b33f33ce",
            "file": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport { LegendPosition, PieChartModule } from \"@swimlane/ngx-charts\";\nimport {DistributionByCategoryForPeriodChartData, Period} from \"../model\";\nimport { NgIf, NgFor } from '@angular/common';\nimport { MatCard, MatCardHeader, MatCardContent } from '@angular/material/card';\n\n\n\n@Component({\n    selector: 'analysis-for-period-by-category',\n    templateUrl: './analysis-for-period-by-category.component.html',\n    styleUrls: ['./analysis-for-period-by-category.component.scss'],\n    standalone: true,\n    imports: [\n        NgIf,\n        NgFor,\n        MatCard,\n        MatCardHeader,\n        MatCardContent,\n        PieChartModule,\n    ],\n})\nexport class AnalysisForPeriodByCategoryComponent implements OnInit {\n\n  //data\n  single: any[] = [];\n  public incomeDataPieChart: PieChartData[] = [];\n  public expensesDataPieChart: PieChartData[] = [];\n\n  //\n  isLoaded: boolean = false;\n\n  // options\n  view: [number, number] = [700, 400];\n  gradient: boolean = true;\n  showLegend: boolean = false;\n  showLabels: boolean = true;\n  isDoughnut: boolean = false;\n  legendPosition: LegendPosition = LegendPosition.Below;\n\n  customColors: any[] = [];\n\n\n  constructor(public appService: AppService) {\n    this.isLoaded = false;\n  }\n\n\n  ngOnInit(): void {\n\n    let labelColors: Map<string, string> = new Map<string, string>();\n    this.appService.categoryQueryForSelectedPeriodObservable$.subscribe(query => {\n      if(!query){\n        return;\n      }\n      this.appService.getRevenueExpensesPerPeriodAndCategoryShow1MonthBeforeAndAfter(query).subscribe(result => {\n        this.expensesDataPieChart = [];\n        for (const expense of result.chartDataExpenses) {\n          this.expensesDataPieChart.push(PieChartData.fromDistributionByCategoryForPeriodChartData(expense, labelColors));\n        }\n\n        this.incomeDataPieChart = [];\n        for (const income of result.chartDataRevenue) {\n          this.incomeDataPieChart.push(PieChartData.fromDistributionByCategoryForPeriodChartData(income, labelColors))\n        }\n\n        this.isLoaded = true;\n        for (const label of labelColors.keys()) {\n          let color = labelColors.get(label);\n          this.customColors.push({\"name\": label,\"value\": color})\n        }\n\n\n      })\n    })\n  }\n\n\n\n\n}\n\nexport class PieChartData {\n  nameValuePairs: any[];\n  period: Period;\n\n\n  constructor(nameValuePairs: any[], period: Period) {\n    this.nameValuePairs = nameValuePairs;\n    this.period = period;\n  }\n\n  static fromDistributionByCategoryForPeriodChartData(obj: DistributionByCategoryForPeriodChartData, labelColors: Map<string, string>): PieChartData {\n    let arr: any[] = [];\n    obj.entries.forEach((categoryAndAmount => {\n      let result = {\n        \"name\": categoryAndAmount.category,\n        \"value\": Math.abs(categoryAndAmount.amount)\n      };\n      arr.push(result);\n      getColorForLabel(result.name, labelColors)\n\n\n    }))\n    return new PieChartData(arr, obj.period as Period);\n\n  }\n}\n\nfunction getRandomColor() {\n  return '#' + Math.floor(Math.random()*16777215).toString(16);\n}\n\n\nfunction getColorForLabel(label: string, labelColors: Map<string, string>): string {\n\n  if (!labelColors.get(label)) {\n\n    labelColors.set(label, getRandomColor());\n  }\n\n  return labelColors.get(label) as string;\n}\n\n\n\n\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "nameValuePairs",
                        "type": "any[]",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "period",
                        "type": "Period",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 86,
                "jsdoctags": [
                    {
                        "name": "nameValuePairs",
                        "type": "any[]",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "period",
                        "type": "Period",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "nameValuePairs",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 85
                },
                {
                    "name": "period",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Period",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 86
                }
            ],
            "methods": [
                {
                    "name": "fromDistributionByCategoryForPeriodChartData",
                    "args": [
                        {
                            "name": "obj",
                            "type": "DistributionByCategoryForPeriodChartData",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "labelColors",
                            "type": "Map<string | string>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "PieChartData",
                    "typeParameters": [],
                    "line": 94,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "obj",
                            "type": "DistributionByCategoryForPeriodChartData",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "labelColors",
                            "type": "Map<string | string>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "ResolvedStartEndDateShortcut",
            "id": "class-ResolvedStartEndDateShortcut-bc71207f91c221f14aecf636aee240aea04248d4d6ddae222d342cb6adff6827ee7701181a37c95ad76116be8351d96dbe207db006609dbbfe68e09ff30f8243",
            "file": "src/app/model.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {SimpleCategory, TypeEnum} from '@daanvdn/budget-assistant-client';\r\n\r\nexport interface CategoryAndAmount {\r\n    amount: number;\r\n    category: string;\r\n    categoryId: number;\r\n    isRevenue: boolean;\r\n\r\n}\r\n\r\nexport function anyIsUndefinedOrEmpty(...args: any[]): boolean {\r\n    for (var a of args) {\r\n        if (a === undefined || a === null) {\r\n            return true;\r\n        }\r\n        //check if string\r\n        if (typeof a === 'string' && a === \"\") {\r\n            return true;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n}\r\n\r\nexport interface PeriodAndAmount {\r\n\r\n    period: string;\r\n    amount: Number;\r\n\r\n}\r\n\r\nexport interface Counterparty {\r\n\r\n    name: string;\r\n    accountNumber: string | null;\r\n    streetAndNumber: string | null;\r\n    zipCodeAndCity: string | null;\r\n    category: string | null;\r\n\r\n}\r\n\r\nexport interface Transaction {\r\n\r\n    transaction_id: string | null;\r\n    bankAccount: string | null;\r\n    bookingDate: Date | null;\r\n    statementNumber: string | null;\r\n    transactionNumber: number | null;\r\n    counterparty: Counterparty | null;\r\n    transaction: string | null;\r\n    currencyDate: Date | null;\r\n    amount: Number | null;\r\n    currency: string | null;\r\n    bic: string | null;\r\n    countryCode: string | null;\r\n    communications: string | null;\r\n    category: string | null;\r\n    manuallyAssignedCategory: Boolean | null;\r\n    isRecurring: Boolean | null;\r\n    isAdvanceSharedAccount: Boolean | null;\r\n    isManuallyReviewed: Boolean | null;\r\n\r\n\r\n}\r\n\r\n\r\nexport interface TransactionQuery {\r\n\r\n\r\n    revenue: Boolean | undefined;\r\n    expenses: Boolean | undefined;\r\n    counterpartyName: string | undefined;\r\n    minAmount: Number | undefined;\r\n    maxAmount: Number | undefined;\r\n    accountNumber: string | undefined;\r\n    category: string | undefined;\r\n    freeText: string | undefined;\r\n    counterpartyAccountNumber: string | undefined;\r\n    startDate: Date | undefined | null;\r\n    endDate: Date | undefined | null;\r\n    transactionOrCommunication: string | undefined | null;\r\n    uploadTimestamp: string | undefined | null;\r\n\r\n\r\n}\r\n\r\nexport interface TransactionsInContextQuery{\r\n    bankAccount: string;\r\n    period: string;\r\n    transactionType: TransactionType;\r\n    category: string;\r\n}\r\n\r\n\r\nexport interface FileWrapper {\r\n\r\n    file: File;\r\n    inProgress: Boolean;\r\n    progress: Number;\r\n    failed: Boolean;\r\n\r\n}\r\n\r\n\r\nexport interface CompositeTransactionsFileUploadResponse {\r\n\r\n    responses: TransactionsFileUploadResponse[];\r\n    uploadTimestamp: string;\r\n}\r\n\r\nexport interface TransactionsFileUploadResponse {\r\n\r\n    message: string;\r\n    type: string;\r\n\r\n}\r\n\r\n\r\nexport interface TransactionsFileUploadResponseWrapper {\r\n    response: TransactionsFileUploadResponse;\r\n    fileWrapper: FileWrapper;\r\n}\r\n\r\n\r\nexport const EMPTY_TRANSACTION_QUERY: TransactionQuery = {\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}\r\n\r\n\r\nexport enum Grouping {\r\n    MONTH = \"month\",\r\n    QUARTER = \"quarter\",\r\n    YEAR = \"year\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByTransactionTypeForPeriod {\r\n    period: Period;\r\n    revenue: number;\r\n    expenses: number;\r\n    balance: number;\r\n    start: string;\r\n    end: string;\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult {\r\n    chartData: DistributionByCategoryForPeriodChartData[];\r\n    tableData: DistributionByCategoryForPeriodTableData[];\r\n    tableColumnNames: string[];\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodHandlerResult2 {\r\n    chartDataRevenue: DistributionByCategoryForPeriodChartData[];\r\n    chartDataExpenses: DistributionByCategoryForPeriodChartData[];\r\n    tableDataRevenue: DistributionByCategoryForPeriodTableData[]\r\n    tableDataExpenses: DistributionByCategoryForPeriodTableData[]\r\n    tableColumnNames: string[];\r\n}\r\n\r\n\r\nexport interface Dataset {\r\n    label: string;\r\n    data: number[];\r\n    maxBarThickness?: number;\r\n}\r\n\r\nexport interface CategoryDetailsForPeriodHandlerResult {\r\n    labels: string[];\r\n    datasets: Dataset[];\r\n}\r\n\r\n\r\nexport interface Period {\r\n\r\n    start: string;\r\n    end: string;\r\n    grouping: Grouping;\r\n    value: string;\r\n\r\n\r\n}\r\n\r\n\r\nexport const EMPTY_PERIOD: Period = {\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}\r\n\r\nexport enum TransactionType {\r\n    REVENUE = \"revenue\",\r\n    EXPENSES = \"expenses\",\r\n    BOTH = \"both\"\r\n\r\n\r\n}\r\n\r\nexport interface DistributionByCategoryForPeriodChartData {\r\n    period: object;\r\n    transactionType: TransactionType;\r\n    entries: CategoryAndAmount[];\r\n\r\n}\r\n\r\n\r\nexport interface DistributionByCategoryForPeriodTableData {\r\n    [key: string]: any;\r\n\r\n}\r\n\r\n\r\n\r\nexport class ResolvedStartEndDateShortcut {\r\n    start: Date;\r\n    end: Date;\r\n\r\n    constructor(start: Date, end: Date) {\r\n        this.start = start\r\n        this.end = end\r\n    }\r\n\r\n\r\n}\r\n\r\nexport enum StartEndDateShortcut {\r\n\r\n\r\n    CURRENT_MONTH = \"current month\",\r\n    PREVIOUS_MONTH = \"previous month\",\r\n    CURRENT_QUARTER = \"current quarter\",\r\n    PREVIOUS_QUARTER = \"previous quarter\",\r\n    CURRENT_YEAR = \"current year\",\r\n    PREVIOUS_YEAR = \"previous year\",\r\n    ALL = \"all\"\r\n}\r\n\r\nexport interface User {\r\n    firstName: string | undefined\r\n    lastName: string | undefined\r\n    userName: string | undefined;\r\n    password: string | undefined;\r\n    email: string | undefined;\r\n    bankAccounts: string[] | undefined;\r\n}\r\n\r\nexport const DUMMY_USER: User = {\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}\r\n\r\nexport enum Type {\r\n    SUCCESS = \"SUCCESS\", FAILED = \"FAILED\"\r\n}\r\n\r\nexport interface TransactionsCategorizationResponse {\r\n    message: string;\r\n    withCategoryCount: number;\r\n    withoutCategoryCount: number;\r\n    type: Type;\r\n}\r\n\r\nexport interface BankAccount {\r\n\r\n    accountNumber: string;\r\n    alias: string | undefined | null;\r\n    editAlias: boolean;\r\n\r\n}\r\n\r\nexport enum ActiveView {\r\n    EXPENSES = \"expenses\", REVENUE = \"revenue\"\r\n}\r\n\r\n\r\ninterface BudgetTrackerResultNode {\r\n    data: Record<string, any>;\r\n    children: BudgetTrackerResultNode[];\r\n    leaf: boolean;\r\n}\r\n\r\nexport interface BudgetTrackerResult {\r\n\r\n    data: BudgetTrackerResultNode[];\r\n    columns: string[];\r\n\r\n\r\n}\r\n\r\n\r\nexport type CategoryType = \"EXPENSES\" | \"REVENUE\";\r\n\r\nexport interface CategoryNode {\r\n\r\n    children: CategoryNode[];\r\n    name: string;\r\n    qualifiedName: string;\r\n    type: TypeEnum | undefined;\r\n    id: number;\r\n\r\n\r\n}\r\n\r\nexport function inferAmountType(amount: number) {\r\n    if (amount >= 0) {\r\n        return AmountType.REVENUE;\r\n    }\r\n    else if (amount < 0) {\r\n        return AmountType.EXPENSES;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown amount type \" + amount);\r\n    }\r\n}\r\n\r\nexport enum AmountType {\r\n    REVENUE = \"REVENUE\",\r\n    EXPENSES = \"EXPENSES\",\r\n    BOTH = \"BOTH\",\r\n}\r\n\r\nexport class FlatCategoryNode {\r\n    level!: number;\r\n    expandable!: boolean;\r\n    name!: string;\r\n    qualifiedName!: string;\r\n    nodeId!: number;\r\n    type: TypeEnum | undefined;\r\n}\r\n\r\nconst DUMMY_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}\r\nexport const NO_CATEGORY: CategoryNode = {\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}\r\n\r\nexport class CategoryMap {\r\n\r\n    private idToNameMap: Map<number, string> = new Map<number, string>();\r\n    private qualifiedNameToIdMap: Map<string, number> = new Map<string, number>();\r\n    private qualifiedNameToNameMap: Map<string, string> = new Map<string, string>();\r\n    private simpleCategoryMap: Map<string, SimpleCategory> = new Map<string, SimpleCategory>();\r\n\r\n    constructor(nodes: CategoryNode[]) {\r\n        for (let node of nodes) {\r\n            this.populateMaps(node);\r\n        }\r\n    }\r\n\r\n    private populateMaps(node: CategoryNode) {\r\n        this.idToNameMap.set(node.id, node.name);\r\n        this.qualifiedNameToIdMap.set(node.qualifiedName, node.id);\r\n        this.qualifiedNameToNameMap.set(node.qualifiedName, node.name);\r\n\r\n        // Store a SimpleCategory object for each node\r\n        this.simpleCategoryMap.set(node.qualifiedName, {\r\n            qualifiedName: node.qualifiedName,\r\n            name: node.name,\r\n            id: node.id\r\n        });\r\n\r\n        for (let child of node.children) {\r\n            this.populateMaps(child);\r\n        }\r\n    }\r\n\r\n    public getName(id: number): string {\r\n        let name = this.idToNameMap.get(id);\r\n        if (name === undefined) {\r\n            throw new Error(\"No name found for id \" + id);\r\n        }\r\n        return name;\r\n    }\r\n\r\n    public getId(qualifiedName: string): number {\r\n        let id = this.qualifiedNameToIdMap.get(qualifiedName);\r\n        if (id === undefined) {\r\n            throw new Error(\"No id found for qualified name \" + qualifiedName);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    public getSimpleCategory(qualifiedName: string): SimpleCategory | null {\r\n        // If qualifiedName is undefined or null, return null\r\n        if (!qualifiedName) {\r\n            return null;\r\n        }\r\n\r\n        let simpleCategory = this.simpleCategoryMap.get(qualifiedName);\r\n        if (simpleCategory === undefined) {\r\n            // If the category doesn't exist in our map, create a default one\r\n            // This handles cases where the category might be from an external source\r\n            // or was added after the CategoryMap was initialized\r\n            console.warn(\"No SimpleCategory found for qualified name \" + qualifiedName + \". Creating a default one.\");\r\n            return {\r\n                qualifiedName: qualifiedName,\r\n                name: qualifiedName.split('.').pop() || qualifiedName, // Use the last part of the qualified name as the name\r\n                id: -1 // Use a default ID\r\n            };\r\n        }\r\n        return simpleCategory;\r\n    }\r\n\r\n}\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "start",
                        "type": "Date",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "end",
                        "type": "Date",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 237,
                "jsdoctags": [
                    {
                        "name": "start",
                        "type": "Date",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "end",
                        "type": "Date",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "end",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 237
                },
                {
                    "name": "start",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 236
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "Rule",
            "id": "class-Rule-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "field",
                        "type": "Field | Field[]",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "fieldType",
                        "type": "FieldType",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "fieldMatchType",
                        "type": "RuleMatchType",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "value",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "valueMatchType",
                        "type": "RuleMatchType",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "operator",
                        "type": "Operator",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "ruleForm",
                        "type": "FormGroup",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 349,
                "jsdoctags": [
                    {
                        "name": "field",
                        "type": "Field | Field[]",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "fieldType",
                        "type": "FieldType",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "fieldMatchType",
                        "type": "RuleMatchType",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "value",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "valueMatchType",
                        "type": "RuleMatchType",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "operator",
                        "type": "Operator",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "ruleForm",
                        "type": "FormGroup",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "_fieldObjects",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Field | Field[]",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 349,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "clazz",
                    "defaultValue": "'Rule'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 333
                },
                {
                    "name": "condition",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ConditionEnum",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 345
                },
                {
                    "name": "field",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<string>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 335
                },
                {
                    "name": "fieldMatchType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RuleMatchType",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 342
                },
                {
                    "name": "fieldType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FieldTypeEnum",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 336
                },
                {
                    "name": "isChild",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 346
                },
                {
                    "name": "operator",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RuleOperator",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 339
                },
                {
                    "name": "ruleForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 343
                },
                {
                    "name": "rules",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<RuleSetRulesInner>",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 344
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 334
                },
                {
                    "name": "value",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<string>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 337
                },
                {
                    "name": "valueMatchType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RuleMatchType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 338
                }
            ],
            "methods": [
                {
                    "name": "clone",
                    "args": [],
                    "optional": false,
                    "returnType": "Rule",
                    "typeParameters": [],
                    "line": 383,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getFieldObjects",
                    "args": [],
                    "optional": false,
                    "returnType": "Field | [] | undefined",
                    "typeParameters": [],
                    "line": 428,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "isComplete",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 397,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "isEmptyOperator",
                    "args": [
                        {
                            "name": "value",
                            "type": "RuleOperator | undefined | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 423,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "RuleOperator | undefined | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setFieldObjects",
                    "args": [
                        {
                            "name": "field",
                            "type": "Field | Field[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 433,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "Field | Field[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "ClientRule"
            ]
        },
        {
            "name": "RuleSet",
            "id": "class-RuleSet-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "condition",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "rules",
                        "type": "Array<any>",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "collapsed",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    },
                    {
                        "name": "isChild",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true
                    }
                ],
                "line": 124,
                "jsdoctags": [
                    {
                        "name": "condition",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "rules",
                        "type": "Array<any>",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "collapsed",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "isChild",
                        "type": "boolean",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "optional": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "clazz",
                    "defaultValue": "'RuleSet'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 117
                },
                {
                    "name": "collapsed",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 124
                },
                {
                    "name": "condition",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ExtendedConditionEnum",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 119
                },
                {
                    "name": "isChild",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 121
                },
                {
                    "name": "rules",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Array<RuleSetRulesInner>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 120
                },
                {
                    "name": "type",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 118
                }
            ],
            "methods": [
                {
                    "name": "clone",
                    "args": [],
                    "optional": false,
                    "returnType": "RuleSet",
                    "typeParameters": [],
                    "line": 140,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "isComplete",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 156,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "toJson",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 180,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": [],
            "implements": [
                "ClientRuleSet"
            ]
        },
        {
            "name": "RuleUtils",
            "id": "class-RuleUtils-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [],
            "methods": [
                {
                    "name": "allowMultipleFields",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 296,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "allowMultipleValues",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 303,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "fieldIsArray",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 248,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "hideValueMatchType",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 261,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isRule",
                    "args": [
                        {
                            "name": "rule",
                            "type": "RuleSetRulesInner",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Rule",
                    "typeParameters": [],
                    "line": 232,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "RuleSetRulesInner",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isRuleObject",
                    "args": [
                        {
                            "name": "o",
                            "type": "Object",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 244,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "o",
                            "type": "Object",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isRuleSet",
                    "args": [
                        {
                            "name": "rule",
                            "type": "RuleSetRulesInner",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "RuleSet",
                    "typeParameters": [],
                    "line": 236,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "RuleSetRulesInner",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isRuleSetObject",
                    "args": [
                        {
                            "name": "o",
                            "type": "Object",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 240,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "o",
                            "type": "Object",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isValid",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 275,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "serializeRuleSet",
                    "args": [
                        {
                            "name": "ruleSet",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 310,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "ruleSet",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "valueIsArray",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 252,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        126
                    ],
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        },
        {
            "name": "StringOperators",
            "id": "class-StringOperators-b79eddb1fab1f9c7d29f657f79ae79b1690fd50830f052d4f970dcc8829234f5fc7a991562d66cb9d17b43990f915916a948077a9dd348d70eea290da22fc3de",
            "file": "src/app/query-builder/query-builder.interfaces.ts",
            "deprecated": false,
            "deprecationMessage": "",
            "type": "class",
            "sourceCode": "import {FormGroup} from \"@angular/forms\";\r\n\r\nimport {CategoryType} from \"../model\";\r\nimport {\r\n  RuleMatchType,\r\n  Rule as ClientRule,\r\n  RuleOperator,\r\n  RuleSet as ClientRuleSet,\r\n  RuleSetRulesInner as ClientRuleSetRulesInner,\r\n  RuleSetWrapper as ClientRuleSetWrapper,\r\n  FieldTypeEnum,\r\n  ConditionEnum,\r\n  TypeEnum,\r\n  SimpleCategory,\r\n  SimpleUser\r\n} from \"@daanvdn/budget-assistant-client\";\r\n\r\n// Extended type to ensure all required properties exist on both Rule and RuleSet\r\n// Using any as a temporary solution to get the code to compile\r\nexport type RuleSetRulesInner = any;\r\n\r\n\r\n// Using FieldTypeEnum from @daanvdn/budget-assistant-client\r\n// export type FieldType = 'string' | 'number' | 'categorical' | 'null';\r\nexport type FieldType = FieldTypeEnum | 'null';\r\n\r\n// Extended type to ensure string is a valid value for ConditionEnum\r\nexport type ExtendedConditionEnum = ConditionEnum;\r\n\r\n// Define MatchType for compatibility with RuleMatchType\r\nexport type MatchType = RuleMatchType;\r\n\r\n\r\nexport function objectsAreEqual(obj1: any, obj2: any): boolean {\r\n  // Get the keys\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n\r\n  // If number of keys is different,\r\n  // then objects are not equal\r\n  if (keys1.length !== keys2.length) {\r\n    return false;\r\n  }\r\n\r\n  // Iterate over keys\r\n  for (const key of keys1) {\r\n    const val1 = obj1[key];\r\n    const val2 = obj2[key];\r\n    const areObjects = isObject(val1) && isObject(val2);\r\n    if ((areObjects && !objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isObject(object: any): boolean {\r\n  return object != null && typeof object === 'object';\r\n}\r\n\r\n// Using RuleOperator from @daanvdn/budget-assistant-client\r\nexport class Operator implements RuleOperator {\r\n  readonly name: string;\r\n  readonly value: string;\r\n  readonly type: string;\r\n\r\n  constructor(name: string, value: string, fieldType: FieldType) {\r\n    this.value = value;\r\n    this.type = fieldType;\r\n    this.name = name;\r\n  }\r\n\r\n  equals(operator: Operator): boolean {\r\n    return this.value === operator.value && this.type === operator.type && this.name === operator.name;\r\n  }\r\n  public asOperator():  RuleOperator {\r\n   return this;\r\n}\r\n}\r\n\r\n\r\nexport class StringOperators {\r\n\r\n  static CONTAINS = new Operator('contains', 'contains', 'string');\r\n  static EXACT_MATCH = new Operator('exact match', 'exact match', 'string');\r\n  static FUZZY_MATCH = new Operator('fuzzy match', 'fuzzy match', 'string');\r\n  static ALL: Operator[] = [StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH];\r\n}\r\n\r\nexport class CategoricalOperators {\r\n  static IN = new Operator('in', 'in', 'categorical');\r\n  static NOT_IN = new Operator('not in', 'not in', 'categorical');\r\n  static EQUALS = new Operator('equals', 'equals', 'categorical');\r\n  static ALL: Operator[] = [CategoricalOperators.IN, CategoricalOperators.NOT_IN, CategoricalOperators.EQUALS];\r\n}\r\n\r\nexport class NumericalOperators {\r\n  static EQUALS = new Operator('equals', '=', 'number');\r\n  static NOT_EQUALS = new Operator('not equals', '!=', 'number');\r\n  static GREATER_THAN = new Operator('greater than', '>', 'number');\r\n  static GREATER_THAN_OR_EQUALS = new Operator('greater than or equals', '>=', 'number');\r\n  static LESS_THAN = new Operator('less than', '<', 'number');\r\n  static LESS_THAN_OR_EQUALS = new Operator('less than or equals', '<=', 'number');\r\n  static ALL: Operator[] = [NumericalOperators.EQUALS, NumericalOperators.NOT_EQUALS, NumericalOperators.GREATER_THAN, NumericalOperators.GREATER_THAN_OR_EQUALS, NumericalOperators.LESS_THAN, NumericalOperators.LESS_THAN_OR_EQUALS];\r\n}\r\n\r\n\r\nfunction isEmptyString(value: string | undefined | null): boolean {\r\n  return !value || value === 'null' || value === 'undefined' || value.trim().length === 0;\r\n\r\n}\r\n\r\n\r\n// Using ClientRuleSet from @daanvdn/budget-assistant-client\r\nexport class RuleSet implements ClientRuleSet {\r\n  clazz: string = 'RuleSet';\r\n  type: any; // Required by ClientRuleSet\r\n  condition: ExtendedConditionEnum;\r\n  rules: Array<RuleSetRulesInner> = [];\r\n  isChild: boolean = false;\r\n\r\n  // Additional properties not in ClientRuleSet\r\n  collapsed?: boolean;\r\n\r\n  constructor(condition: string, rules: Array<any>, collapsed?: boolean, isChild?: boolean) {\r\n    this.clazz = 'RuleSet';\r\n    this.type = 'RuleSet'; // Required by ClientRuleSet\r\n    this.condition = condition as ConditionEnum;\r\n\r\n    // Convert rules to RuleSetRulesInner array\r\n    if (rules) {\r\n      this.rules = rules as Array<RuleSetRulesInner>;\r\n    }\r\n\r\n    this.collapsed = collapsed;\r\n    this.isChild = isChild ?? false;\r\n  }\r\n\r\n  public clone(): RuleSet {\r\n    let clone: RuleSet = {...this};\r\n    delete clone.collapsed;\r\n    clone.isChild = false;\r\n\r\n    clone.rules = clone.rules.map((rule: any) => {\r\n      if (rule instanceof RuleSet) {\r\n        return rule.clone();\r\n      } else if (rule instanceof Rule) {\r\n        return rule.clone();\r\n      }\r\n      return rule;\r\n    });\r\n    return clone;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (isEmptyString(this.condition)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.rules.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    for (const item of this.rules) {\r\n      if ((item as any) instanceof RuleSet) {\r\n        if (!(item as RuleSet).isComplete()) {\r\n          return false;\r\n        }\r\n      } else if ((item as any) instanceof Rule) {\r\n        if (!(item as Rule).isComplete()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public toJson(): string {\r\n    if (!this.isComplete()) {\r\n      throw new Error('RuleSet is not complete');\r\n    }\r\n\r\n    let clone: RuleSet = this.clone();\r\n\r\n    /*\r\n        // Post-process the serialized JSON to remove properties that are undefined\r\n        return JSON.parse(JSON.stringify(json, (key, value) => value === undefined ? undefined : value));\r\n    */\r\n\r\n    let mapper = (key: string, value: any) => {\r\n      if (key === 'field' && value instanceof Field) {\r\n        return (value as Field).pathFromTransaction;\r\n      }\r\n      if (key === 'field' && value instanceof Array) {\r\n        return value.map((f: Field) => (f as Field).pathFromTransaction);\r\n      }\r\n      if (value && typeof value === 'object' && 'name' in value && 'value' in value) {\r\n        return value.name;\r\n      }\r\n\r\n      return value;\r\n    }\r\n\r\n    return JSON.stringify(clone, mapper);\r\n  }\r\n}\r\n\r\n\r\n// Using ClientRuleSetWrapper from @daanvdn/budget-assistant-client\r\nexport interface RuleSetWrapper extends ClientRuleSetWrapper {\r\n  // Additional properties not in ClientRuleSetWrapper\r\n  categoryType: TypeEnum;\r\n}\r\n\r\n// export type RuleMatchType = 'any of' | 'all of';\r\n\r\n\r\n\r\n\r\nexport class MatchTypes {\r\n  static ANY_OF: RuleMatchType = {name: 'any of', value:'any of'};\r\n  static ALL_OF = {name: 'all of', value: 'all of'};\r\n  static ALL: RuleMatchType[] = [MatchTypes.ANY_OF, MatchTypes.ALL_OF];\r\n}\r\n\r\nexport const MATCH_TYPES: RuleMatchType[] = MatchTypes.ALL;\r\n\r\nexport class RuleUtils {\r\n\r\n  static isRule(rule: RuleSetRulesInner): rule is Rule {\r\n    return rule.clazz === 'Rule';\r\n  }\r\n\r\n  static isRuleSet(rule: RuleSetRulesInner): rule is RuleSet {\r\n    return rule.clazz === 'RuleSet';\r\n  }\r\n\r\n  static isRuleSetObject(o: Object): boolean {\r\n    return o.hasOwnProperty('condition') && o.hasOwnProperty('rules');\r\n  }\r\n\r\n  static isRuleObject(o: Object): boolean {\r\n    return o.hasOwnProperty('field') && o.hasOwnProperty('operator') && o.hasOwnProperty('value');\r\n  }\r\n\r\n  static fieldIsArray(rule: Rule): boolean {\r\n    return Array.isArray(rule.field);\r\n  }\r\n\r\n  static valueIsArray(rule: Rule): boolean {\r\n    if (rule.value) {\r\n      return Array.isArray(rule.value);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  static hideValueMatchType(rule: Rule): boolean {\r\n    if (rule.fieldType !== undefined && (rule.fieldType as string === 'null')) {\r\n      return true;\r\n    }\r\n    if (rule.fieldType !== undefined && rule.fieldType === 'categorical') {\r\n      if (rule.operator !== undefined && rule.operator === CategoricalOperators.EQUALS) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  static isValid(rule: Rule): boolean {\r\n    if (rule === undefined || rule === null) {\r\n      return false;\r\n    }\r\n\r\n    function isUndefinedOrEmpty(value: any): boolean {\r\n      return value === undefined || value === null || (Array.isArray(\r\n        value) && (value as Array<any>).length == 0) || value === '';\r\n    }\r\n\r\n    if (isUndefinedOrEmpty(rule.fieldType)) {\r\n      return false;\r\n    }\r\n    if (rule.fieldType === 'string') {\r\n      return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.fieldMatchType) || isUndefinedOrEmpty(\r\n        rule.operator) || isUndefinedOrEmpty(rule.valueMatchType) || isUndefinedOrEmpty(rule.value));\r\n\r\n    }\r\n    return !(isUndefinedOrEmpty(rule.field) || isUndefinedOrEmpty(rule.operator) || isUndefinedOrEmpty(rule.value));\r\n  }\r\n\r\n  static allowMultipleFields(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static allowMultipleValues(rule: Rule): boolean {\r\n    if (rule.fieldType && rule.fieldType === 'string') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static serializeRuleSet(ruleSet: RuleSet): string {\r\n    const cache = new Set();\r\n    const jsonString = JSON.stringify(ruleSet, (key, value) => {\r\n      if (typeof value === 'object' && value !== null) {\r\n        if (cache.has(value)) {\r\n          // Circular reference found, discard key\r\n          return;\r\n        }\r\n        // Store value in our set\r\n        cache.add(value);\r\n      }\r\n      return value;\r\n    });\r\n    cache.clear(); // Clear the cache\r\n    return jsonString;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// Using ClientRule from @daanvdn/budget-assistant-client\r\nexport class Rule implements ClientRule {\r\n  clazz: string = 'Rule';\r\n  type: any; // Required by ClientRule\r\n  field: Array<string> = [];\r\n  fieldType: FieldTypeEnum;\r\n  value: Array<string> = [];\r\n  valueMatchType: RuleMatchType;\r\n  operator: RuleOperator;\r\n\r\n  // Additional properties not in ClientRule\r\n  fieldMatchType?: RuleMatchType;\r\n  ruleForm?: FormGroup;\r\n  rules?: Array<RuleSetRulesInner>;\r\n  condition?: ConditionEnum;\r\n  isChild?: boolean;\r\n\r\n  // Internal properties to store Field objects\r\n  private _fieldObjects?: Field | Field[];\r\n\r\n  constructor(field?: Field | Field[], fieldType?: FieldType, fieldMatchType?: RuleMatchType, value?: any,\r\n              valueMatchType?: RuleMatchType, operator?: Operator, ruleForm?: FormGroup) {\r\n    this.clazz = 'Rule';\r\n    this.type = 'Rule'; // Required by ClientRule\r\n    this._fieldObjects = field;\r\n\r\n    // Convert Field objects to string array for ClientRule\r\n    if (field) {\r\n      if (field instanceof Array) {\r\n        this.field = field.map(f => (f as Field).pathFromTransaction);\r\n      } else {\r\n        this.field = [(field as Field).pathFromTransaction];\r\n      }\r\n    }\r\n\r\n    this.fieldType = fieldType as FieldTypeEnum;\r\n    this.fieldMatchType = fieldMatchType;\r\n\r\n    // Convert value to string array for ClientRule\r\n    if (value) {\r\n      if (value instanceof Array) {\r\n        this.value = value.map(v => String(v));\r\n      } else {\r\n        this.value = [String(value)];\r\n      }\r\n    }\r\n\r\n    this.valueMatchType = valueMatchType as RuleMatchType;\r\n    this.operator = operator as RuleOperator;\r\n    this.ruleForm = ruleForm;\r\n  }\r\n\r\n  clone(): Rule {\r\n    let rule: Rule = {...this};\r\n    delete rule.ruleForm;\r\n\r\n    if (this._fieldObjects) {\r\n      if (this._fieldObjects instanceof Array) {\r\n        rule._fieldObjects = this._fieldObjects.map((f: Field) => f.clone());\r\n      } else if (this._fieldObjects instanceof Field) {\r\n        rule._fieldObjects = this._fieldObjects.clone();\r\n      }\r\n    }\r\n    return rule;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    if (!this.field || this.field.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (isEmptyString(this.fieldType)) {\r\n      return false;\r\n    }\r\n\r\n    if (this.isEmptyOperator(this.operator)) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.value || this.value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    if (this.valueMatchType == undefined) {\r\n      return false;\r\n    }\r\n    if (this.fieldMatchType == undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private isEmptyOperator(value: RuleOperator | undefined | null): boolean {\r\n    return value === undefined || value === null;\r\n  }\r\n\r\n  // Getter for field objects\r\n  getFieldObjects(): Field | Field[] | undefined {\r\n    return this._fieldObjects;\r\n  }\r\n\r\n  // Setter for field objects\r\n  setFieldObjects(field: Field | Field[]): void {\r\n    this._fieldObjects = field;\r\n    if (field instanceof Array) {\r\n      this.field = field.map(f => (f as Field).pathFromTransaction);\r\n    } else {\r\n      this.field = [(field as Field).pathFromTransaction];\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Option {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\nexport interface FieldMap {\r\n  [key: string]: Field;\r\n}\r\n\r\n\r\nexport class Field {\r\n\r\n  name: string;\r\n  pathFromTransaction: string;\r\n  value?: string;\r\n  type: string;\r\n  nullable?: boolean;\r\n\r\n  options?: Option[];\r\n  operators?: Operator[];\r\n\r\n\r\n  constructor(name: string, pathFromTransaction: string, type: string, value?: string, nullable?: boolean,\r\n              options?: Option[], operators?: Operator[]) {\r\n    this.name = name;\r\n    this.pathFromTransaction = pathFromTransaction;\r\n    this.value = value;\r\n    this.type = type;\r\n    this.nullable = nullable;\r\n    this.options = options;\r\n    this.operators = operators;\r\n  }\r\n\r\n  clone(): Field {\r\n\r\n    let clone: Field = {...this};\r\n    delete clone.nullable;\r\n    delete clone.value;\r\n    delete clone.options;\r\n    delete clone.operators;\r\n\r\n    return clone;\r\n\r\n  }\r\n\r\n\r\n  equals(field: Field): boolean {\r\n    return this.name === field.name && this.type === field.type && this.value === field.value && this.nullable === field.nullable && this.options === field.options && this.operators === field.operators;\r\n  }\r\n}\r\n\r\nexport class MultiMap<K, V> {\r\n  private map = new Map<K, V[]>();\r\n\r\n  set(key: K, value: V): void {\r\n    let values = this.map.get(key);\r\n    if (values) {\r\n      values.push(value);\r\n    } else {\r\n      this.map.set(key, [value]);\r\n    }\r\n  }\r\n\r\n  get(key: K): V[] | undefined {\r\n    return this.map.get(key);\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.map.has(key);\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.map.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.map.clear();\r\n  }\r\n\r\n  keys(): K[] {\r\n    return Array.from(this.map.keys());\r\n  }\r\n}\r\n\r\n\r\nexport interface LocalRuleMeta {\r\n  ruleset: boolean;\r\n  invalid: boolean;\r\n}\r\n\r\nexport interface QueryBuilderClassNames {\r\n  arrowIconButton?: string;\r\n  arrowIcon?: string;\r\n  removeIcon?: string;\r\n  addIcon?: string;\r\n  button?: string;\r\n  buttonGroup?: string;\r\n  removeButton?: string;\r\n  removeButtonSize?: string;\r\n  switchRow?: string;\r\n  switchGroup?: string;\r\n  switchLabel?: string;\r\n  switchRadio?: string;\r\n  switchControl?: string;\r\n  rightAlign?: string;\r\n  transition?: string;\r\n  collapsed?: string;\r\n  treeContainer?: string;\r\n  tree?: string;\r\n  row?: string;\r\n  connector?: string;\r\n  rule?: string;\r\n  ruleSet?: string;\r\n  invalidRuleSet?: string;\r\n  emptyWarning?: string;\r\n  fieldControl?: string;\r\n  fieldControlSize?: string;\r\n  operatorControl?: string;\r\n  operatorControlSize?: string;\r\n  inputControl?: string;\r\n  inputControlSize?: string;\r\n}\r\n\r\nexport interface QueryBuilderConfig {\r\n  fields: FieldMap;\r\n  allowEmptyRulesets?: boolean;\r\n\r\n\r\n}\r\n\r\nexport const DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig = {\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}\r\n\r\nfunction createFieldByNameMap(queryBuilderConfig: QueryBuilderConfig): Map<string, Field> {\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(queryBuilderConfig.fields)) {\r\n    map.set(value.name, value);\r\n  }\r\n  return map;\r\n\r\n}\r\n\r\nexport const FIELDS_BY_NAME_MAP: Map<string, Field> = createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG: QueryBuilderConfig): Map<string, Field> {\r\n\r\n  let map = new Map<string, Field>();\r\n  for (let [key, value] of Object.entries(DEFAULT_QUERY_BUILDER_CONFIG.fields)) {\r\n    map.set(value.pathFromTransaction, value);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const FIELDS_BY_PATH_FROM_TRANSACTION_MAP: Map<string, Field> = createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG);\r\n\r\nfunction createMatchTypesByNameMap(MATCH_TYPES: RuleMatchType[]): Map<string, RuleMatchType> {\r\n  let map = new Map<string, RuleMatchType>();\r\n  for (let matchType of MATCH_TYPES) {\r\n    map.set(matchType.name, matchType);\r\n  }\r\n  return map;\r\n}\r\n\r\nexport const MATCH_TYPES_BY_NAME_MAP: Map<string, RuleMatchType> = createMatchTypesByNameMap(MATCH_TYPES);\r\n\r\n\r\nfunction ruleSetReviverFn0(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value.clazz === 'RuleSet') {\r\n      return new RuleSet(value.condition, value.rules.map(ruleSetReviverFn0), value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n      let field;\r\n      if (Array.isArray(value.field)) {\r\n\r\n        field = value.field.map((f: string) => FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f));\r\n      } else if (value.field) {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      return new Rule(field, value.fieldType, value.fieldMatchType, value.value, value.valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction ruleSetReviverFn(key: string, value: any) {\r\n  if (value && typeof value === 'object' && 'clazz' in value) {\r\n    if (value instanceof RuleSet) {\r\n      return value;\r\n    } else if (value instanceof Rule) {\r\n      return value;\r\n    }\r\n    if (value.clazz === 'RuleSet') {\r\n      let rules: Array<RuleSet | Rule> = [];\r\n      if (Array.isArray(value.rules)) {\r\n        rules = value.rules.map((ruleOrRuleSet: any) => {\r\n          if (ruleOrRuleSet.clazz === 'RuleSet') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          } else if (ruleOrRuleSet.clazz === 'Rule') {\r\n            return ruleSetReviverFn('', ruleOrRuleSet);\r\n          }\r\n          return ruleOrRuleSet;\r\n        });\r\n      }\r\n\r\n      return new RuleSet(value.condition, rules, value.collapsed, value.isChild);\r\n    } else if (value.clazz === 'Rule') {\r\n      // Revive the Operator object\r\n      let operator = value.operator ? new Operator(value.operator.name, value.operator.value,\r\n        value.operator.type) : undefined;\r\n\r\n      // Revive the Field object(s)\r\n\r\n      function allItemsAreStrings(arr: any[]): boolean {\r\n        return arr.every((item: any) => typeof item === 'string');\r\n      }\r\n\r\n      let field;\r\n      if (Array.isArray(value.field) && allItemsAreStrings(value.field)) {\r\n        field = value.field.map((f: string) => {\r\n          if (!FIELDS_BY_PATH_FROM_TRANSACTION_MAP.has(f)) {\r\n            throw new Error(`Field ${f} not found in FIELDS_BY_PATH_FROM_TRANSACTION_MAP`);\r\n          }\r\n          return FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(f);\r\n        });\r\n      } else if (value.field && typeof value.field === 'string') {\r\n        field = FIELDS_BY_PATH_FROM_TRANSACTION_MAP.get(value.field);\r\n      }\r\n\r\n      //revive the fieldMatchType\r\n      let fieldMatchType;\r\n      if (value.fieldMatchType && typeof value.fieldMatchType === 'string') {\r\n        fieldMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid fieldMatchType');\r\n      }\r\n\r\n      let valueMatchType;\r\n      if (value.valueMatchType && typeof value.valueMatchType === 'string') {\r\n        valueMatchType = MATCH_TYPES_BY_NAME_MAP.get(value.fieldMatchType);\r\n      } else {\r\n        throw new Error('Invalid valueMatchType');\r\n      }\r\n\r\n\r\n      return new Rule(field, value.fieldType, fieldMatchType, value.value, valueMatchType, operator);\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n\r\nfunction operatorReviverFn(key: string, value: any): Operator {\r\n  if (value && typeof value === 'object' && 'type' in value) {\r\n    return new Operator(value.name, value.value, value.type);\r\n  }\r\n  return value;\r\n\r\n}\r\n\r\n\r\nfunction isValidRuleSetObject(obj: any): boolean {\r\n  // Check if the object has the necessary properties\r\n  if (!obj || !(obj instanceof RuleSet) || obj.clazz !== 'RuleSet' || !Array.isArray(obj.rules)) {\r\n    return false;\r\n  }\r\n\r\n  // Check if each rule is a valid RuleSet or Rule object\r\n  for (const rule of obj.rules) {\r\n    if (rule instanceof RuleSet) {\r\n      // If the rule is a RuleSet, check it recursively\r\n      if (!isValidRuleSetObject(rule)) {\r\n        return false;\r\n      }\r\n    } else if (rule instanceof Rule) {\r\n      // If the rule is a Rule, check if it has the necessary properties\r\n\r\n      if (!rule.field) {\r\n        return false;\r\n      } else if (Array.isArray(rule.field)) {\r\n        if (!rule.field.every(f => typeof f === 'object' && f !== null && 'pathFromTransaction' in f)) {\r\n          return false;\r\n        }\r\n\r\n\r\n      } else {\r\n        if (!(typeof rule.field === 'object' && rule.field !== null && 'pathFromTransaction' in rule.field)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.operator) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.operator instanceof Operator)) {\r\n          return false;\r\n        }\r\n      }\r\n      if (!rule.value) {\r\n        return false;\r\n      }\r\n      if (!rule.fieldMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.fieldMatchType && typeof rule.fieldMatchType === 'object' && 'name' in rule.fieldMatchType && 'value' in rule.fieldMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      if (!rule.valueMatchType) {\r\n        return false;\r\n      } else {\r\n        if (!(rule.valueMatchType && typeof rule.valueMatchType === 'object' && 'name' in rule.valueMatchType && 'value' in rule.valueMatchType)) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      // If the rule is neither a RuleSet nor a Rule, return false\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // If all checks passed, return true\r\n  return true;\r\n}\r\n\r\nexport function deserializeRuleSet(jsonString: string): RuleSet {\r\n  let ruleSet = JSON.parse(jsonString, ruleSetReviverFn);\r\n  if (!isValidRuleSetObject(ruleSet)) {\r\n    throw new Error('Invalid RuleSet object');\r\n\r\n  }\r\n  return ruleSet;\r\n}\r\n\r\n\r\nexport class Comparator {\r\n\r\n\r\n  private isUndefinedOrNull(o: any): boolean {\r\n    return o === undefined || o === null;\r\n  }\r\n\r\n\r\n  public equals(o1: any, o2: any): boolean {\r\n    if (this.isUndefinedOrNull(o1) && this.isUndefinedOrNull(o2)) {\r\n      return true;\r\n    }\r\n    if (this.bothAreArrays(o1, o2)) {\r\n      return this.checkArraysAreEqual(o1, o2);\r\n    }\r\n    if (this.isObject(o1) && this.isObject(o2)) {\r\n      return this.objectsAreEqual(o1, o2);\r\n    }\r\n\r\n    return o1 === o2;\r\n\r\n  }\r\n\r\n  private checkArraysAreEqual(arr1: any[], arr2: any[]): boolean {\r\n\r\n    //check if all items in o1 and o2 have the same typeof\r\n    if (arr1.length !== arr2.length) {\r\n      return false;\r\n    }\r\n    const sortedList1 = arr1.sort();\r\n    const sortedList2 = arr2.sort();\r\n    for (let i = 0; i < arr1.length; i++) {\r\n      let item1 = sortedList1[i];\r\n      let item2 = sortedList2[i];\r\n      if (typeof item1 !== typeof item2) {\r\n        throw new Error(`Unexpected type: ${typeof item1} and ${typeof item2} are not the same type`);\r\n      }\r\n\r\n      if(isObject(item1) && isObject(item2)){\r\n        if(!objectsAreEqual(item1, item2)){\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private bothAreArrays(o1: any, o2: any): boolean {\r\n    return Array.isArray(o1) && Array.isArray(o2);\r\n  }\r\n\r\n  private isObject(object: any): boolean {\r\n    return object != null && typeof object === 'object';\r\n  }\r\n\r\n  private objectsAreEqual(obj1: any, obj2: any): boolean {\r\n    // Get the keys\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n\r\n    // If number of keys is different,\r\n    // then objects are not equal\r\n    if (keys1.length !== keys2.length) {\r\n      return false;\r\n    }\r\n\r\n    // Iterate over keys\r\n    for (const key of keys1) {\r\n      const val1 = obj1[key];\r\n      const val2 = obj2[key];\r\n      const areObjects = isObject(val1) && isObject(val2);\r\n      if ((areObjects && !this.objectsAreEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// Conversion functions to convert between the project's interfaces and the interfaces from @daanvdn/budget-assistant-client\r\n\r\n/**\r\n * Converts a Rule to a ClientRule\r\n */\r\nexport function convertRuleToClientRule(rule: Rule, type: TypeEnum = TypeEnum.BOTH): ClientRule {\r\n  return {\r\n    clazz: rule.clazz,\r\n    type: type,\r\n    field: rule.field,\r\n    fieldType: rule.fieldType as FieldTypeEnum,\r\n    value: rule.value instanceof Array \r\n      ? rule.value.map(v => String(v)) \r\n      : [String(rule.value)],\r\n    valueMatchType: rule.valueMatchType as RuleMatchType,\r\n    operator: rule.operator as RuleOperator\r\n  };\r\n}\r\n\r\n/**\r\n * Converts a RuleSet to a ClientRuleSet\r\n */\r\n/*\r\nexport function convertRuleSetToClientRuleSet(ruleSet: RuleSet, type: TypeEnum = TypeEnum.BOTH): ClientRuleSet {\r\n  return {\r\n    clazz: ruleSet.clazz,\r\n    type: type,\r\n    condition: ruleSet.condition as ConditionEnum,\r\n    rules: ruleSet.rules.map(rule => {\r\n      if (rule instanceof RuleSet) {\r\n        return convertRuleSetToClientRuleSet(rule, type);\r\n      } else {\r\n        return convertRuleToClientRule(rule as Rule, type);\r\n      }\r\n    }),\r\n    isChild: ruleSet.isChild === undefined ? false : ruleSet.isChild\r\n  };\r\n}\r\n*/\r\n\r\n/**\r\n * Converts a RuleSetWrapper to a ClientRuleSetWrapper\r\n */\r\n\r\n/**\r\n * Converts a ClientRule to a Rule\r\n */\r\nexport function convertClientRuleToRule(clientRule: ClientRule): Rule {\r\n  const rule = new Rule();\r\n  rule.clazz = clientRule.clazz;\r\n  // We can't set field directly because it's a Field object, not a string array\r\n  // rule.field = clientRule.field;\r\n  rule.fieldType = clientRule.fieldType;\r\n  rule.value = clientRule.value;\r\n  rule.valueMatchType = clientRule.valueMatchType;\r\n  rule.operator = clientRule.operator as Operator;\r\n  return rule;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSet to a RuleSet\r\n */\r\nexport function convertClientRuleSetToRuleSet(clientRuleSet: ClientRuleSet): RuleSet {\r\n  const ruleSet = new RuleSet(\r\n    clientRuleSet.condition,\r\n    [],\r\n    false,\r\n    clientRuleSet.isChild\r\n  );\r\n\r\n  ruleSet.rules = clientRuleSet.rules.map(rule => {\r\n    if (rule.clazz === 'RuleSet') {\r\n      return convertClientRuleSetToRuleSet(rule as ClientRuleSet);\r\n    } else {\r\n      return convertClientRuleToRule(rule as ClientRule);\r\n    }\r\n  });\r\n\r\n  return ruleSet;\r\n}\r\n\r\n/**\r\n * Converts a ClientRuleSetWrapper to a RuleSetWrapper\r\n */\r\n",
            "inputsClass": [],
            "outputsClass": [],
            "properties": [
                {
                    "name": "ALL",
                    "defaultValue": "[StringOperators.CONTAINS, StringOperators.EXACT_MATCH, StringOperators.FUZZY_MATCH]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Operator[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 88,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "CONTAINS",
                    "defaultValue": "new Operator('contains', 'contains', 'string')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 85,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "EXACT_MATCH",
                    "defaultValue": "new Operator('exact match', 'exact match', 'string')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 86,
                    "modifierKind": [
                        126
                    ]
                },
                {
                    "name": "FUZZY_MATCH",
                    "defaultValue": "new Operator('fuzzy match', 'fuzzy match', 'string')",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 87,
                    "modifierKind": [
                        126
                    ]
                }
            ],
            "methods": [],
            "indexSignatures": [],
            "extends": [],
            "hostBindings": [],
            "hostListeners": []
        }
    ],
    "directives": [],
    "components": [
        {
            "name": "AnalysisForPeriodByCategoryComponent",
            "id": "component-AnalysisForPeriodByCategoryComponent-22f23af21ebbd36b25dc449f65d4362f535099da61bcc7f1d48775b93e168fae84d2378f08dfdbb0ebc2f11f916aa179bb55a1b8c106184dc17ba033b33f33ce",
            "file": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "analysis-for-period-by-category",
            "styleUrls": [
                "./analysis-for-period-by-category.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./analysis-for-period-by-category.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "appService",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AppService",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "customColors",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "expensesDataPieChart",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "PieChartData[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "gradient",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "incomeDataPieChart",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "PieChartData[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "isDoughnut",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "isLoaded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 32
                },
                {
                    "name": "legendPosition",
                    "defaultValue": "LegendPosition.Below",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "LegendPosition",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "showLabels",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38
                },
                {
                    "name": "showLegend",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 37
                },
                {
                    "name": "single",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27
                },
                {
                    "name": "view",
                    "defaultValue": "[700, 400]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[number, number]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 50,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgIf"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatCard"
                },
                {
                    "name": "MatCardHeader"
                },
                {
                    "name": "MatCardContent"
                },
                {
                    "name": "PieChartModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport { LegendPosition, PieChartModule } from \"@swimlane/ngx-charts\";\nimport {DistributionByCategoryForPeriodChartData, Period} from \"../model\";\nimport { NgIf, NgFor } from '@angular/common';\nimport { MatCard, MatCardHeader, MatCardContent } from '@angular/material/card';\n\n\n\n@Component({\n    selector: 'analysis-for-period-by-category',\n    templateUrl: './analysis-for-period-by-category.component.html',\n    styleUrls: ['./analysis-for-period-by-category.component.scss'],\n    standalone: true,\n    imports: [\n        NgIf,\n        NgFor,\n        MatCard,\n        MatCardHeader,\n        MatCardContent,\n        PieChartModule,\n    ],\n})\nexport class AnalysisForPeriodByCategoryComponent implements OnInit {\n\n  //data\n  single: any[] = [];\n  public incomeDataPieChart: PieChartData[] = [];\n  public expensesDataPieChart: PieChartData[] = [];\n\n  //\n  isLoaded: boolean = false;\n\n  // options\n  view: [number, number] = [700, 400];\n  gradient: boolean = true;\n  showLegend: boolean = false;\n  showLabels: boolean = true;\n  isDoughnut: boolean = false;\n  legendPosition: LegendPosition = LegendPosition.Below;\n\n  customColors: any[] = [];\n\n\n  constructor(public appService: AppService) {\n    this.isLoaded = false;\n  }\n\n\n  ngOnInit(): void {\n\n    let labelColors: Map<string, string> = new Map<string, string>();\n    this.appService.categoryQueryForSelectedPeriodObservable$.subscribe(query => {\n      if(!query){\n        return;\n      }\n      this.appService.getRevenueExpensesPerPeriodAndCategoryShow1MonthBeforeAndAfter(query).subscribe(result => {\n        this.expensesDataPieChart = [];\n        for (const expense of result.chartDataExpenses) {\n          this.expensesDataPieChart.push(PieChartData.fromDistributionByCategoryForPeriodChartData(expense, labelColors));\n        }\n\n        this.incomeDataPieChart = [];\n        for (const income of result.chartDataRevenue) {\n          this.incomeDataPieChart.push(PieChartData.fromDistributionByCategoryForPeriodChartData(income, labelColors))\n        }\n\n        this.isLoaded = true;\n        for (const label of labelColors.keys()) {\n          let color = labelColors.get(label);\n          this.customColors.push({\"name\": label,\"value\": color})\n        }\n\n\n      })\n    })\n  }\n\n\n\n\n}\n\nexport class PieChartData {\n  nameValuePairs: any[];\n  period: Period;\n\n\n  constructor(nameValuePairs: any[], period: Period) {\n    this.nameValuePairs = nameValuePairs;\n    this.period = period;\n  }\n\n  static fromDistributionByCategoryForPeriodChartData(obj: DistributionByCategoryForPeriodChartData, labelColors: Map<string, string>): PieChartData {\n    let arr: any[] = [];\n    obj.entries.forEach((categoryAndAmount => {\n      let result = {\n        \"name\": categoryAndAmount.category,\n        \"value\": Math.abs(categoryAndAmount.amount)\n      };\n      arr.push(result);\n      getColorForLabel(result.name, labelColors)\n\n\n    }))\n    return new PieChartData(arr, obj.period as Period);\n\n  }\n}\n\nfunction getRandomColor() {\n  return '#' + Math.floor(Math.random()*16777215).toString(16);\n}\n\n\nfunction getColorForLabel(label: string, labelColors: Map<string, string>): string {\n\n  if (!labelColors.get(label)) {\n\n    labelColors.set(label, getRandomColor());\n  }\n\n  return labelColors.get(label) as string;\n}\n\n\n\n\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".parent {\r\n  border: 1px solid black;\r\n  margin: 1rem;\r\n  padding: 2rem 2rem;\r\n  text-align: center;\r\n}\r\n.child {\r\n  display: inline-block;\r\n  border: 1px solid red;\r\n  padding: 1rem 1rem;\r\n  vertical-align: middle;\r\n}\r\n\r\n.chart-parent {\r\n  border: 1px solid black;\r\n  display: flex;        /* Display children vertically */\r\n  flex-direction: column; /* Display children vertically */\r\n  overflow-y: auto;      /* Add vertical scrollbar when content overflows */\r\n}\r\n\r\n.chart-child {\r\n  margin-bottom: 10px;   /* Add some spacing between charts */\r\n  width: 50%;\r\n}\r\n\r\n.dashboard{\r\n  //flex-wrap:wrap;\r\n  //width: 50%;\r\n  .card{\r\n    background: #FFFFFF;\r\n    padding:0;\r\n    .card-title{\r\n      display:flex;\r\n      justify-content: center; /* align horizontal */\r\n      align-items: center; /* align vertical */\r\n\r\n      .title{\r\n        font-size: 20px;\r\n        color: #262B3D;\r\n      }\r\n    }\r\n    .description{\r\n      font-size: 12px;\r\n      color: #525252;\r\n    }\r\n\r\n  }\r\n}\r\n.dashboard-card-content {\r\n  width: 100%;\r\n  height: calc(100% - 30px);\r\n  display: flex;\r\n  flex-flow: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  box-sizing: border-box;\r\n}\r\n",
                    "styleUrl": "./analysis-for-period-by-category.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 42,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<div *ngIf=\"isLoaded\">\n  <h2 class=\"text_center\">Categorieën</h2>\n  <div class=\"mat-z8\" style=\"padding-left: 25px; display: flex; \">\n    <div style=\"width: 50%; height: 50%\">\n      <div class=\"dashboard\">\n        <h3 class=\"dashboard-card-content\">Inkomsten</h3>\n        <ul class=\"card\" *ngFor=\"let item of incomeDataPieChart\">\n          <mat-card appearance=\"outlined\">\n            <mat-card-header class=\"dashboard-card-content\">{{item.period.value}}</mat-card-header>\n            <mat-card-content class=\"dashboard-card-content\">\n              <ngx-charts-pie-chart\n                [view]=\"view\"\n                [customColors]=\"customColors\"\n                [results]=\"item.nameValuePairs\"\n                [gradient]=\"gradient\"\n                [legend]=\"showLegend\"\n                [legendPosition]=\"legendPosition\"\n                [labels]=\"showLabels\"\n                [doughnut]=\"isDoughnut\"\n                [trimLabels]=false\n                [animations]=true\n              ></ngx-charts-pie-chart>\n              <ngx-charts-pie-chart\n\n              ></ngx-charts-pie-chart>\n            </mat-card-content>\n          </mat-card>\n\n        </ul>\n      </div>\n    </div>\n    <div style=\"width: 50%; height: 50%\">\n      <div class=\"dashboard\">\n        <h3 class=\"dashboard-card-content\">Uitgaven</h3>\n        <ul class=\"card\" *ngFor=\"let item of expensesDataPieChart\">\n          <mat-card appearance=\"outlined\">\n            <mat-card-header class=\"dashboard-card-content\">{{item.period.value}}</mat-card-header>\n            <mat-card-content class=\"dashboard-card-content\">\n              <ngx-charts-pie-chart\n                [view]=\"view\"\n                [customColors]=\"customColors\"\n                [results]=\"item.nameValuePairs\"\n                [gradient]=\"gradient\"\n                [legend]=\"showLegend\"\n                [legendPosition]=\"legendPosition\"\n                [labels]=\"showLabels\"\n                [doughnut]=\"isDoughnut\"\n                [trimLabels]=false\n                [animations]=true\n              ></ngx-charts-pie-chart>\n            </mat-card-content>\n          </mat-card>\n\n        </ul>\n      </div>\n    </div>\n\n  </div>\n</div>\n\n"
        },
        {
            "name": "AppComponent",
            "id": "component-AppComponent-2650f8c40fd04ac648ea3a41f0b42688da1d65da3c3e7cd2c8b5033fe75b4a91b3a729f074a9d00783753fc6c35a7d44458fc9431dbd57d49039f88a212f62c1",
            "file": "src/app/app.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-root",
            "styleUrls": [
                "./app.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./app.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "title",
                    "defaultValue": "'BudgetAssistant'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                }
            ],
            "methodsClass": [
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 30,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "RouterOutlet"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {AfterViewInit, Component} from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.scss'],\n    standalone: true,\n    imports: [RouterOutlet],\n})\nexport class AppComponent implements AfterViewInit {\n\n  title:string = 'BudgetAssistant';\n\n\n\n\n\n\n  constructor() {\n\n\n  }\n\n\n\n\n\n  public ngAfterViewInit(): void {\n\n\n\n\n\n\n  }\n\n\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "\r\n  body {\r\n    font-family: Roboto, \"Helvetica Neue\", sans-serif;\r\n    margin: 0;\r\n    padding: 30px;\r\n  }\r\n\r\n  html, body {\r\n    height: 100%;\r\n  }\r\n",
                    "styleUrl": "./app.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 14
            },
            "extends": [],
            "implements": [
                "AfterViewInit"
            ],
            "templateData": "<router-outlet></router-outlet>\r\n"
        },
        {
            "name": "BankAccountCheckBoxesComponent",
            "id": "component-BankAccountCheckBoxesComponent-5d1177f29bfa53b71d51abd3522d2000e5293cddadbcfa38a4cbfab81070c047d94fe7dedfcba585b7d61daa2d11038af5bcb3add9e23b6049a511b0f9a07d0b",
            "file": "src/app/bank-account-check-boxes/bank-account-check-boxes.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "bank-account-check-boxes",
            "styleUrls": [
                "./bank-account-check-boxes.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./bank-account-check-boxes.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "change",
                    "defaultValue": "new EventEmitter<BankAccount[]>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "EventEmitter<BankAccount[]>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "bankAccounts",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccount[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18
                },
                {
                    "name": "destroy$",
                    "defaultValue": "new Subject<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 19
                }
            ],
            "methodsClass": [
                {
                    "name": "emitSelectedAccounts",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 59,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getFormArrayControls",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 55,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 43,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 48,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatCheckbox"
                },
                {
                    "name": "UpperCasePipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, OnDestroy, OnInit, Output} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport {Subject, takeUntil} from \"rxjs\";\nimport { FormBuilder, FormGroup, FormArray, FormsModule, ReactiveFormsModule } from \"@angular/forms\";\nimport { BankAccount } from '@daanvdn/budget-assistant-client';\nimport { NgFor, UpperCasePipe } from '@angular/common';\nimport { MatCheckbox } from '@angular/material/checkbox';\n\n@Component({\n    selector: 'bank-account-check-boxes',\n    templateUrl: './bank-account-check-boxes.component.html',\n    styleUrls: ['./bank-account-check-boxes.component.scss'],\n    standalone: true,\n    imports: [FormsModule, ReactiveFormsModule, NgFor, MatCheckbox, UpperCasePipe]\n})\nexport class BankAccountCheckBoxesComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n  bankAccounts: BankAccount[] = [];\n  form: FormGroup;\n\n  @Output() change: EventEmitter<BankAccount[]> = new EventEmitter<BankAccount[]>();\n\n  constructor(private appService: AppService, private formBuilder: FormBuilder) {\n    this.form = this.formBuilder.group({\n      bankAccounts: new FormArray([])\n    });\n\n    this.appService.fetchBankAccountsForUser()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(result => {\n        if (result == undefined) {\n          return;\n        }\n        this.bankAccounts = result;\n        const bankAccountsFormArray = this.form.get('bankAccounts') as FormArray;\n        this.bankAccounts.forEach(() => {\n          bankAccountsFormArray.push(this.formBuilder.control(true));\n        });\n      });\n\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n  ngOnInit(): void {\n    const bankAccountsFormArray = this.form.get('bankAccounts') as FormArray;\n    bankAccountsFormArray.valueChanges.subscribe(() => {\n      this.emitSelectedAccounts();\n    });\n  }\n\n  getFormArrayControls() {\n    return (this.form.get('bankAccounts') as FormArray).controls;\n  }\n\n  emitSelectedAccounts() {\n    const formArrayControls = this.getFormArrayControls();\n    let selectedBankAccounts: BankAccount[] = [];\n\n    this.bankAccounts.forEach((bankAccount, index) => {\n      let selected: boolean = formArrayControls[index].value;\n      if (selected){\n        selectedBankAccounts.push(bankAccount);\n      }\n      });\n\n    this.change.emit(selectedBankAccounts);\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./bank-account-check-boxes.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 21,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "OnDestroy"
            ],
            "templateData": "<form [formGroup]=\"form\">\n  <div formArrayName=\"bankAccounts\" *ngFor=\"let bankAccount of bankAccounts; let i = index\">\n    <mat-checkbox [formControlName]=\"i\" >\n      {{ bankAccount.accountNumber | uppercase }}\n    </mat-checkbox>\n  </div>\n</form>\n"
        },
        {
            "name": "BankAccountSelectionComponent",
            "id": "component-BankAccountSelectionComponent-9ed1ca1ae2dc5842617d95f4272bb9de161eee984e61805470f78e69c190e4ccfdb1ed6da443deea256b114835330068770b51a93e277716d23bbc103ae18ae0",
            "file": "src/app/bank-account-selection/bank-account-selection.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "bank-account-selection",
            "styleUrls": [
                "./bank-account-selection.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./bank-account-selection.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "change",
                    "defaultValue": "new EventEmitter<BankAccount>(true)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 27,
                    "type": "EventEmitter<BankAccount>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "bankAccountFormFieldGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "bankAccounts",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccount[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25
                },
                {
                    "name": "destroy$",
                    "defaultValue": "new Subject<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "selectedBankAccount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccount",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnChanges",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 52,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 57,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 49,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatLabel"
                },
                {
                    "name": "MatSelect"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatOption"
                },
                {
                    "name": "UpperCasePipe",
                    "type": "pipe"
                },
                {
                    "name": "IbanPipe",
                    "type": "pipe"
                },
                {
                    "name": "MatIconModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, OnDestroy, OnInit, Output} from '@angular/core';\nimport { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport {AppService} from '../app.service';\nimport {Subject, takeUntil} from \"rxjs\";\nimport {BankAccount} from \"@daanvdn/budget-assistant-client\";\nimport { MatFormField, MatLabel } from '@angular/material/form-field';\nimport { MatSelect } from '@angular/material/select';\nimport { NgFor, UpperCasePipe } from '@angular/common';\nimport { MatOption } from '@angular/material/core';\nimport { IbanPipe } from '../iban.pipe';\nimport {MatIconModule} from \"@angular/material/icon\";\n\n@Component({\n    selector: 'bank-account-selection',\n    templateUrl: './bank-account-selection.component.html',\n    styleUrls: ['./bank-account-selection.component.scss'],\n    standalone: true,\n    imports: [FormsModule, ReactiveFormsModule, MatFormField, MatLabel, MatSelect, NgFor, MatOption, UpperCasePipe, IbanPipe, MatIconModule]\n})\nexport class BankAccountSelectionComponent implements OnInit, OnDestroy {\n\n\n  bankAccountFormFieldGroup: FormGroup;\n  selectedBankAccount!: BankAccount;\n  bankAccounts: BankAccount[] = [];\n\n  @Output() change: EventEmitter<BankAccount> = new EventEmitter<BankAccount>(true);\n  private destroy$ = new Subject<void>();\n\n  constructor(private appService: AppService, private formBuilder: FormBuilder) {\n    this.appService.fetchBankAccountsForUser()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(result => {\n        if (result == undefined) {\n          return;\n        }\n        this.bankAccounts = result\n        this.selectedBankAccount = this.bankAccounts[0];\n        this.appService.setBankAccount(this.selectedBankAccount);\n        this.change.emit(this.selectedBankAccount);\n        return this.bankAccounts;\n\n      }\n    )\n    this.bankAccountFormFieldGroup = formBuilder.group({queryForm: \"\"});\n  }\n\n\n  ngOnInit() {\n  }\n\n  ngOnChanges() {\n    this.change.emit(this.selectedBankAccount);\n    this.appService.setBankAccount(this.selectedBankAccount);\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".wrapper {\r\n    border: 1px solid gray;\r\n}\r\n.inline_block {\r\n    display: inline-block;\r\n    padding: 2px;\r\n    //min-width:350px\r\n    /* width:120px;\r\n    height:120px;\r\n    border: 1px solid red; */\r\n}\r\n",
                    "styleUrl": "./bank-account-selection.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 28,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "OnDestroy"
            ],
            "templateData": "<div [formGroup]=\"bankAccountFormFieldGroup\" class=\"inline_block\" style=\"width: fit-content\">\n  <mat-form-field appearance=\"fill\" >\n    <mat-label>Selecteer rekening</mat-label>\n    <mat-select placeholder=\"Rekening\" name=\"rekening\" [(value)]=\"selectedBankAccount\" (selectionChange)=\"ngOnChanges()\">\n      <mat-option *ngFor=\"let bankAccount of bankAccounts\" [value]=\"bankAccount\">\n        {{bankAccount.accountNumber | uppercase | iban}}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</div>\n"
        },
        {
            "name": "BooleanRadioButtonGroupComponent",
            "id": "component-BooleanRadioButtonGroupComponent-8a0d49f4cc3e9ef8ba64aae4a721c19a5295139a7f153e694fd6dabbf6f4c48066406c96055e4214029be504e0252684f90fee3a75cf3fd2648e67d4950e7d7b",
            "file": "src/app/boolean-radio-button-group/boolean-radio-button-group.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-boolean-radio-button-group",
            "styleUrls": [
                "./boolean-radio-button-group.component.css"
            ],
            "styles": [],
            "templateUrl": [
                "./boolean-radio-button-group.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "selectedValue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 14
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 17,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatRadioGroup"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "MatRadioButton"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\nimport { MatRadioGroup, MatRadioButton } from '@angular/material/radio';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n    selector: 'app-boolean-radio-button-group',\n    templateUrl: './boolean-radio-button-group.component.html',\n    styleUrls: ['./boolean-radio-button-group.component.css'],\n    standalone: true,\n    imports: [MatRadioGroup, FormsModule, MatRadioButton]\n})\nexport class BooleanRadioButtonGroupComponent implements OnInit {\n\n  selectedValue!: Boolean\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./boolean-radio-button-group.component.css"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 14
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<label><ng-content></ng-content></label>\n<mat-radio-group name=\"options\" [(ngModel)]=\"selectedValue\">\n  <mat-radio-button value=\"true\">ja</mat-radio-button>\n  <mat-radio-button value=\"false\">nee</mat-radio-button>\n  \n</mat-radio-group>"
        },
        {
            "name": "BudgetComponent",
            "id": "component-BudgetComponent-ab5802e1347f1b484d762ed6e73a59f110ab93d7f293d3abc926c94b10090e9aaed528e4bcd7224404a36df227182a0c26149eedd0309c7062054dec8e0225ba",
            "file": "src/app/budget/budget.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-budget",
            "styleUrls": [
                "./budget.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./budget.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "allControls",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormControl[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 125
                },
                {
                    "name": "controlsToIdMap",
                    "defaultValue": "new Map<FormControl, number>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<FormControl | number>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 124
                },
                {
                    "name": "currentSubTreeHasError",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 128
                },
                {
                    "name": "dataLoaded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 186
                },
                {
                    "name": "dataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTreeFlatDataSource<BudgetTreeNode | FlatBudgetTreeNode>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 114
                },
                {
                    "name": "dialog",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatDialog",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 132,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "displayedColumns",
                    "defaultValue": "['category', 'budget', 'yearlyBudget']",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 119
                },
                {
                    "name": "getChildren",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 181
                },
                {
                    "name": "getLevel",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 177
                },
                {
                    "name": "hasChild",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 183
                },
                {
                    "name": "idToBudgetNodeMap",
                    "defaultValue": "new Map<number, BudgetTreeNode>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<number | BudgetTreeNode>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 127
                },
                {
                    "name": "idToControlsMap",
                    "defaultValue": "new Map<number, FormControl>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<number | FormControl>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 123
                },
                {
                    "name": "idToNodeMap",
                    "defaultValue": "new Map<number, BudgetTreeNode>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "<p>Map from flat node to nested node. This helps us finding the nested node to be modified</p>\n",
                    "line": 106,
                    "rawdescription": "\nMap from flat node to nested node. This helps us finding the nested node to be modified"
                },
                {
                    "name": "inputChanged",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 185
                },
                {
                    "name": "isExpandable",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 179
                },
                {
                    "name": "isSaved",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 187
                },
                {
                    "name": "isTreeExpanded",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 129
                },
                {
                    "name": "mainForm",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 126
                },
                {
                    "name": "matcher",
                    "defaultValue": "new MyErrorStateMatcher()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 102
                },
                {
                    "name": "nestedNodeMap",
                    "defaultValue": "new Map<BudgetTreeNode, FlatBudgetTreeNode>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "<p>Map from nested node to flattened node. This helps us to keep the same object for selection</p>\n",
                    "line": 109,
                    "rawdescription": "\nMap from nested node to flattened node. This helps us to keep the same object for selection"
                },
                {
                    "name": "qualifiedNameToNodeMap",
                    "defaultValue": "new Map<string, BudgetTreeNode>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 111
                },
                {
                    "name": "rowsToHighlight",
                    "defaultValue": "new Set<number>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Set<number>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 121
                },
                {
                    "name": "TOTAL_NODE_CATEGORY_NAME",
                    "defaultValue": "'Totaal'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 98
                },
                {
                    "name": "TOTAL_NODE_ID",
                    "defaultValue": "-1",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 97
                },
                {
                    "name": "totalBudget",
                    "defaultValue": "0",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 100
                },
                {
                    "name": "transformer",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 157
                },
                {
                    "name": "treeControl",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FlatTreeControl<FlatBudgetTreeNode>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 113
                },
                {
                    "name": "treeFlattener",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTreeFlattener<BudgetTreeNode | FlatBudgetTreeNode>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 117
                }
            ],
            "methodsClass": [
                {
                    "name": "anyFormControlIsInvalid",
                    "args": [
                        {
                            "name": "ids",
                            "type": "Set<number>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 365,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "ids",
                            "type": "Set<number>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "budgetValidator",
                    "args": [],
                    "optional": false,
                    "returnType": "ValidatorFn",
                    "typeParameters": [],
                    "line": 281,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "calculateTotalBudget",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 516,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "determineSubTreeForNode",
                    "args": [
                        {
                            "name": "data",
                            "type": "FlatBudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 328,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "FlatBudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "formControlIsInvalid",
                    "args": [
                        {
                            "name": "budgetTreeNodeId",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 380,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "budgetTreeNodeId",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getAllDescendantsRecursively",
                    "args": [
                        {
                            "name": "budgetTreeNode",
                            "type": "BudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "descendants",
                            "type": "BudgetTreeNode[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 400,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "budgetTreeNode",
                            "type": "BudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "descendants",
                            "type": "BudgetTreeNode[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getDescendantIds",
                    "args": [
                        {
                            "name": "node",
                            "type": "BudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "allDescendantIds",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 261,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "node",
                            "type": "BudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "allDescendantIds",
                            "type": "number[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getRowClass",
                    "args": [
                        {
                            "name": "data",
                            "type": "FlatBudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 190,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "FlatBudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initTotalBudgetTreeNode",
                    "args": [],
                    "optional": false,
                    "returnType": "BudgetTreeNode",
                    "typeParameters": [],
                    "line": 531,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "isLessThanSumOfDescendants",
                    "args": [
                        {
                            "name": "control",
                            "type": "FormControl",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 295,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "control",
                            "type": "FormControl",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "negativeNumberValidator",
                    "args": [],
                    "optional": false,
                    "returnType": "ValidatorFn",
                    "typeParameters": [],
                    "line": 288,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 204,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onBudgetChange",
                    "args": [
                        {
                            "name": "data",
                            "type": "FlatBudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 412,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "FlatBudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "sameSubTreeAsFocusedBudgetNode",
                    "args": [
                        {
                            "name": "data",
                            "type": "FlatBudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 450,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "FlatBudgetTreeNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "saveAll",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 460,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "toggleTree",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 507,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "validateAllControls",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 270,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatToolbar"
                },
                {
                    "name": "BankAccountSelectionComponent",
                    "type": "component"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "MatIcon"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatInput"
                },
                {
                    "name": "MatError"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                },
                {
                    "name": "NgClass"
                },
                {
                    "name": "MatIconModule",
                    "type": "module"
                },
                {
                    "name": "MatIcon"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport {FlatTreeControl} from \"@angular/cdk/tree\";\nimport {MatTreeFlatDataSource, MatTreeFlattener} from \"@angular/material/tree\";\nimport {\n  AbstractControl,\n  FormBuilder,\n  FormControl,\n  FormGroup,\n  FormGroupDirective,\n  FormsModule,\n  NgForm,\n  ReactiveFormsModule,\n  ValidatorFn\n} from \"@angular/forms\";\nimport {ErrorStateMatcher} from '@angular/material/core';\nimport {MatDialog} from \"@angular/material/dialog\";\nimport {SaveErrorDialogComponent} from \"./save-error-dialog/save-error-dialog.component\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {MatButton, MatIconButton} from '@angular/material/button';\nimport {MatIcon, MatIconModule, MatIconRegistry} from '@angular/material/icon';\nimport {NgClass, NgIf} from '@angular/common';\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from '@angular/material/table';\nimport {MatError, MatFormField} from '@angular/material/form-field';\nimport {MatInput} from '@angular/material/input';\n\nexport interface BudgetTreeNode {\n  budgetTreeNodeAmount: number;\n  budgetTreeNodeId: number;\n  budgetTreeNodeParentId: number;\n  children: BudgetTreeNode[];\n  name: string;\n  qualifiedName: string;\n}\n\nexport class FlatBudgetTreeNode {\n  level!: number;\n  expandable!: boolean;\n  name!: string;\n  qualifiedName!: string;\n  budgetTreeNodeId!: number;\n  budgetTreeNodeAmount!: number;\n  budgetTreeNodeParentId!: number;\n}\n\n\n\nexport interface FindOrCreateBudgetResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n  budgetTreeNodes: BudgetTreeNode[];\n  numberOfBudgetTreeNodes: number;\n\n}\n\nexport interface UpdateBudgetEntryResponse {\n  response: string;\n  failureReason: string | undefined | null;\n  errorMessage: string | undefined | null;\n\n\n}\n\n\nexport class MyErrorStateMatcher implements ErrorStateMatcher {\n  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {\n    return !!(control && control.invalid);\n  }\n}\n\n\n@Component({\n    selector: 'app-budget',\n    templateUrl: './budget.component.html',\n    styleUrls: ['./budget.component.scss'],\n    standalone: true,\n  imports: [MatToolbar, BankAccountSelectionComponent,\n    MatButton, MatIcon, NgIf, FormsModule, ReactiveFormsModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell,\n    MatCellDef, MatCell, MatIconButton, MatFormField, MatInput, MatError, MatHeaderRowDef,\n    MatHeaderRow, MatRowDef, MatRow, NgClass, MatIconModule, MatIcon],\n\n})\nexport class BudgetComponent implements OnInit {\n  TOTAL_NODE_ID: number = -1;\n  TOTAL_NODE_CATEGORY_NAME = 'Totaal';\n\n  totalBudget: number = 0;\n\n  matcher = new MyErrorStateMatcher();\n\n\n  /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n  idToNodeMap = new Map<number, BudgetTreeNode>();\n\n  /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n  nestedNodeMap = new Map<BudgetTreeNode, FlatBudgetTreeNode>();\n\n  qualifiedNameToNodeMap = new Map<string, BudgetTreeNode>();\n\n  treeControl!: FlatTreeControl<FlatBudgetTreeNode>\n  dataSource!: MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>;\n\n\n  treeFlattener: MatTreeFlattener<BudgetTreeNode, FlatBudgetTreeNode>;\n\n  displayedColumns: string[] = ['category', 'budget', 'yearlyBudget'];\n\n  rowsToHighlight: Set<number> = new Set<number>();\n\n  idToControlsMap: Map<number, FormControl> = new Map<number, FormControl>();\n  controlsToIdMap: Map<FormControl, number> = new Map<FormControl, number>();\n  allControls: FormControl[] = [];\n  mainForm: FormGroup;\n  idToBudgetNodeMap: Map<number, BudgetTreeNode> = new Map<number, BudgetTreeNode>();\n  currentSubTreeHasError: boolean = false;\n  isTreeExpanded = true;\n\n\n  constructor(private appService: AppService, private fb: FormBuilder, public dialog: MatDialog\n  ) {\n\n    this.mainForm = this.fb.group({});\n\n    this.treeFlattener = new MatTreeFlattener(\n      this.transformer,\n      this.getLevel,\n      this.isExpandable,\n      this.getChildren\n    );\n    this.treeControl = new FlatTreeControl<FlatBudgetTreeNode>(\n      this.getLevel,\n      this.isExpandable\n    );\n    this.dataSource = new MatTreeFlatDataSource<BudgetTreeNode, FlatBudgetTreeNode>(\n      this.treeControl,\n      this.treeFlattener\n    );\n\n\n\n  }\n\n\n  transformer = (node: BudgetTreeNode, level: number) => {\n    const existingNode = this.nestedNodeMap.get(node);\n    const flatNode =\n      existingNode && existingNode.qualifiedName === node.qualifiedName\n        ? existingNode\n        : new FlatBudgetTreeNode();\n    flatNode.name = node.name;\n    flatNode.qualifiedName = node.qualifiedName;\n    flatNode.level = level;\n    flatNode.expandable = (node.children != undefined && node.children.length > 0);\n    flatNode.budgetTreeNodeAmount = node.budgetTreeNodeAmount;\n    flatNode.budgetTreeNodeId = node.budgetTreeNodeId;\n    flatNode.budgetTreeNodeParentId = node.budgetTreeNodeParentId;\n    this.idToNodeMap.set(node.budgetTreeNodeId, node);\n\n    this.nestedNodeMap.set(node, flatNode);\n    this.qualifiedNameToNodeMap.set(node.qualifiedName, node);\n    return flatNode;\n  };\n\n  getLevel = (node: FlatBudgetTreeNode) => node.level;\n\n  isExpandable = (node: FlatBudgetTreeNode) => node.expandable;\n\n  getChildren = (node: BudgetTreeNode): BudgetTreeNode[] => node.children;\n\n  hasChild = (_: number, _nodeData: FlatBudgetTreeNode) => _nodeData.expandable;\n\n  inputChanged: boolean = false;\n  dataLoaded: boolean = false;\n  isSaved: boolean = false;\n\n\n  getRowClass(data: FlatBudgetTreeNode): string {\n    if (data.name === this.TOTAL_NODE_CATEGORY_NAME) {\n      return 'highlight-total-row';\n    }\n    if (this.currentSubTreeHasError && this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-error';\n    }\n    if (this.sameSubTreeAsFocusedBudgetNode(data)) {\n      return 'highlight-row-no-error';\n    }\n    return '';\n  }\n\n\n  ngOnInit(): void {\n    this.appService.selectedBankAccountObservable$.subscribe(selectedAccount => {\n      if (selectedAccount) {\n        this.appService.findOrCreateBudget(selectedAccount).subscribe((response: BudgetTreeNode[]) => {\n\n          let filteredData = response.filter(node => node.name !== 'NO CATEGORY' && node.name !== 'DUMMY CATEGORY');\n          let totalBudgetTreeNode = this.initTotalBudgetTreeNode();\n          filteredData.push(totalBudgetTreeNode);\n          this.dataSource.data = filteredData;\n          let allBudgetNodes: BudgetTreeNode[] = [];\n          for (const node of response) {\n            if (node.name === 'NO CATEGORY' || node.name === 'DUMMY CATEGORY') {\n              continue;\n            }\n            allBudgetNodes.push(node);\n            this.getAllDescendantsRecursively(node, allBudgetNodes);\n          }\n\n\n          for (const node of allBudgetNodes) {\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            let control = new FormControl<number>(node.budgetTreeNodeAmount, [this.budgetValidator(), this.negativeNumberValidator()]);\n            this.idToControlsMap.set(node.budgetTreeNodeId, control);\n            control.valueChanges.subscribe((value) => {\n              if ((value !== undefined)) {\n                // this.inputChanged = false;\n                this.validateAllControls();\n                this.calculateTotalBudget();\n\n                let flatNode = this.nestedNodeMap.get(node);\n                if (flatNode){\n                  if (flatNode.name === this.TOTAL_NODE_CATEGORY_NAME) {\n                    //we don't want to do anything when the total node is changed\n                    return;\n                  }\n                  this.determineSubTreeForNode(flatNode as FlatBudgetTreeNode);\n                  if (!this.currentSubTreeHasError){\n                    this.onBudgetChange(flatNode as FlatBudgetTreeNode);\n                  }\n                }\n              }\n            });\n            this.idToBudgetNodeMap.set(node.budgetTreeNodeId, node);\n            this.controlsToIdMap.set(control, node.budgetTreeNodeId);\n            this.allControls.push(control);\n            this.mainForm.addControl(node.budgetTreeNodeId.toString(), control);\n          }\n          this.calculateTotalBudget();\n          this.dataLoaded = true;\n          this.treeControl.expandAll();\n\n        });\n      }\n    });\n\n  }\n\n  getDescendantIds(node: BudgetTreeNode, allDescendantIds: number[]) {\n    if (node.children && node.children.length > 0) {\n      node.children.forEach(child => {\n        allDescendantIds.push(child.budgetTreeNodeId);\n        this.getDescendantIds(child, allDescendantIds);\n      });\n    }\n  }\n\n  validateAllControls() {\n    Object.keys(this.mainForm.controls).forEach(key => {\n      const control = this.mainForm.get(key);\n      if (control) {\n        control.updateValueAndValidity({onlySelf: false, emitEvent: false});\n\n      }\n    });\n    this.mainForm.markAllAsTouched();\n  }\n\n  budgetValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isLessThanSumOfDescendants = this.isLessThanSumOfDescendants(control as FormControl);\n      return isLessThanSumOfDescendants ? {'isLessThanItsDescendants': {value: control.value}} : null;\n    };\n  }\n\n  negativeNumberValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      const isNegative = control.value < 0;\n      return isNegative ? {'negativeNumber': {value: control.value}} : null;\n    };\n  }\n\n  isLessThanSumOfDescendants(control: FormControl): boolean {\n    let nodeId = this.controlsToIdMap.get(control);\n    if (!nodeId) {\n      return false;\n    }\n\n    let nodeValue = control.value;\n\n    if (nodeValue == undefined || nodeValue < 0) {\n      return false;\n    }\n    let sumOfDescendants = 0;\n\n    let payload = this.idToBudgetNodeMap.get(nodeId) as BudgetTreeNode;\n    let allDescendantIds: number[] = [];\n    this.getDescendantIds(payload, allDescendantIds);\n\n    for (const descendantId of allDescendantIds) {\n      let descendantValue = this.idToControlsMap.get(descendantId)?.value;\n      if (descendantValue) {\n        sumOfDescendants = sumOfDescendants + descendantValue;\n\n      }\n    }\n\n\n    let isLessThanSumOfDescendants = nodeValue < sumOfDescendants;\n    //unpacking boolean for debugging purposes\n    return isLessThanSumOfDescendants;\n\n  }\n\n\n  determineSubTreeForNode(data: FlatBudgetTreeNode) {\n    this.rowsToHighlight = new Set<number>();\n    this.currentSubTreeHasError = false;\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n    this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n    if (budgetTreeNode.budgetTreeNodeParentId) {\n      //go one level up the tree to the parent. Add the id of the parent and all its descendants to the set of rows to highlight\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeParentId);\n      let parentBudgetTreeNode = this.idToNodeMap.get(budgetTreeNode.budgetTreeNodeParentId);\n      if (parentBudgetTreeNode == undefined) {\n        return;\n      }\n\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(parentBudgetTreeNode, allDescendantIds);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n\n\n\n    } else {\n      let allDescendantIds: number[] = [];\n      this.getDescendantIds(budgetTreeNode, allDescendantIds);\n      this.rowsToHighlight.add(budgetTreeNode.budgetTreeNodeId);\n      allDescendantIds.forEach(id => {\n        this.rowsToHighlight.add(id);\n      });\n    }\n    this.currentSubTreeHasError = this.anyFormControlIsInvalid(this.rowsToHighlight);\n\n\n  }\n\n  private anyFormControlIsInvalid(ids: Set<number>): boolean {\n    let idsArray = [...ids];\n    for (const number of idsArray) {\n      if(this.formControlIsInvalid(number)){\n        return true;\n      }\n    }\n\n    return false;\n\n\n\n\n  }\n\n  private formControlIsInvalid(budgetTreeNodeId: number): boolean {\n    let control = this.mainForm.get(budgetTreeNodeId.toString());\n    if (control) {\n      return control.invalid;\n    }\n    return false;\n  }\n\n\n  /*onBlur() {\n    this.inputChanged = true;\n  }\n\n  onKeyUpEnter(event: Event) {\n    let kbe = event as KeyboardEvent;\n    if (kbe.key === 'Enter') {\n      this.inputChanged = true;\n    }\n  }*/\n\n  getAllDescendantsRecursively(budgetTreeNode: BudgetTreeNode, descendants: BudgetTreeNode[]) {\n    if (budgetTreeNode.children && budgetTreeNode.children.length > 0) {\n      budgetTreeNode.children.forEach(child => {\n        descendants.push(child);\n        this.getAllDescendantsRecursively(child, descendants);\n      });\n    }\n  }\n\n\n\n\n  onBudgetChange(data: FlatBudgetTreeNode): void {\n\n    let budgetControl = this.mainForm.get(data.budgetTreeNodeId.toString()) as FormControl;\n    if (budgetControl == undefined) {\n      return;\n    }\n    if (data.budgetTreeNodeAmount === undefined || data.budgetTreeNodeAmount === null) {\n      data.budgetTreeNodeAmount = 0;\n      budgetControl.setValue(0);\n    }\n\n\n    if (!budgetControl.valid) {\n      return;\n    }\n    let budgetTreeNode = this.idToNodeMap.get(data.budgetTreeNodeId);\n    if (budgetTreeNode == undefined) {\n      return;\n    }\n\n\n    if (budgetTreeNode.budgetTreeNodeAmount !== budgetControl.value) {\n      budgetTreeNode.budgetTreeNodeAmount = budgetControl.value;\n    }\n\n    this.appService.updateBudgetEntryAmount(budgetTreeNode).subscribe(\n      (\n        response: UpdateBudgetEntryResponse\n      ) => {\n        if (response.response.toLowerCase() !== \"success\") {\n          throw new Error(\"Failed to update budget entry amount\");\n        }\n        // this.recalculateCumulatedAmountsForAllNodes();\n        this.treeControl.expandAll();\n      });\n\n  }\n\n  sameSubTreeAsFocusedBudgetNode(data: FlatBudgetTreeNode): boolean {\n    return this.rowsToHighlight.has(data.budgetTreeNodeId);\n\n  }\n\n\n  /*onInputChange() {\n    this.inputChanged = true\n  }*/\n\n  saveAll() {\n    if (this.mainForm.invalid) {\n      let invalidCategories: BudgetTreeNode[] = [];\n      Object.keys(this.mainForm.controls).forEach(key => {\n        const control = this.mainForm.get(key);\n        if (control && control.invalid) {\n          let node = this.idToNodeMap.get(parseInt(key));\n          if (!node) {\n            throw new Error(\"Failed to find node for id \" + key);\n          }\n          node.budgetTreeNodeAmount = control.value;\n          invalidCategories.push(node);\n\n\n        }\n      });\n      this.dialog.open(SaveErrorDialogComponent, {\n        data: {\n          message: 'Sommige wijzingen kunnen niet worden opgeslaan! Corrigeer de inconsistente budgetbedragen voor onderstaande categorieën en probeer opnieuw:',\n          nodes: invalidCategories\n        }\n      });\n    } else {\n      let budgetTreeNodes = this.dataSource.data;\n      for (const budgetTreeNode of budgetTreeNodes) {\n        if (budgetTreeNode.budgetTreeNodeId === this.TOTAL_NODE_ID) {\n          continue;\n        }\n        let flatNode = this.nestedNodeMap.get(budgetTreeNode);\n        if (!flatNode) {\n          throw new Error(\"Failed to find flat node for budget tree node \" + budgetTreeNode);\n        } else {\n          this.onBudgetChange(flatNode);\n        }\n\n\n      }\n\n\n\n\n\n\n    }\n  }\n\n\n  toggleTree(): void {\n    if (this.isTreeExpanded) {\n      this.treeControl.collapseAll();\n    } else {\n      this.treeControl.expandAll();\n    }\n    this.isTreeExpanded = !this.isTreeExpanded;\n  }\n\n  calculateTotalBudget(): void {\n    this.totalBudget = Array.from(this.idToControlsMap.values()).filter(control => control.valid)\n      .reduce((sum, control) => sum + (control.value || 0), 0);\n    let totalNode = {\n      budgetTreeNodeAmount: this.totalBudget,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n    this.dataSource.data = [totalNode, ...this.dataSource.data.slice(1, this.dataSource.data.length - 1), totalNode];\n    this.mainForm.get(totalNode.budgetTreeNodeId.toString())?.setValue(totalNode.budgetTreeNodeAmount);\n  }\n\n  initTotalBudgetTreeNode(): BudgetTreeNode {\n    return {\n      budgetTreeNodeAmount: 0,\n      budgetTreeNodeId: this.TOTAL_NODE_ID, // Use a unique ID that does not conflict with existing IDs\n      budgetTreeNodeParentId: -1,\n      children: [],\n      name: this.TOTAL_NODE_CATEGORY_NAME,\n      qualifiedName: this.TOTAL_NODE_CATEGORY_NAME\n    };\n  }\n\n}\n\n\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".highlight-row-no-error{\r\n  background-color: lightgreen;\r\n}\r\n.highlight-row-error{\r\n  background-color: lightpink;\r\n}\r\n\r\n.highlight-total-row{\r\n  background-color: lightgray;\r\n  font-weight: bold;\r\n}\r\n/*td.mat-cell, th.mat-header-cell, tr.mat-header-row, tr.mat-row {\r\n  height: 30px;\r\n}*/\r\n:host ::ng-deep .mat-mdc-row{\r\n  padding-bottom: 2px;\r\n  padding-top: 2px;\r\n}\r\n/*\r\n:host ::ng-deep mat-error {\r\n  font-size: 10px;\r\n}\r\n*/\r\n\r\n\r\n.mat-mdc-table-wrapper {\r\n  //height: 300px; // Set this to your desired height\r\n  overflow: auto;\r\n}\r\n\r\n.mat-mdc-table {\r\n  width: 100%;\r\n}\r\n\r\n.button {\r\n  padding: 1.40em 0;\r\n  line-height: 1;\r\n}\r\n\r\n.flex-child{\r\n  flex: 1;\r\n}\r\n\r\n.flex-child:first-child {\r\n  margin-right: 2px;\r\n}\r\n\r\n",
                    "styleUrl": "./budget.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 129,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<mat-toolbar color=\"primary\" class=\"toolbar-header\">\n  <span>Budget</span>\n\n\n</mat-toolbar>\n<div>\n  <div style=\"display: flex;justify-content: space-between; position: sticky; top:0px;background: rgba(255, 255, 255, 1); height: 5vh\">\n    <bank-account-selection style=\"padding-left: 16px; width: fit-content;\"></bank-account-selection>\n    <div style=\"display:flex\">\n      <button mat-button (click)=\"saveAll()\" class=\"button;flex-child\">\n        <div style=\"display: flex; flex-direction: column; align-items: center;\">\n          <mat-icon>save</mat-icon>\n          Save\n        </div>\n      </button>\n      <button mat-button (click)=\"toggleTree()\" class=\"button;flex-child\">\n        <div style=\"display: flex; flex-direction: column; align-items: center;\">\n            <mat-icon>{{ isTreeExpanded ? 'expand_less' : 'expand_more' }}</mat-icon>\n          {{ isTreeExpanded ? 'Collapse' : 'Expand' }}\n        </div>\n      </button>\n    </div>\n  </div>\n  <form *ngIf=\"dataLoaded\" [formGroup]=\"mainForm\" style=\"height: 85vh; overflow-y: scroll\">\n    <div class=\"mat-table-wrapper\">\n      <table mat-table [dataSource]=\"dataSource\" class=\"mat-elevation-z8\" style=\"width: 100%\">\n        <ng-container matColumnDef=\"category\">\n          <th mat-header-cell *matHeaderCellDef>\n            <span [style.padding-left.px]=\"50\">Categorie</span>\n          </th>\n          <td mat-cell *matCellDef=\"let data\">\n            <button mat-icon-button\n                    [style.visibility]=\"!data.expandable ? 'hidden' : ''\"\n                    [style.margin-left.px]=\"data.level * 32\"\n                    (click)=\"treeControl.toggle(data)\">\n              <mat-icon class=\"mat-icon-rtl-mirror\">\n                {{ treeControl.isExpanded(data) ? 'expand_more' : 'chevron_right' }}\n              </mat-icon>\n            </button>\n            {{ data.name }}\n          </td>\n        </ng-container>\n        <ng-container matColumnDef=\"budget\">\n          <th mat-header-cell *matHeaderCellDef>Maandbudget</th>\n          <td mat-cell *matCellDef=\"let data\">\n            <mat-form-field *ngIf=\"data.budgetTreeNodeId !== -1\">\n              <label hidden=\"hidden\">node {{ data.budgetTreeNodeId }}</label>\n              <input matInput type=\"number\"\n                     formControlName=\"{{data.budgetTreeNodeId}}\" [errorStateMatcher]=\"matcher\"\n                     (focus)=\"determineSubTreeForNode(data)\"\n              >\n              <mat-error *ngIf=\"mainForm.controls[data.budgetTreeNodeId]?.errors?.['negativeNumber']\">\n                The number must not be negative!\n              </mat-error>\n              <mat-error *ngIf=\"mainForm.controls[data.budgetTreeNodeId]?.errors?.['isLessThanItsDescendants']\">\n                Sum of descendants must not be greater than parent budget!\n              </mat-error>\n            </mat-form-field>\n            <span *ngIf=\"data.budgetTreeNodeId === -1\">{{ data.budgetTreeNodeAmount }}</span>\n          </td>\n        </ng-container>\n\n        <ng-container matColumnDef=\"yearlyBudget\">\n          <th mat-header-cell *matHeaderCellDef>Jaarbudget</th>\n          <td mat-cell *matCellDef=\"let data\">\n            <span>{{ data.budgetTreeNodeAmount * 12 }}</span>\n\n          </td>\n        </ng-container>\n        <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n        <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"\n            [ngClass]=\"getRowClass(row)\"></tr>\n\n\n      </table>\n    </div>\n  </form>\n\n</div>\n"
        },
        {
            "name": "BudgetTrackingComponent",
            "id": "component-BudgetTrackingComponent-31e677090fb0c2c23cc7e2bb13475d3538a573e0fc59ac3f309d4f983dbe780069df3a6d7b8effb683e2d1309a1e1e3378f4e7b7653c4c6376d69d44cb268204",
            "file": "src/app/budget-tracking/budget-tracking.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "budget-tracking",
            "styleUrls": [
                "./budget-tracking.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./budget-tracking.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "criteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 41,
                    "type": "Criteria",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "columns",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "dataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTableDataSource<any>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "datatIsLoaded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "displayedColumns",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "TransactionType",
                    "defaultValue": "TransactionTypeEnum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 96,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "treeNodes",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TreeNode[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                }
            ],
            "methodsClass": [
                {
                    "name": "doQuery",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 56,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getCellValue",
                    "args": [
                        {
                            "name": "element",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "column",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 100,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "element",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "column",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 89,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 86,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, Input, OnChanges, OnInit, SimpleChanges} from '@angular/core';\n\nimport {AppService} from '../app.service';\nimport {Criteria} from \"../model/criteria.model\";\n// @ts-ignore\nimport autocolors from 'chartjs-plugin-autocolors';\nimport {\n    MatCell,\n    MatCellDef,\n    MatColumnDef,\n    MatHeaderCell,\n    MatHeaderCellDef,\n    MatHeaderRow,\n    MatHeaderRowDef,\n    MatRow,\n    MatRowDef,\n    MatTable,\n    MatTableDataSource\n} from \"@angular/material/table\";\nimport {TreeNode} from \"primeng/api\";\nimport {\n    ApiBudgetAssistantBackendClientService,\n    BudgetTrackerResult,\n    ExpensesRecurrenceEnum,\n    RevenueExpensesQuery,\n    TransactionTypeEnum\n} from \"@daanvdn/budget-assistant-client\";\nimport {RevenueRecurrenceEnum} from \"@daanvdn/budget-assistant-client\";\nimport {catchError, throwError} from \"rxjs\";\nimport {NgFor, NgIf} from '@angular/common';\n\n@Component({\n    selector: 'budget-tracking',\n    templateUrl: './budget-tracking.component.html',\n    styleUrls: ['./budget-tracking.component.scss'],\n    standalone: true,\n    imports: [NgIf, MatTable, NgFor, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow]\n})\nexport class BudgetTrackingComponent implements OnInit, OnChanges {\n\n    @Input() criteria!: Criteria\n    datatIsLoaded: Boolean = false;\n    treeNodes!: TreeNode[];\n    columns!: string[];\n\n    // Add these properties to your component\n    dataSource!: MatTableDataSource<any>;\n    displayedColumns!: string[];\n\n\n    constructor(private appService: AppService, private apiBudgetAssistantBackendClientService: ApiBudgetAssistantBackendClientService) {\n\n\n    }\n\n    doQuery() {\n        if (!this.criteria) {\n            throw new Error(\"Query parameters are not initialized!\");\n        }\n        this.datatIsLoaded = false;\n        let query: RevenueExpensesQuery = {\n            accountNumber: this.criteria.bankAccount.accountNumber,\n            grouping: this.criteria.grouping,\n            transactionType: TransactionTypeEnum.BOTH,\n            start: JSON.stringify(this.criteria.startDate),\n            end: JSON.stringify(this.criteria.endDate),\n            expensesRecurrence: ExpensesRecurrenceEnum.BOTH,\n            revenueRecurrence: RevenueRecurrenceEnum.BOTH\n\n        };\n        this.apiBudgetAssistantBackendClientService.apiTrackBudgetCreate(query).pipe(\n            catchError(error => {\n                console.error('Error occurred:', error);\n                return throwError(error);\n            })\n        ).subscribe((res: BudgetTrackerResult) => {\n            /*this.treeNodes= res.data;\n            this.columns = res.columns;\n             this.datatIsLoaded = true;*/\n            this.dataSource = new MatTableDataSource(res.data);\n            this.displayedColumns = res.columns;\n            this.datatIsLoaded = true;\n        })\n    }\n\n    ngOnInit(): void {\n    }\n\n    ngOnChanges(changes: SimpleChanges): void {\n        if (changes['criteria']?.currentValue) {\n            this.doQuery();\n        }\n\n    }\n\n    protected readonly TransactionType = TransactionTypeEnum;\n\n\n\n    getCellValue(element: any, column: string) {\n        //check if element has the column\n\n        let value = element.data[column];\n        if (value !== null && value !== undefined) {\n            if (typeof value === 'number') {\n                return value.toFixed(0);\n            }\n            return value\n\n        }\n        return \"N/A\";\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "\r\n.mat-mdc-table {\r\n  border-collapse: collapse;\r\n  td, th {\r\n    border: 1px solid #ddd;\r\n    padding: 8px;\r\n    text-align: left;\r\n\r\n  }\r\n  th {\r\n    background-color: #f2f2f2;\r\n    font-weight: bold;\r\n\r\n  }\r\n  td{\r\n\r\n  }\r\n}\r\n\r\n\r\n.mat-mdc-table-sticky {\r\n  background: #59abfd;\r\n  opacity: 1;\r\n}\r\n.mat-mdc-table-sticky-border-elem-top {\r\n  border-bottom: 2px solid midnightblue;\r\n}\r\n\r\n.mat-mdc-table-sticky-border-elem-right {\r\n  border-left: 2px solid midnightblue;\r\n}\r\n\r\n.mat-mdc-table-sticky-border-elem-bottom {\r\n  border-top: 2px solid midnightblue;\r\n}\r\n\r\n.mat-mdc-table-sticky-border-elem-left {\r\n  border-right: 2px solid midnightblue;\r\n}\r\n\r\n.color-red {\r\n  color: red;\r\n\r\n}\r\n.color-light-coral {\r\n  background: lightcoral;\r\n\r\n}\r\n\r\n.color-green {\r\n  color: green;\r\n}\r\n\r\n.mat-mdc-table {\r\n  width: 100%;\r\n}\r\n\r\n.mat-mdc-header-cell, .mat-mdc-cell {\r\n  padding: 8px;\r\n  text-align: left;\r\n}",
                    "styleUrl": "./budget-tracking.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "apiBudgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 48,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "apiBudgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<!--\n<div *ngIf=\"datatIsLoaded && this.criteria\">\n    <div style=\" padding-top: 10px; width: 100%; overflow-x: auto\">\n        <p-treeTable [value]=\"treeNodes\" [columns]=\"columns\">\n            <ng-template pTemplate=\"header\" let-columns let-rowNode>\n                <tr [ttRow]=\"rowNode\">\n                    <th *ngFor=\"let col of columns\">\n                        {{col}}\n                    </th>\n                </tr>\n            </ng-template>\n            <ng-template pTemplate=\"body\" let-rowNode let-rowData=\"rowData\" let-columns=\"columns\">\n                <tr>\n                    <td *ngFor=\"let col of columns; let i = index\">\n                        <p-treeTableToggler [rowNode]=\"rowNode\" *ngIf=\"i == 0\"></p-treeTableToggler>\n                        {{formatCell(rowData[col])}}\n                    </td>\n                </tr>\n            </ng-template>\n        </p-treeTable>\n    </div>\n</div>\n\n\n\n-->\n<div *ngIf=\"datatIsLoaded && this.criteria\">\n    <div style=\"padding-top: 10px; width: 100%; overflow-x: auto\">\n        <table mat-table [dataSource]=\"dataSource\" class=\"mat-elevation-z8\">\n            <!-- Define the columns -->\n            <ng-container *ngFor=\"let column of displayedColumns\" [matColumnDef]=\"column\">\n                <th mat-header-cell *matHeaderCellDef> {{column}} </th>\n                <td mat-cell *matCellDef=\"let element\"> {{getCellValue(element, column)}} </td>\n            </ng-container>\n\n            <!-- Header row -->\n            <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n\n            <!-- Data rows -->\n            <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\n        </table>\n    </div>\n</div>"
        },
        {
            "name": "CategoryDetailsComponent",
            "id": "component-CategoryDetailsComponent-e168bf21321adc90ae9c3bf77f337ffe9eca6e61b6b27cf2e762cd27d58c8793f768f74f7193609e8f59413c570689d2cfc43cb589970de84724ebc82bacb233",
            "file": "src/app/category-details/category-details.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "category-details",
            "styleUrls": [
                "./category-details.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./category-details.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "criteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 49,
                    "type": "Criteria",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "chartData",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45
                },
                {
                    "name": "chartOptions",
                    "defaultValue": "this.initChartOptions()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "datatIsLoaded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "expensesCategories",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Category[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "plugins",
                    "defaultValue": "[ChartDataLabels, autocolors]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "revenueCategories",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Category[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "selectedCategory",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Category | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "TransactionType",
                    "defaultValue": "TransactionTypeEnum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 179,
                    "modifierKind": [
                        124,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "doQuery",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 123,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getCategories",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Observable<string[]>",
                    "typeParameters": [],
                    "line": 159,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initCategoryLists",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 63,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initChartOptions",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 83,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 181,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 77,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onCategorySelectionChange",
                    "args": [
                        {
                            "name": "$event",
                            "type": "MatSelectionListChange",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 170,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "$event",
                            "type": "MatSelectionListChange",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatSelectionList"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatListOption"
                },
                {
                    "name": "ChartModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, Input, OnChanges, OnInit, SimpleChanges} from '@angular/core';\nimport {Dataset} from \"../model\";\nimport {AppService} from \"../app.service\";\nimport ChartDataLabels from \"chartjs-plugin-datalabels\";\nimport {Observable} from \"rxjs\";\nimport {MatListOption, MatSelectionList, MatSelectionListChange} from \"@angular/material/list\";\n// @ts-ignore\nimport autocolors from 'chartjs-plugin-autocolors';\nimport {\n    BankAccount,\n    ExpensesRecurrenceEnum,\n    RevenueExpensesQuery,\n    RevenueRecurrenceEnum,\n    TransactionTypeEnum\n} from \"@daanvdn/budget-assistant-client\";\n\nimport {Criteria} from \"../model/criteria.model\";\nimport {NgFor, NgIf} from '@angular/common';\nimport {ChartModule} from 'primeng/chart';\n\n\ninterface Category {\n    name: string;\n    transactionType: TransactionTypeEnum;\n\n}\n@Component({\n    selector: 'category-details',\n    templateUrl: './category-details.component.html',\n    styleUrls: ['./category-details.component.scss'],\n    standalone: true,\n    imports: [NgIf, MatSelectionList, NgFor, MatListOption, ChartModule]\n})\nexport class CategoryDetailsComponent implements OnInit, OnChanges {\n\n    /* executedInitialQuery: boolean = false;\n     criteriaChangeCount: number = 0;\n     criteria: Criteria | undefined;*/\n\n\n    selectedCategory: Category | undefined;\n    plugins: any[] = [ChartDataLabels, autocolors];\n    expensesCategories!: Category[];\n    revenueCategories!: Category[];\n    chartData: any;\n\n    datatIsLoaded: Boolean = false;\n    chartOptions: any = this.initChartOptions();\n    @Input() criteria!: Criteria;\n\n    constructor(private appService: AppService) {\n\n        this.appService.selectedBankAccountObservable$.subscribe(bankAccount => {\n            if (bankAccount) {\n                this.initCategoryLists(bankAccount);\n            }\n\n        });\n\n    }\n\n\n    private initCategoryLists(bankAccount: BankAccount) {\n        this.getCategories(bankAccount, TransactionTypeEnum.EXPENSES).subscribe((data) => {\n            this.expensesCategories = data.map((category: string) => {\n                return {name: category, transactionType: TransactionTypeEnum.EXPENSES};\n            });\n        });\n        this.getCategories(bankAccount, TransactionTypeEnum.REVENUE).subscribe((data) => {\n            this.revenueCategories = data.map((category: string) => {\n                return {name: category, transactionType: TransactionTypeEnum.REVENUE};\n            });\n        });\n    }\n\n\n    ngOnInit(): void {\n\n    }\n\n\n\n    initChartOptions(): any {\n        return {\n            plugins: {\n                datalabels: {\n                    display: true,\n                    align: 'end',\n                    anchor: 'end',\n                    formatter: function (value: any, context: any) {\n                        return Math.round(value) || null;\n                    }\n\n                },\n                autocolors: {\n                    enabled: true,\n                    mode: 'dataset', // or 'data' or 'label'\n                    // other options...\n                }\n            },\n            indexAxis: 'x',\n            tooltips: {\n                mode: 'index',\n                intersect: false\n            },\n            responsive: true,\n            scales: {\n                x: {\n                    stacked: true\n\n                },\n                y: {\n                    stacked: true\n\n\n                }\n            }\n        };\n\n    }\n\n\n    doQuery(): void {\n\n        this.datatIsLoaded = false;\n\n        if (!this.criteria || !this.selectedCategory) {\n            return;\n        }\n        if(this.selectedCategory.transactionType !== this.criteria.transactionType) {\n            return;\n        }\n\n        let query: RevenueExpensesQuery = {\n            accountNumber: this.criteria.bankAccount.accountNumber,\n            grouping: this.criteria.grouping,\n            transactionType: this.criteria.transactionType,\n            start: JSON.stringify(this.criteria.startDate),\n            end: JSON.stringify(this.criteria.endDate),\n            expensesRecurrence: ExpensesRecurrenceEnum.BOTH,\n            revenueRecurrence: RevenueRecurrenceEnum.BOTH\n\n        };\n\n\n        this.datatIsLoaded = false;\n        this.appService.getCategoryDetailsForPeriod(query, this.selectedCategory.name).subscribe((data) => {\n            data.datasets = data.datasets.map((dataset: Dataset) => {\n                dataset.maxBarThickness = 50\n                return dataset;\n            });\n            this.chartData = data;\n            this.datatIsLoaded = true;\n        });\n\n    }\n\n\n    private getCategories(bankAccount: BankAccount, transactionType: TransactionTypeEnum):\n        Observable<string[]> {\n        if (transactionType === TransactionTypeEnum.BOTH) {\n            throw new Error(\"TransactionType.BOTH is not supported\");\n        }\n\n        return this.appService.getCategoriesForAccountAndTransactionType(bankAccount.accountNumber, transactionType);\n\n    }\n\n\n    onCategorySelectionChange($event: MatSelectionListChange) {\n        let options = $event.options;\n        if (options) {\n            this.selectedCategory = options[0].value as Category;\n            this.doQuery();\n        }\n\n    }\n\n    protected readonly TransactionType = TransactionTypeEnum;\n\n    ngOnChanges(changes: SimpleChanges): void {\n        let criteriaChange = changes['criteria'];\n        if (criteriaChange && criteriaChange.currentValue) {\n            let previousCriteria = criteriaChange.previousValue;\n            if (previousCriteria && this.criteria && previousCriteria.transactionType !== this.criteria.transactionType) {\n                this.selectedCategory = undefined;\n            }\n            this.doQuery();\n         }\n\n    }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./category-details.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 49,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<div *ngIf=\"criteria\" style=\"display: flex; justify-content: space-between;\">\n    <mat-selection-list *ngIf=\"criteria.transactionType === 'EXPENSES'; else showRevenueCategories\"\n                        [multiple]=\"false\" (selectionChange)=\"onCategorySelectionChange($event)\"\n                        style=\"width: fit-content; overflow-y: auto; height: 80vh\">\n        <mat-list-option *ngFor=\"let category of expensesCategories\" [value]=\"category\">\n            {{ category.name }}\n        </mat-list-option>\n    </mat-selection-list>\n    <ng-template #showRevenueCategories>\n        <mat-selection-list [multiple]=\"false\" (selectionChange)=\"onCategorySelectionChange($event) \"\n                            style=\"width: fit-content; overflow-y: auto; height: 80vh\">\n            <mat-list-option *ngFor=\"let category of revenueCategories\" [value]=\"category\">\n                {{ category.name }}\n            </mat-list-option>\n        </mat-selection-list>\n\n    </ng-template>\n    <div *ngIf=\"datatIsLoaded\" style=\"width: 100%; height: 80vh\">\n        <p-chart type=\"bar\" [data]=\"chartData\" [options]=\"chartOptions\" [plugins]=\"plugins\"></p-chart>\n\n    </div>\n</div>\n\n"
        },
        {
            "name": "CategoryTreeDropdownComponent",
            "id": "component-CategoryTreeDropdownComponent-32bf478a495183c644fb2a8f3cf7748e17ba31f7897af4b46118f618adae368a8edeca283ae501448a928b16fbcce92a6f62b6546bd3f3f8fe390bfd397e2547",
            "file": "src/app/category-tree-dropdown/category-tree-dropdown.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-category-tree-dropdown",
            "styleUrls": [
                "./category-tree-dropdown.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./category-tree-dropdown.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "selectedCategoryQualifiedNameStr",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 148,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "transactionTypeEnum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 155,
                    "type": "TransactionTypeEnum",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "selectionChange",
                    "defaultValue": "new EventEmitter<string>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 157,
                    "type": "EventEmitter<string>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "_database",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BackingDatabase",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 169
                },
                {
                    "name": "autoCompleteTrigger",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatAutocompleteTrigger",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 160,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'autoCompleteTrigger'"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "categoryFormGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 245
                },
                {
                    "name": "checklistSelection",
                    "defaultValue": "new SelectionModel<FlatCategoryNode>(false /* multiple */)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "<p>The selection for checklist</p>\n",
                    "line": 168,
                    "rawdescription": "\nThe selection for checklist"
                },
                {
                    "name": "dataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTreeFlatDataSource<CategoryNode | FlatCategoryNode>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 153
                },
                {
                    "name": "flatNodeMap",
                    "defaultValue": "new Map<FlatCategoryNode, CategoryNode>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "<p>Map from flat node to nested node. This helps us finding the nested node to be modified</p>\n",
                    "line": 140,
                    "rawdescription": "\nMap from flat node to nested node. This helps us finding the nested node to be modified"
                },
                {
                    "name": "formField",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatFormField",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 159,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'formField'"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "getChildren",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 240
                },
                {
                    "name": "getLevel",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 236
                },
                {
                    "name": "hasChild",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 242
                },
                {
                    "name": "hasNoContent",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 244
                },
                {
                    "name": "isExpandable",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 238
                },
                {
                    "name": "nestedNodeMap",
                    "defaultValue": "new Map<CategoryNode, FlatCategoryNode>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "<p>Map from nested node to flattened node. This helps us to keep the same object for selection</p>\n",
                    "line": 143,
                    "rawdescription": "\nMap from nested node to flattened node. This helps us to keep the same object for selection"
                },
                {
                    "name": "qualifiedNameToNodeMap",
                    "defaultValue": "new Map<string, CategoryNode>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 145
                },
                {
                    "name": "selectedCategory",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryNode",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 149
                },
                {
                    "name": "selectedCategoryName",
                    "defaultValue": "\"select category\"",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 150
                },
                {
                    "name": "transformer",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 218
                },
                {
                    "name": "treeControl",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FlatTreeControl<FlatCategoryNode>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 152
                },
                {
                    "name": "treeFlattener",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTreeFlattener<CategoryNode | FlatCategoryNode>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 165
                }
            ],
            "methodsClass": [
                {
                    "name": "filterChanged",
                    "args": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 247,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 194,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "toggleSelection",
                    "args": [
                        {
                            "name": "node",
                            "type": "FlatCategoryNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 259,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "node",
                            "type": "FlatCategoryNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toggleSelectionWithoutEmittingChange",
                    "args": [
                        {
                            "name": "node",
                            "type": "FlatCategoryNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 277,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "node",
                            "type": "FlatCategoryNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatInput"
                },
                {
                    "name": "MatAutocompleteTrigger"
                },
                {
                    "name": "MatAutocomplete"
                },
                {
                    "name": "MatOption"
                },
                {
                    "name": "MatTree"
                },
                {
                    "name": "MatTreeNodeDef"
                },
                {
                    "name": "MatTreeNode"
                },
                {
                    "name": "MatTreeNodeToggle"
                },
                {
                    "name": "MatTreeNodePadding"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "MatCheckbox"
                },
                {
                    "name": "MatIcon"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {SelectionModel} from '@angular/cdk/collections';\nimport {FlatTreeControl} from '@angular/cdk/tree';\nimport {Component, EventEmitter, Input, OnInit, Output, ViewChild} from '@angular/core';\nimport {\n  MatTree,\n  MatTreeFlatDataSource,\n  MatTreeFlattener,\n  MatTreeNode,\n  MatTreeNodeDef,\n  MatTreeNodePadding,\n  MatTreeNodeToggle\n} from '@angular/material/tree';\nimport {BehaviorSubject} from 'rxjs';\nimport {AppService} from '../app.service';\nimport {FormBuilder, FormGroup, FormsModule, ReactiveFormsModule} from \"@angular/forms\";\nimport {MatFormField} from \"@angular/material/form-field\";\nimport {MatAutocomplete, MatAutocompleteTrigger} from \"@angular/material/autocomplete\";\nimport {CategoryNode, FlatCategoryNode, NO_CATEGORY} from \"../model\";\nimport {MatInput} from '@angular/material/input';\nimport {MatOption} from '@angular/material/core';\nimport {MatIconButton} from '@angular/material/button';\nimport {MatCheckbox} from '@angular/material/checkbox';\nimport {MatIcon} from '@angular/material/icon';\nimport {TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\n\n\n// @Injectable({ providedIn: \"root\" })\nexport class BackingDatabase {\n  dataChange = new BehaviorSubject<CategoryNode[]>([]);\n  treeData?: any[];\n\n  get data(): CategoryNode[] {\n    return this.dataChange.value;\n  }\n\n  constructor(private appService: AppService, transactionTypeEnum: TransactionTypeEnum) {\n    this.initialize(transactionTypeEnum);\n  }\n\n\n\n  initialize(transactionTypeEnum: TransactionTypeEnum) {\n\n    switch (transactionTypeEnum) {\n      case TransactionTypeEnum.REVENUE:\n        this.appService.sharedCategoryTreeRevenueObservable$.subscribe(tree => {\n          this.treeData = tree;\n          // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n          //     file node as children.\n          const data = tree;\n\n          // Notify the change.\n          this.dataChange.next(data);\n\n        });\n        break;\n      case TransactionTypeEnum.EXPENSES:\n        this.appService.sharedCategoryTreeExpensesObservable$.subscribe(tree => {\n          this.treeData = tree;\n          // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n          //     file node as children.\n          const data = tree;\n\n          // Notify the change.\n          this.dataChange.next(data);\n\n        });\n        break;\n      case TransactionTypeEnum.BOTH:\n\n\n        this.appService.sharedCategoryTreeObservable$.subscribe(tree => {\n          this.treeData = tree;\n          // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n          //     file node as children.\n          const data = tree;\n\n          // Notify the change.\n          this.dataChange.next(data);\n\n        });\n        break;\n\n    }\n\n\n\n\n\n  }\n\n  public filter(filterText: string) {\n    let filteredTreeData;\n    if (filterText && filterText.trim().length > 0) {\n      // Filter the tree\n      function filter(array: any, text: any) {\n        const getChildren = (result: any[], object: { qualifiedName: string; children: any[]; }) => {\n\n          if (object.qualifiedName.toLowerCase() === text.toLowerCase() || object.qualifiedName.toLowerCase().includes(text.toLowerCase())) {\n            result.push(object);\n            return result;\n          }\n          if (Array.isArray(object.children)) {\n            const children = object.children.reduce(getChildren, []);\n            if (children.length) result.push({ ...object, children });\n          }\n          return result;\n        };\n\n        return array.reduce(getChildren, []);\n      }\n\n      filteredTreeData = filter(this.treeData, filterText);\n    } else {\n      // Return the initial tree\n      filteredTreeData = this.treeData;\n    }\n\n    // Build the tree nodes from Json object. The result is a list of `TodoItemNode` with nested\n    // file node as children.\n    const data = filteredTreeData;\n    // Notify the change.\n    this.dataChange.next(data);\n  }\n}\n\n\n\n\n@Component({\n    selector: 'app-category-tree-dropdown',\n    templateUrl: './category-tree-dropdown.component.html',\n    styleUrls: ['./category-tree-dropdown.component.scss'],\n    standalone: true,\n    imports: [FormsModule, ReactiveFormsModule, MatFormField, MatInput, MatAutocompleteTrigger, MatAutocomplete, MatOption, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodeToggle, MatTreeNodePadding, MatIconButton, MatCheckbox, MatIcon]\n})\nexport class CategoryTreeDropdownComponent implements OnInit  {\n\n  /** Map from flat node to nested node. This helps us finding the nested node to be modified */\n  flatNodeMap = new Map<FlatCategoryNode, CategoryNode>();\n\n  /** Map from nested node to flattened node. This helps us to keep the same object for selection */\n  nestedNodeMap = new Map<CategoryNode, FlatCategoryNode>();\n\n  qualifiedNameToNodeMap = new Map<string, CategoryNode>();\n\n  @Input()\n  selectedCategoryQualifiedNameStr?: string;\n  selectedCategory?: CategoryNode;\n  selectedCategoryName?: string = \"select category\"\n  // treeControl = new NestedTreeControl<CategoryNode>(node => node.children);\n  treeControl!: FlatTreeControl<FlatCategoryNode>\n  dataSource!: MatTreeFlatDataSource<CategoryNode, FlatCategoryNode>;\n  @Input()\n  transactionTypeEnum?: TransactionTypeEnum;\n\n  @Output() selectionChange: EventEmitter<string> = new EventEmitter<string>();\n\n  @ViewChild('formField') formField!: MatFormField;\n  @ViewChild('autoCompleteTrigger') autoCompleteTrigger!: MatAutocompleteTrigger;\n\n\n\n\n  treeFlattener: MatTreeFlattener<CategoryNode, FlatCategoryNode>;\n\n  /** The selection for checklist */\n  checklistSelection = new SelectionModel<FlatCategoryNode>(false /* multiple */);\n  _database?: BackingDatabase;\n\n  constructor(private appService: AppService, private formBuilder: FormBuilder) {\n    this.categoryFormGroup = this.formBuilder.group({\n      queryForm: \"\", searchField: \"\"\n    });\n    this.treeFlattener = new MatTreeFlattener(\n      this.transformer,\n      this.getLevel,\n      this.isExpandable,\n      this.getChildren\n    );\n    this.treeControl = new FlatTreeControl<FlatCategoryNode>(\n      this.getLevel,\n      this.isExpandable\n    );\n    this.dataSource = new MatTreeFlatDataSource(\n      this.treeControl,\n      this.treeFlattener\n    );\n\n  }\n\n\n\n  ngOnInit(): void {\n\n    if (this.selectedCategoryQualifiedNameStr !== undefined) {\n      this.selectedCategory = this.qualifiedNameToNodeMap.get(this.selectedCategoryQualifiedNameStr);\n      if (this.selectedCategory !== undefined) {\n        let flatNode = this.nestedNodeMap.get(this.selectedCategory);\n        if (flatNode !== undefined) {\n          this.toggleSelectionWithoutEmittingChange(flatNode);\n\n        }\n      }\n\n    }\n    if (this.transactionTypeEnum !== undefined) {\n      this._database = new BackingDatabase(this.appService, this.transactionTypeEnum);\n      this._database.dataChange.subscribe(data => {\n        this.dataSource.data = data;\n      });\n    }\n\n\n  }\n\n\n  transformer = (node: CategoryNode, level: number) => {\n    const existingNode = this.nestedNodeMap.get(node);\n    const flatNode =\n      existingNode && existingNode.qualifiedName === node.qualifiedName\n        ? existingNode\n        : new FlatCategoryNode();\n    flatNode.name = node.name;\n    flatNode.nodeId = node.id;\n    flatNode.qualifiedName = node.qualifiedName;\n    flatNode.level = level;\n    flatNode.expandable = (node.children != undefined && node.children.length > 0);\n    flatNode.type = node.type;\n    this.flatNodeMap.set(flatNode, node);\n    this.nestedNodeMap.set(node, flatNode);\n    this.qualifiedNameToNodeMap.set(node.qualifiedName, node);\n    return flatNode;\n  };\n\n  getLevel = (node: FlatCategoryNode) => node.level;\n\n  isExpandable = (node: FlatCategoryNode) => node.expandable;\n\n  getChildren = (node: CategoryNode): CategoryNode[] => node.children;\n\n  hasChild = (_: number, _nodeData: FlatCategoryNode) => _nodeData.expandable;\n\n  hasNoContent = (_: number, _nodeData: FlatCategoryNode) => _nodeData.name === \"\";\n  categoryFormGroup: FormGroup;\n\n  filterChanged(event: Event) {\n\n    let filterText: string = (<HTMLInputElement>(event as InputEvent).target).value\n    // ChecklistDatabase.filter method which actually filters the tree and gives back a tree structure\n    this._database?.filter(filterText);\n    if (filterText) {\n      this.treeControl.expandAll();\n    } else {\n      this.treeControl.collapseAll();\n    }\n  }\n\n  toggleSelection(node: FlatCategoryNode): void {\n    this.checklistSelection.toggle(node);\n    if(this.checklistSelection.isSelected(node)){\n      this.selectedCategory = this.flatNodeMap.get(node);\n      this.selectedCategoryQualifiedNameStr = this.selectedCategory?.qualifiedName;\n      this.selectedCategoryName = this.selectedCategory?.name;\n      this.selectionChange.emit(this.selectedCategoryQualifiedNameStr);\n    } else{\n      this.selectedCategory = NO_CATEGORY;\n      this.selectedCategoryQualifiedNameStr = this.selectedCategory?.qualifiedName;\n      this.selectedCategoryName = \"selecteer categorie\";\n      this.selectionChange.emit(this.selectedCategoryQualifiedNameStr);\n    }\n    this.categoryFormGroup.controls['searchField'].reset();\n    this._database?.filter(\"\")\n    this.autoCompleteTrigger.closePanel();\n\n  }\n  toggleSelectionWithoutEmittingChange(node: FlatCategoryNode): void {\n    this.checklistSelection.toggle(node);\n    if(this.checklistSelection.isSelected(node)){\n      this.selectedCategory = this.flatNodeMap.get(node);\n      this.selectedCategoryQualifiedNameStr = this.selectedCategory?.qualifiedName;\n      this.selectedCategoryName = this.selectedCategory?.name;\n    } else {\n      this.selectedCategory = NO_CATEGORY;\n      this.selectedCategoryQualifiedNameStr = this.selectedCategory?.qualifiedName;\n      this.selectedCategoryName = \"selecteer categorie\";\n    }\n\n  }\n\n\n\n\n\n\n\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./category-tree-dropdown.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 169,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<div [formGroup]=\"categoryFormGroup\">\n  <mat-form-field #formField  style=\"; width: 100%\" >\n      <input #autoCompleteTrigger=\"matAutocompleteTrigger\" formControlName=\"searchField\"  type=\"text\" placeholder=\"{{selectedCategoryQualifiedNameStr}}\" aria-label=\"Number\" matInput\n        (input)=\"filterChanged($event)\" [matAutocomplete]=\"auto\" >\n      <mat-autocomplete autoActiveFirstOption #auto=\"matAutocomplete\" >\n        <mat-option [disabled]=\"true\">Please select an item from below</mat-option>\n        <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" #myMatTree>\n          <mat-tree-node *matTreeNodeDef=\"let node\" matTreeNodeToggle matTreeNodePadding>\n            <button mat-icon-button [disabled]=\"true\"></button>\n            <mat-checkbox style=\"font-weight: lighter; font-size: large\" [checked]=\"checklistSelection.isSelected(node)\"\n              (change)=\"toggleSelection(node)\">{{node.name}}</mat-checkbox>\n          </mat-tree-node>\n          <mat-tree-node *matTreeNodeDef=\"let node; when: hasChild\" matTreeNodePadding >\n            <button mat-icon-button matTreeNodeToggle [attr.aria-label]=\"'toggle ' + node.filename\" >\n              <mat-icon class=\"mat-icon-rtl-mirror\" style=\"font-weight: lighter; font-size: large\">\n                {{treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right'}}\n              </mat-icon>\n            </button>\n            <mat-checkbox style=\"font-weight: lighter; font-size: large\" [checked]=\"checklistSelection.isSelected(node)\"\n              (change)=\"toggleSelection(node)\">\n              {{node.name}}</mat-checkbox>\n          </mat-tree-node>\n        </mat-tree>\n      </mat-autocomplete>\n    </mat-form-field>\n</div>\n\n"
        },
        {
            "name": "CounterpartyAccountNumberSelectionComponent",
            "id": "component-CounterpartyAccountNumberSelectionComponent-18c958a23709612dfbd804e4162d3de2819b9a3941d083762663e07d22845325a715db37df0bea34e95a562c1c6b87b6ee2d92f9cc5f5d552b6e83f878768b89",
            "file": "src/app/counterparty-account-number-selection/counterparty-account-number-selection.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-counterparty-account-number-selection",
            "styleUrls": [
                "./counterparty-account-number-selection.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./counterparty-account-number-selection.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "change",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "EventEmitter<boolean>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "distinctCounterpartAccountNumbers",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Observable<string[]>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "ngSelect",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "NgSelectComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "NgSelectComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "selectedCounterpartAccountNumber",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20
                }
            ],
            "methodsClass": [
                {
                    "name": "accountCounterpartySelectionChanges",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getSelectedCounterpartAccountNumber",
                    "args": [],
                    "optional": false,
                    "returnType": "string | null | undefined",
                    "typeParameters": [],
                    "line": 53,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nwe cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n",
                    "description": "<p>we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround</p>\n",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 1610,
                                "end": 1617,
                                "kind": 80,
                                "id": 0,
                                "flags": 16842752,
                                "transformFlags": 0,
                                "escapedText": "returns"
                            },
                            "comment": ""
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 27,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgSelectComponent",
                    "type": "component"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "AsyncPipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, OnInit, Output, ViewChild} from '@angular/core';\nimport {NgSelectComponent} from '@ng-select/ng-select';\nimport {Observable} from 'rxjs';\nimport {AppService} from '../app.service';\nimport { FormsModule } from '@angular/forms';\nimport { AsyncPipe } from '@angular/common';\n\n@Component({\n    selector: 'app-counterparty-account-number-selection',\n    templateUrl: './counterparty-account-number-selection.component.html',\n    styleUrls: ['./counterparty-account-number-selection.component.scss'],\n    standalone: true,\n    imports: [NgSelectComponent, FormsModule, AsyncPipe]\n})\nexport class CounterpartyAccountNumberSelectionComponent implements OnInit {\n\n  @Output() change: EventEmitter<boolean> = new EventEmitter<boolean>();\n  @ViewChild(NgSelectComponent) ngSelect!:NgSelectComponent;\n\n  selectedCounterpartAccountNumber!: string;\n  distinctCounterpartAccountNumbers!: Observable<string[]>;\n\n  constructor(private appService: AppService) {\n\n  }\n\n  ngOnInit() {\n\n\n    this.appService.selectedBankAccountObservable$.subscribe(bankAccount => {\n      if (bankAccount !== undefined) {\n        this.distinctCounterpartAccountNumbers = this.appService.getDistinctCounterpartyAccounts(bankAccount.accountNumber);\n      }\n\n\n    })\n  }\n\n\n\n  accountCounterpartySelectionChanges() {\n    let sel = this.getSelectedCounterpartAccountNumber()\n    if(sel !== null && sel !== undefined){\n      this.selectedCounterpartAccountNumber = sel;\n      this.change.emit();\n    }\n  }\n\n  /**\n   * we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n   * @returns\n   */\n  private getSelectedCounterpartAccountNumber(): string | null | undefined{\n    let selectedItems = this.ngSelect.selectedItems;\n    if (selectedItems == null){\n      return null;\n    }\n    if( selectedItems.length != 1){\n      throw new Error(\"only 1 item can be selected!\")\n    }\n    let firstValue: string | undefined = selectedItems[0].value;\n    if (firstValue === undefined){\n      throw new Error(\"value must not be undefined!\")\n    }\n\n    return firstValue;\n\n\n\n\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".example-form {\r\n    min-width: 150px;\r\n    max-width: 500px;\r\n    width: 100%;\r\n  }\r\n  \r\n  .example-full-width {\r\n    width: 100%;\r\n  }\r\n  ",
                    "styleUrl": "./counterparty-account-number-selection.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 21,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<ng-select style=\"font-size: larger;\" [items]=\"distinctCounterpartAccountNumbers | async\"\n\n           autofocus\n           [(ngModel)]=\"selectedCounterpartAccountNumber\"\n           (change)=\"accountCounterpartySelectionChanges()\"\n           placeholder=\"select account\"\n           >\n</ng-select>\n"
        },
        {
            "name": "CounterpartyNameSelectionComponent",
            "id": "component-CounterpartyNameSelectionComponent-d9827d13540f67ce8318827e787b66b7f605485df100766496ec5ace5ff11693e264882e2202490bfa26d5c04798c15e35ad4e34c87d33bb4e8397b891324676",
            "file": "src/app/counterparty-name-selection/counterparty-name-selection.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-counterparty-name-selection",
            "styleUrls": [
                "./counterparty-name-selection.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./counterparty-name-selection.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "change",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 17,
                    "type": "EventEmitter<boolean>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "distinctCounterpartyNames",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Observable<string[]>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "ngSelect",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "NgSelectComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "NgSelectComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "selectedCounterpartyName",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 20
                }
            ],
            "methodsClass": [
                {
                    "name": "counterpartySelectionChanges",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 45,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getSelectedCounterparty",
                    "args": [],
                    "optional": false,
                    "returnType": "string | null | undefined",
                    "typeParameters": [],
                    "line": 59,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nwe cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n",
                    "description": "<p>we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround</p>\n",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 1527,
                                "end": 1534,
                                "kind": 80,
                                "id": 0,
                                "flags": 16842752,
                                "transformFlags": 0,
                                "escapedText": "returns"
                            },
                            "comment": ""
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 34,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgSelectComponent",
                    "type": "component"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "AsyncPipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, OnInit, Output, ViewChild} from '@angular/core';\nimport {NgSelectComponent} from '@ng-select/ng-select';\nimport {Observable} from 'rxjs';\nimport {AppService} from '../app.service';\nimport { FormsModule } from '@angular/forms';\nimport { AsyncPipe } from '@angular/common';\n\n@Component({\n    selector: 'app-counterparty-name-selection',\n    templateUrl: './counterparty-name-selection.component.html',\n    styleUrls: ['./counterparty-name-selection.component.scss'],\n    standalone: true,\n    imports: [NgSelectComponent, FormsModule, AsyncPipe]\n})\nexport class CounterpartyNameSelectionComponent implements OnInit {\n\n  @Output() change: EventEmitter<boolean> = new EventEmitter<boolean>();\n  @ViewChild(NgSelectComponent) ngSelect!:NgSelectComponent;\n\n  selectedCounterpartyName!: string;\n  distinctCounterpartyNames!: Observable<string[]>;\n\n\n\n  constructor(private appService: AppService) {\n\n\n\n  }\n\n\n\n\n  ngOnInit() {\n    this.appService.selectedBankAccountObservable$.subscribe(bankAccount => {\n      if (bankAccount !== undefined) {\n        this.distinctCounterpartyNames = this.appService.getDistinctCounterpartyNames(bankAccount.accountNumber);\n      }\n    })\n\n  }\n\n\n\n  counterpartySelectionChanges() {\n\n    let sel = this.getSelectedCounterparty();\n    if(sel !== undefined && sel !== null){\n      this.selectedCounterpartyName = sel;\n      this.change.emit(true);\n    }\n  }\n\n  /**\n   * we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n   * @returns\n   */\n\n  private getSelectedCounterparty(): string | null | undefined{\n    let selectedItems = this.ngSelect.selectedItems;\n    if (selectedItems === null || selectedItems.length ===0){\n      return null;\n    }\n    if( selectedItems.length != 1){\n      throw new Error(\"only 1 item can be selected!\")\n    }\n    let firstValue: string | undefined = selectedItems[0].value;\n    if (firstValue === undefined){\n      throw new Error(\"value must not be undefined!\")\n    }\n\n    return firstValue;\n\n\n\n\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".example-form {\r\n    min-width: 150px;\r\n    max-width: 500px;\r\n    width: 100%;\r\n  }\r\n  \r\n  .example-full-width {\r\n    width: 100%;\r\n  }\r\n  ",
                    "styleUrl": "./counterparty-name-selection.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 21,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<ng-select style=\"font-size: larger;\" [items]=\"distinctCounterpartyNames | async\"\n\n           autofocus\n           [(ngModel)]=\"selectedCounterpartyName\"\n           (change)=\"counterpartySelectionChanges()\"\n           placeholder=\"selecteer naam\"\n           [multiple]=\"false\"\n           >\n</ng-select>\n"
        },
        {
            "name": "CriteriaToolbarComponent",
            "id": "component-CriteriaToolbarComponent-c499f6f625c7b8af99f38723215e8edbb99c0f23e86827b50bea67adfaacff9d8f579a604b3e6ef82ad6bb07e7bfb122b7342a1ffbd90fca94d74db5e643ef59",
            "file": "src/app/criteria-toolbar/criteria-toolbar.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "criteria-toolbar",
            "styleUrls": [
                "./criteria-toolbar.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./criteria-toolbar.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "enableBankAccountSelection",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 24,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "enableCloseButton",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 28,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "enableExpensesRevenueToggle",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 27,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "enableGroupingTypeSelection",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 25,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "enablePeriodSelection",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 26,
                    "type": "boolean",
                    "decorators": []
                }
            ],
            "outputsClass": [
                {
                    "name": "closed",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 29,
                    "type": "EventEmitter"
                },
                {
                    "name": "criteriaChange",
                    "defaultValue": "new EventEmitter<Criteria>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 30,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "bankAccount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccount",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33
                },
                {
                    "name": "currentCriteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Criteria",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 38
                },
                {
                    "name": "endDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "faXmark",
                    "defaultValue": "faXmark",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "grouping",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "GroupingEnum",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 34
                },
                {
                    "name": "startDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Date",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                },
                {
                    "name": "transactionType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionTypeEnum",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 37
                }
            ],
            "methodsClass": [
                {
                    "name": "maybeEmitCriteriaChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 95,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 45,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onBankAccountChange",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 60,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onClickClose",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 48,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onExpensesRevenueChange",
                    "args": [
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 55,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onGroupingChange",
                    "args": [
                        {
                            "name": "grouping",
                            "type": "GroupingEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 65,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "grouping",
                            "type": "GroupingEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onPeriodChange",
                    "args": [
                        {
                            "name": "$event",
                            "type": "Date[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 70,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "$event",
                            "type": "Date[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "requiredFieldsAreSet",
                    "args": [],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 76,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgIf"
                },
                {
                    "name": "BankAccountSelectionComponent",
                    "type": "component"
                },
                {
                    "name": "GroupingTypeSelectionComponent",
                    "type": "component"
                },
                {
                    "name": "PeriodSelectionComponent",
                    "type": "component"
                },
                {
                    "name": "ExpensesRevenueToggleComponent",
                    "type": "component"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "FaIconComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, Input, OnInit, Output} from '@angular/core';\nimport {faXmark} from \"@fortawesome/free-solid-svg-icons\";\nimport {anyIsUndefinedOrEmpty} from \"../model\";\nimport {Criteria} from \"../model/criteria.model\";\nimport {BankAccount, GroupingEnum, TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\nimport {NgIf} from '@angular/common';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {GroupingTypeSelectionComponent} from '../grouping-type-selection/grouping-type-selection.component';\nimport {PeriodSelectionComponent} from '../period-selection/period-selection.component';\nimport {ExpensesRevenueToggleComponent} from '../expenses-revenue-toggle/expenses-revenue-toggle.component';\nimport {MatButton} from '@angular/material/button';\nimport {FaIconComponent} from '@fortawesome/angular-fontawesome';\n\n\n@Component({\n    selector: 'criteria-toolbar',\n    templateUrl: './criteria-toolbar.component.html',\n    styleUrls: ['./criteria-toolbar.component.scss'],\n    standalone: true,\n    imports: [NgIf, BankAccountSelectionComponent, GroupingTypeSelectionComponent, PeriodSelectionComponent, ExpensesRevenueToggleComponent, MatButton, FaIconComponent]\n})\nexport class CriteriaToolbarComponent implements OnInit {\n\n    @Input() enableBankAccountSelection: boolean = true;\n    @Input() enableGroupingTypeSelection: boolean = true;\n    @Input() enablePeriodSelection: boolean = true;\n    @Input() enableExpensesRevenueToggle: boolean = true;\n    @Input() enableCloseButton: boolean = true;\n    @Output() closed = new EventEmitter<boolean>();\n    @Output() criteriaChange = new EventEmitter<Criteria>();\n\n\n    bankAccount!: BankAccount;\n    grouping!: GroupingEnum ;\n    startDate!: Date;\n    endDate!: Date;\n    transactionType!: TransactionTypeEnum;\n    currentCriteria!: Criteria;\n\n\n    constructor() {\n\n    }\n\n    ngOnInit(): void {\n    }\n\n    onClickClose() {\n        this.closed.emit(true);\n    }\n\n    protected readonly faXmark = faXmark;\n\n\n    onExpensesRevenueChange(transactionType: TransactionTypeEnum) {\n        this.transactionType = transactionType;\n        this.maybeEmitCriteriaChange();\n    }\n\n    onBankAccountChange(bankAccount: BankAccount) {\n        this.bankAccount = bankAccount;\n        this.maybeEmitCriteriaChange();\n    }\n\n    onGroupingChange(grouping: GroupingEnum) {\n        this.grouping = grouping;\n        this.maybeEmitCriteriaChange();\n    }\n\n    onPeriodChange($event: Date[]) {\n        this.startDate = $event[0];\n        this.endDate = $event[1];\n        this.maybeEmitCriteriaChange();\n    }\n\n    requiredFieldsAreSet(): boolean {\n        if (this.enableExpensesRevenueToggle && anyIsUndefinedOrEmpty(this.transactionType)) {\n            return false;\n        }\n        if (this.enableBankAccountSelection && anyIsUndefinedOrEmpty(this.bankAccount)) {\n            return false;\n        }\n        if (this.enableGroupingTypeSelection && anyIsUndefinedOrEmpty(this.grouping)) {\n            return false;\n        }\n        if (this.enablePeriodSelection && anyIsUndefinedOrEmpty(this.startDate, this.endDate)) {\n            return false;\n        }\n\n        return true;\n\n    }\n\n\n    maybeEmitCriteriaChange() {\n        if (!this.requiredFieldsAreSet()) {\n            return;\n        }\n        let criteria = new Criteria(this.bankAccount, this.grouping, this.startDate, this.endDate,\n            this.transactionType);\n        if (!this.currentCriteria) {\n            this.currentCriteria = criteria;\n            this.criteriaChange.emit(this.currentCriteria);\n\n        }\n        else if (!this.currentCriteria.equals(criteria)) {\n            this.currentCriteria = criteria;\n            this.criteriaChange.emit(this.currentCriteria);\n\n        }\n    }\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".button-container {\r\n  display: flex;\r\n  justify-content: flex-end;\r\n}\r\n\r\n.toolbar-container {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: normal;\r\n}",
                    "styleUrl": "./criteria-toolbar.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 38
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"toolbar-container\">\n    <div style=\"display: flex; justify-content: flex-start\">\n        <bank-account-selection (change)=\"onBankAccountChange($event)\" *ngIf=\"enableBankAccountSelection\" style=\"width: fit-content;\"></bank-account-selection>\n        <grouping-type-selection (change)=\"onGroupingChange($event)\" *ngIf=\"enableGroupingTypeSelection\"\n                                 style=\"width: fit-content\"></grouping-type-selection>\n        <period-selection (change)=\"onPeriodChange($event)\" *ngIf=\"enablePeriodSelection\"></period-selection>\n        <expenses-revenue-toggle (change)=\"onExpensesRevenueChange($event)\" *ngIf=\"enableExpensesRevenueToggle\"></expenses-revenue-toggle>\n    </div>\n    <div class=\"button-container\" style=\"width: 50px; height: 50px; \">\n        <button (click)=\"onClickClose()\"  mat-raised-button>\n            <fa-icon size=\"lg\" [icon]=\"faXmark\" [fixedWidth]=\"true\"></fa-icon>\n        </button>\n    </div>\n</div>"
        },
        {
            "name": "ErrorDialogComponent",
            "id": "component-ErrorDialogComponent-91e290881abd29512d826fa6a5ce069e976a0fd9cb9e3b3e00ffb90fc8399db3acdb101e86431eac5c1eeb45599a8a16e66e418313344cbd0a2f8fa2338757ab",
            "file": "src/app/error-dialog/error-dialog.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-error-dialog",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./error-dialog.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "decorators": [
                        {
                            "name": "Inject",
                            "stringifiedArguments": "MAT_DIALOG_DATA"
                        }
                    ],
                    "modifierKind": [
                        170,
                        125
                    ]
                }
            ],
            "methodsClass": [],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatDialogTitle"
                },
                {
                    "name": "CdkScrollable"
                },
                {
                    "name": "MatDialogContent"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatLabel"
                },
                {
                    "name": "MatDialogActions"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "MatDialogClose"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, Inject } from '@angular/core';\nimport { MAT_DIALOG_DATA, MatDialogTitle, MatDialogContent, MatDialogActions, MatDialogClose } from '@angular/material/dialog';\nimport { CdkScrollable } from '@angular/cdk/scrolling';\nimport { NgIf } from '@angular/common';\nimport { MatLabel } from '@angular/material/form-field';\nimport { MatButton } from '@angular/material/button';\n\n@Component({\n    selector: 'app-error-dialog',\n    templateUrl: './error-dialog.component.html',\n    standalone: true,\n    imports: [\n        MatDialogTitle,\n        CdkScrollable,\n        MatDialogContent,\n        NgIf,\n        MatLabel,\n        MatDialogActions,\n        MatButton,\n        MatDialogClose,\n    ],\n})\nexport class ErrorDialogComponent {\n  constructor(@Inject(MAT_DIALOG_DATA) public data: { message: string, reason: string }) {}\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "literal type",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 23,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "literal type",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "templateData": "<h1 mat-dialog-title>Foutmelding</h1>\n<div mat-dialog-content>\n  <p style=\"font-weight:bold; padding: 10px\">{{ data.message }}</p>\n  <div *ngIf=\"data.reason !==undefined\" style=\"font-style: italic; padding: 10px\">\n    <mat-label>Reden:</mat-label><span style=\"font-style: italic; padding-left: 2px\">{{ data.reason}}</span>\n  </div>\n\n</div>\n<div mat-dialog-actions>\n  <button mat-button [mat-dialog-close]=\"'OK'\">Close</button>\n</div>\n"
        },
        {
            "name": "ExpensesByCategoryComponent",
            "id": "component-ExpensesByCategoryComponent-1bed2a97698f9710c89620097801efb4bdf14876f571ba4d74f4d128fc56bb1f3819bc5ed09227e78b69efd21800d59974f296557b0e4a20c2aacf89fc8191dd",
            "file": "src/app/uitgaven-per-categorie/expenses-by-category.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-expenses-by-category",
            "styleUrls": [
                "./expenses-by-category.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./expenses-by-category.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 13,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n    selector: 'app-expenses-by-category',\n    templateUrl: './expenses-by-category.component.html',\n    styleUrls: ['./expenses-by-category.component.scss'],\n    standalone: true\n})\nexport class ExpensesByCategoryComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./expenses-by-category.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 9
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<p>\n  uitgaven-per-categorie works!\n</p>\n"
        },
        {
            "name": "ExpensesRevenueComponent",
            "id": "component-ExpensesRevenueComponent-5256cd95f9195ae556ec145cb0ba1d125be407c21a962f8dde2212a991d9380b3593d1d383babbeddb30ce8c56d09b9e30c51138ce57a4417c55e21f739ea1a1",
            "file": "src/app/revenue-expenses/revenue-expenses.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "expenses-revenue",
            "styleUrls": [
                "./revenue-expenses.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./revenue-expenses.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "criteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 45,
                    "type": "Criteria",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "barIsSelected",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36
                },
                {
                    "name": "chartOptions",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "dataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTableDataSource<ExpensesAndRevenueForPeriod>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 32
                },
                {
                    "name": "datatIsLoaded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "displayedColumns",
                    "defaultValue": "[\"period\", \"revenue\", \"expenses\", \"balance\"]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33
                },
                {
                    "name": "paginator",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatPaginator",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatPaginator"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "plugins",
                    "defaultValue": "[ChartDataLabels]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "sort",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatSort",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatSort"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "table",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTable<ExpensesAndRevenueForPeriod>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 31,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatTable"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "tableIsHidden",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35
                }
            ],
            "methodsClass": [
                {
                    "name": "doQuery",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 54,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getToggleTableMessage",
                    "args": [],
                    "optional": false,
                    "returnType": "\"verberg tabel\" | \"toon tabel\"",
                    "typeParameters": [],
                    "line": 186,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleChart",
                    "args": [
                        {
                            "name": "content",
                            "type": "Array<ExpensesAndRevenueForPeriod>",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 84,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "content",
                            "type": "Array<ExpensesAndRevenueForPeriod>",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initChartOptions",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 149,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 241,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 237,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "stringToDate",
                    "args": [
                        {
                            "name": "string",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Date",
                    "typeParameters": [],
                    "line": 224,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "string",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toggleTable",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 181,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "transformChartDataToPrimeNgFormat",
                    "args": [
                        {
                            "name": "chartData",
                            "type": "any[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 113,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "chartData",
                            "type": "any[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgIf"
                },
                {
                    "name": "ChartModule",
                    "type": "module"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "NgClass"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                },
                {
                    "name": "DecimalPipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, Input, OnChanges, OnInit, SimpleChanges, ViewChild} from '@angular/core';\nimport {MatPaginator} from \"@angular/material/paginator\";\nimport {MatSort} from \"@angular/material/sort\";\nimport { MatTable, MatTableDataSource, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from \"@angular/material/table\";\nimport ChartDataLabels from 'chartjs-plugin-datalabels';\nimport {parse} from 'date-fns';\nimport {isNaN} from \"lodash\";\nimport {AppService} from \"../app.service\";\nimport {Criteria} from \"../model/criteria.model\";\nimport {ExpensesRecurrenceEnum, RevenueExpensesQuery, TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\nimport {RevenueRecurrenceEnum} from \"@daanvdn/budget-assistant-client\";\nimport {ExpensesAndRevenueForPeriod} from \"@daanvdn/budget-assistant-client\";\nimport { NgIf, NgClass, DecimalPipe } from '@angular/common';\nimport { ChartModule } from 'primeng/chart';\nimport { MatButton } from '@angular/material/button';\n\n@Component({\n    selector: 'expenses-revenue',\n    templateUrl: './revenue-expenses.component.html',\n    styleUrls: ['./revenue-expenses.component.scss'],\n    animations: [],\n    standalone: true,\n    imports: [NgIf, ChartModule, MatButton, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, NgClass, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, DecimalPipe]\n})\nexport class ExpensesRevenueComponent  implements OnInit, OnChanges {\n\n\n  //table stuff\n  @ViewChild(MatPaginator) paginator!: MatPaginator;\n  @ViewChild(MatSort) sort!: MatSort;\n  @ViewChild(MatTable) table!: MatTable<ExpensesAndRevenueForPeriod>;\n  dataSource!: MatTableDataSource<ExpensesAndRevenueForPeriod>;\n  displayedColumns = [\"period\", \"revenue\", \"expenses\", \"balance\"];\n\n  tableIsHidden: boolean = true;\n  barIsSelected: boolean = false;\n\n\n  //chart stuff\n  datatIsLoaded: Boolean = false;\n\n  data: any;\n  chartOptions: any;\n  plugins: any[] = [ChartDataLabels];\n  @Input() criteria!: Criteria;\n\n  constructor(private appService: AppService) {\n\n\n  }\n\n\n\n  doQuery(): void {\n    if (!this.criteria) {\n      throw new Error(\"Query parameters are not initialized!\");\n    }\n    this.datatIsLoaded = false;\n    let query: RevenueExpensesQuery = {\n      accountNumber: this.criteria.bankAccount.accountNumber,\n      grouping: this.criteria.grouping,\n      transactionType: TransactionTypeEnum.BOTH,\n      start: JSON.stringify(this.criteria.startDate),\n      end: JSON.stringify(this.criteria.endDate),\n      expensesRecurrence: ExpensesRecurrenceEnum.BOTH,\n      revenueRecurrence: RevenueRecurrenceEnum.BOTH\n\n    };\n\n\n    this.appService.getRevenueAndExpensesByYear(query).subscribe(result => {\n      let content: Array<ExpensesAndRevenueForPeriod> = result.content;\n      this.dataSource = new MatTableDataSource(content);\n      this.dataSource.sort = this.sort;\n      this.dataSource.paginator = this.paginator;\n      // this.table.dataSource = this.dataSource;\n      this.handleChart(content);\n      this.datatIsLoaded = true;\n    });\n\n\n  }\n\n  handleChart(content: Array<ExpensesAndRevenueForPeriod>) {\n\n    let chartData: any[] = []\n\n\n    this.datatIsLoaded = content.length > 0;\n    content.forEach(item => {\n      let entry = {\n        \"name\": item.period.value, \"series\": [{\n          \"name\": \"inkomsten\", \"value\": item.revenue, \"extra\": item\n\n        }, {\n          \"name\": \"uitgaven\", \"value\": Math.abs(item.expenses), \"extra\": item\n\n        }]\n\n      }\n\n      chartData.push(entry)\n    })\n\n    if (chartData.length > 0) {\n      this.data = this.transformChartDataToPrimeNgFormat(chartData);\n      this.chartOptions = this.initChartOptions();\n    }\n\n\n  }\n\n  transformChartDataToPrimeNgFormat(chartData: any[]):\n      any {\n    let transformedData: any = {\n      labels: [],\n      datasets: [\n        {\n          type: 'bar',\n          label: 'Inkomsten',\n          backgroundColor: '#66BB6A',\n          data: []\n        },\n        {\n          type: 'bar',\n          label: 'Uitgaven',\n          backgroundColor: '#EF5350',\n          data: []\n        }\n      ]\n    };\n\n    chartData.forEach(item => {\n      transformedData.labels.push(item.name);\n      item.series.forEach((seriesItem: any) => {\n        if (seriesItem.name === 'inkomsten') {\n          transformedData.datasets[0].data.push(seriesItem.value);\n        }\n        else if (seriesItem.name === 'uitgaven') {\n          transformedData.datasets[1].data.push(seriesItem.value);\n        }\n      });\n    });\n\n    return transformedData;\n  }\n\n\n  initChartOptions(): any {\n    return {\n      plugins: {\n        datalabels: {\n          display: true,\n          align: 'end',\n          anchor: 'end',\n          formatter: function (value:any, context:any) { return Math.round(value) || null;  }\n        }\n      },\n      indexAxis: 'y',\n      tooltips: {\n        mode: 'index',\n        intersect: false\n      },\n      responsive: true,\n      scales: {\n        x: {\n          stacked: false\n\n        },\n        y: {\n          stacked: false\n\n\n        }\n      }\n    };\n\n  }\n\n\n  toggleTable() {\n    this.tableIsHidden = !this.tableIsHidden;\n  }\n\n\n  getToggleTableMessage() {\n\n    if (!this.tableIsHidden) {\n      return \"verberg tabel\";\n    }\n\n    return \"toon tabel\"\n\n  }\n\n  /*handleBarIsSelected($event: any): void {\n    //check if event is an object\n    if (typeof $event !== 'object'\n    ) {\n      return;\n    }\n\n    let period: Period = $event.extra.period;\n    let start = this.stringToDate(period.start);\n    let end = this.stringToDate(period.end);\n\n\n    let query: RevenueExpensesQuery = {\n      accountNumber: this.criteria.bankAccount.accountNumber,\n      grouping: this.criteria.grouping,\n      transactionType: TransactionType.BOTH,\n      start: start,\n      end: end,\n      expensesRecurrence: 'both',\n      revenueRecurrence: 'both'\n    }\n\n    this.appService.setCategoryQueryForSelectedPeriod$(query);\n    this.barIsSelected = true;\n\n\n  }*/\n\n  private stringToDate(string: string): Date {\n\n    const dateObject = parse(string, 'yyyy-MM-dd', new Date());\n\n    if (!isNaN(dateObject.getTime())) {\n      return dateObject;\n    }\n    else {\n      throw new Error(\"Invalid error\")\n    }\n\n  }\n\n  ngOnInit(): void {\n\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n\n    if (changes['criteria']?.currentValue) {\n      this.doQuery();\n    }\n\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".full-width-table {\r\n  width: 100%;\r\n  border-collapse: separate;\r\n  border-spacing: 10px 0;\r\n\r\n}\r\n.course-thumbnail {\r\n    width: 150px;\r\n    margin: 20px auto 0 auto;\r\n    display: block;\r\n}\r\n.duration-cell {\r\n    text-align: center;\r\n}\r\n\r\n.duration-cell mat-icon {\r\n    display: inline-block;\r\n    vertical-align: middle;\r\n    font-size: 20px;\r\n}\r\n\r\n.spinner-container {\r\n    height: 360px;\r\n    width: 390px;\r\n    position: fixed;\r\n}\r\n\r\n\r\n\r\n/* TODO(mdc-migration): The following rule targets internal classes of paginator that may no longer apply for the MDC version. */\nmat-paginator {\r\n  width: 400px;\r\n  margin-bottom: 200px;\r\n}\r\n\r\n.spinner-container mat-spinner {\r\n    margin: 130px auto 0 auto;\r\n}\r\n\r\n.rotate-label {\r\n  display: inline-block;\r\n  transform: rotate(-45deg);\r\n  white-space: nowrap;\r\n}\r\n\r\n.move-legend-left {\r\n  .ngx-charts-legend-wrapper {\r\n    margin-left: 5px;\r\n  }\r\n}\r\n\r\n\r\n\r\n.color-red {\r\n  color: red;\r\n\r\n}\r\n\r\n.color-green {\r\n  color: green;\r\n\r\n}\r\n\r\n",
                    "styleUrl": "./revenue-expenses.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 45,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<div *ngIf=\"datatIsLoaded; else noDataFound\">\n    <div style=\"display: flex; justify-content: space-between; overflow-x: auto; padding: 16px; margin: 20px\">\n        <div style=\"width: 900px; height: fit-content\">\n            <p-chart type=\"bar\" [data]=\"data\" [options]=\"chartOptions\" [plugins]=\"plugins\"></p-chart>\n        </div>\n        <button mat-raised-button style=\"max-width: 120px; max-height: 50px; margin-right:5px\"\n                (click)=\"toggleTable()\"> {{ this.getToggleTableMessage() }}\n        </button>\n    </div>\n    <div *ngIf=\"!tableIsHidden\"\n         style=\"overflow: hidden;  overflow-y: auto;padding: 16px; margin: 20px; width: 900px;\">\n        <table mat-table [dataSource]=\"dataSource\" class=\"mat-z8\" style=\"width: 100%; border: black 1px solid\">\n            <ng-container matColumnDef=\"period\">\n                <th mat-header-cell *matHeaderCellDef style=\"\">periode</th>\n                <td mat-cell *matCellDef=\"let item\">{{ item.period.value }}</td>\n            </ng-container>\n            <ng-container matColumnDef=\"revenue\">\n                <th mat-header-cell *matHeaderCellDef style=\"\">inkomsten</th>\n                <td mat-cell *matCellDef=\"let item\">{{ item.revenue | number:'1.1-2' }}</td>\n            </ng-container>\n            <ng-container matColumnDef=\"expenses\">\n                <th mat-header-cell *matHeaderCellDef style=\"\">uitgaven</th>\n                <td mat-cell *matCellDef=\"let item\">{{ item.expenses | number:'1.1-2' }}</td>\n            </ng-container>\n\n            <ng-container matColumnDef=\"balance\">\n                <th mat-header-cell *matHeaderCellDef style=\"\">saldo</th>\n                <td mat-cell [ngClass]=\"item.balance < 0 ? 'color-red' : 'color-green'\"\n                    *matCellDef=\"let item\">{{ item.balance | number:'1.1-2' }}\n                </td>\n            </ng-container>\n\n            <tr mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"></tr>\n            <tr mat-row *matRowDef=\"let row; columns: displayedColumns\"></tr>\n        </table>\n    </div>\n</div>\n<ng-template #noDataFound>\n    <div [hidden]=\"datatIsLoaded\"\n         style=\"font-weight: bold; padding-left: 25px;padding-top: 25px; text-align: center\">\n    Geen data gevonden die beantwoordt aan de zoekcriteria!<br>Verander rekening, periode of andere criteria\n  </div>\n</ng-template>\n\n\n"
        },
        {
            "name": "ExpensesRevenueToggleComponent",
            "id": "component-ExpensesRevenueToggleComponent-21e795b84813975c7feae1db3246bd05da6b39d632e9ff038e1d2a1fda363527c7d8f54b046d5e9b86e085141319186b960e87d45c1b7924784b66b14d64a20c",
            "file": "src/app/expenses-revenue-toggle/expenses-revenue-toggle.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "expenses-revenue-toggle",
            "styleUrls": [
                "./expenses-revenue-toggle.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./expenses-revenue-toggle.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "change",
                    "defaultValue": "new EventEmitter<TransactionTypeEnum>(true)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 15,
                    "type": "EventEmitter<TransactionTypeEnum>"
                }
            ],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 20,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onToggleChange",
                    "args": [
                        {
                            "name": "$event",
                            "type": "MatButtonToggleChange",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 24,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "$event",
                            "type": "MatButtonToggleChange",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatButtonToggleGroup"
                },
                {
                    "name": "MatButtonToggle"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, OnInit, Output} from '@angular/core';\nimport { MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggle } from \"@angular/material/button-toggle\";\nimport {AppService} from \"../app.service\";\nimport {TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\n\n@Component({\n    selector: 'expenses-revenue-toggle',\n    templateUrl: './expenses-revenue-toggle.component.html',\n    styleUrls: ['./expenses-revenue-toggle.component.scss'],\n    standalone: true,\n    imports: [MatButtonToggleGroup, MatButtonToggle]\n})\nexport class ExpensesRevenueToggleComponent implements OnInit {\n\n  @Output() change: EventEmitter<TransactionTypeEnum> = new EventEmitter<TransactionTypeEnum>(true);\n\n\n  constructor(private appService: AppService) { }\n\n  ngOnInit(): void {\n    this.change.emit(TransactionTypeEnum.EXPENSES);\n    this.appService.setTransactionType(TransactionTypeEnum.EXPENSES);\n  }\n  onToggleChange($event: MatButtonToggleChange) {\n    const value = $event.value;\n    if (value === \"expenses\") {\n      this.change.emit(TransactionTypeEnum.EXPENSES);\n      this.appService.setTransactionType(TransactionTypeEnum.EXPENSES);\n    }\n    else if (value === \"revenue\") {\n      this.change.emit(TransactionTypeEnum.REVENUE);\n      this.appService.setTransactionType(TransactionTypeEnum.REVENUE);\n    }\n    else {\n      throw new Error(\"Unknown value \" + value);\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./expenses-revenue-toggle.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 15,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"inline_block\" style=\"padding-top: 1px\">\n    <mat-button-toggle-group (change)=\"onToggleChange($event)\" name=\"fontStyle\" aria-label=\"Font Style\">\n        <mat-button-toggle style=\"border: grey solid 1px\" [checked]=\"true\" value=\"expenses\">Expenses</mat-button-toggle>\n        <mat-button-toggle style=\"border: grey solid 1px\" value=\"revenue\">Revenue</mat-button-toggle>\n    </mat-button-toggle-group>\n</div>\n"
        },
        {
            "name": "FileUploaderComponent",
            "id": "component-FileUploaderComponent-d0995f44478ef75be621ced0e2591d62c7e87d0349b883179de6b0f71e4372e4d256f350b80bf1ee2afafe333df70bc8de2151358202926a6d1e1e699987fae4",
            "file": "src/app/file-uploader/file-uploader.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "file-uploader, [file-uploader]",
            "styleUrls": [
                "./file-uploader.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "file-uploader.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "onCompleteItem",
                    "defaultValue": "new EventEmitter()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "EventEmitter"
                }
            ],
            "propertiesClass": [
                {
                    "name": "completeItem",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33
                },
                {
                    "name": "fileInput",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 23,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'fileInput'"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "queue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Observable<FileQueueObject[]>",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 24
                },
                {
                    "name": "uploader",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FileUploaderService",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "addToQueue",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 37,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 28,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatDialogTitle"
                },
                {
                    "name": "CdkScrollable"
                },
                {
                    "name": "MatDialogContent"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "AsyncPipe",
                    "type": "pipe"
                },
                {
                    "name": "DecimalPipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, EventEmitter, OnInit, Output, ViewChild } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { FileQueueObject, FileUploaderService } from '../file-uploader.service';\nimport { MatDialogTitle, MatDialogContent } from '@angular/material/dialog';\nimport { CdkScrollable } from '@angular/cdk/scrolling';\nimport { NgFor, NgIf, AsyncPipe, DecimalPipe } from '@angular/common';\n\n\n\n\n@Component({\n    selector: 'file-uploader, [file-uploader]',\n    templateUrl: 'file-uploader.component.html',\n    styleUrls: ['./file-uploader.component.scss'],\n    standalone: true,\n    imports: [MatDialogTitle, CdkScrollable, MatDialogContent, NgFor, NgIf, AsyncPipe, DecimalPipe]\n})\n\nexport class FileUploaderComponent implements OnInit {\n\n  @Output() onCompleteItem = new EventEmitter();\n\n  @ViewChild('fileInput') fileInput?: { nativeElement: any; };\n  queue?: Observable<FileQueueObject[]>;\n\n  constructor(public uploader: FileUploaderService) { }\n\n  ngOnInit() {\n    this.queue = this.uploader.queue;\n    this.uploader.onCompleteItem = this.completeItem;\n  }\n\n  completeItem = (item: FileQueueObject, response: any) => {\n    this.onCompleteItem.emit({ item, response });\n  }\n\n  addToQueue() {\n    const fileBrowser = this.fileInput?.nativeElement;\n    this.uploader.addToQueue(fileBrowser.files);\n  }\n}",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".tag {\r\n    border-radius: 50%;\r\n    height: 15px;\r\n    width: 15px;\r\n    display: inline-block;\r\n  }\r\n  \r\n  .tag-default {\r\n    background-color: gray;\r\n  }\r\n  \r\n  .tag-success {\r\n    background-color: green;\r\n  }\r\n  \r\n  .tag-warning {\r\n    background-color: orange;\r\n  }\r\n  \r\n  .tag-danger {\r\n    background-color: red;\r\n  }",
                    "styleUrl": "./file-uploader.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "uploader",
                        "type": "FileUploaderService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 24,
                "jsdoctags": [
                    {
                        "name": "uploader",
                        "type": "FileUploaderService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<h1 mat-dialog-title>Uploading items</h1>\n<div mat-dialog-content class=\"row\">\n\t<div class=\"col-md-3\">\n\t\t<h3>Select files</h3>\n\t\t<input type=\"file\" #fileInput multiple (change)=\"addToQueue()\" />\n\t</div>\n\n\t<div class=\"col-md-9\">\n\t\t<h3>Upload queue</h3>\n\t\t<table class=\"table-headed table-striped\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th class=\"text-left\">Name</th>\n\t\t\t\t\t<th class=\"text-right\">Size</th>\n\t\t\t\t\t<th class=\"text-left\">Progress</th>\n\t\t\t\t\t<th class=\"text-left\">Status</th>\n\t\t\t\t\t<th class=\"text-right\">Actions</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t<tr *ngFor=\"let item of queue | async\">\n\t\t\t\t\t<td>{{ item?.file?.name }}</td>\n\t\t\t\t\t<td class=\"text-right\">{{ item?.file?.size/1024/1024 | number:'.2' }} MB</td>\n\t\t\t\t\t<td>{{ item.progress + ' %' }}</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<span *ngIf=\"item.isPending()\" class=\"tag tag-default\"></span>\n\t\t\t\t\t\t<span *ngIf=\"item.isSuccess()\" class=\"tag tag-success\"></span>\n\t\t\t\t\t\t<span *ngIf=\"item.inProgress()\" class=\"tag tag-warning\"></span>\n\t\t\t\t\t\t<span *ngIf=\"item.isError()\" class=\"tag tag-danger\"></span>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td class=\"text-right\">\n\t\t\t\t\t\t<a tooltip=\"Upload file\" (click)=\"item.upload()\" *ngIf=\"item.isUploadable()\">\n\t\t\t\t\t\t\t<i class=\"fa fa-upload\"></i>\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<a tooltip=\"Cancel upload\" (click)=\"item.cancel()\" *ngIf=\"item.inProgress()\">\n\t\t\t\t\t\t\t<i class=\"fa fa-times-circle\"></i>\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<a tooltip=\"Remove from queue\" (click)=\"item.remove()\" *ngIf=\"!item.inProgress()\">\n\t\t\t\t\t\t\t<i class=\"fa fa-trash\"></i>\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\t\t<div>\n\t\t\t<a class=\"button\" (click)=\"uploader.clearQueue()\">Clear queue</a>\n\t\t\t<a class=\"button button-primary\" (click)=\"uploader.uploadAll()\">Upload all</a>\n\t\t</div>\n\t</div>\n\n</div>"
        },
        {
            "name": "FiltersComponent",
            "id": "component-FiltersComponent-9e17116a133eb210925dcc890127c847c0354fd226e1ef726cca053e94cf7ddee3bb4260cdbbbef15f6d06371856420bc709ea7f13868304023501247319f9f1",
            "file": "src/app/filters/filters.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": "{ provide: DateAdapter, useClass: PickDateAdapter }"
                },
                {
                    "name": "{ provide: MAT_DATE_FORMATS, useValue: PICK_FORMATS }"
                }
            ],
            "selector": "app-filters",
            "styleUrls": [
                "./filters.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./filters.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "bankAccountFormFieldGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 51
                },
                {
                    "name": "bankAccounts",
                    "defaultValue": "[]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccount[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54
                },
                {
                    "name": "dateClass",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 118
                },
                {
                    "name": "destroy$",
                    "defaultValue": "new Subject<void>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 74,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "endDate",
                    "defaultValue": "new FormControl<Date | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 73
                },
                {
                    "name": "groupingTypes",
                    "defaultValue": "new Map<string, GroupingEnum>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | GroupingEnum>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "groupingTypesFormFieldGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "groupingTypeStringValues",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                },
                {
                    "name": "startDate",
                    "defaultValue": "new FormControl<Date | null>(null)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 72
                },
                {
                    "name": "startEndDateFormFieldGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56
                },
                {
                    "name": "startEndDateShortCuts",
                    "defaultValue": "new Map<string, StartEndDateShortcut>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | StartEndDateShortcut>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 68
                },
                {
                    "name": "startEndDateShortCutStringValues",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 69
                },
                {
                    "name": "transactionTypeFormFieldGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64
                },
                {
                    "name": "transactionTypes",
                    "defaultValue": "new Map<string, TransactionTypeEnum>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | TransactionTypeEnum>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 65
                },
                {
                    "name": "transactionTypeStringValues",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 66
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnDestroy",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 174,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 115,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onBankAccountChange",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 124,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onGroupingChange",
                    "args": [
                        {
                            "name": "groupingStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 149,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "groupingStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onPeriodShortCutClick",
                    "args": [
                        {
                            "name": "periodStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 158,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "periodStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onTransactionTypeChange",
                    "args": [
                        {
                            "name": "transactionTypeStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 140,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transactionTypeStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setStartAndEndDate",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 131,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatLabel"
                },
                {
                    "name": "MatSelect"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatOption"
                },
                {
                    "name": "MatDateRangeInput"
                },
                {
                    "name": "MatStartDate"
                },
                {
                    "name": "MatEndDate"
                },
                {
                    "name": "MatHint"
                },
                {
                    "name": "MatDatepickerToggle"
                },
                {
                    "name": "MatSuffix"
                },
                {
                    "name": "MatDateRangePicker"
                },
                {
                    "name": "MatButton"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport { FormBuilder, FormControl, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport {AppService} from '../app.service';\nimport {StartEndDateShortcut} from '../model';\n\nimport { DateAdapter, MAT_DATE_FORMATS, NativeDateAdapter, MatOption } from '@angular/material/core';\nimport { formatDate, NgFor } from '@angular/common';\nimport {Subject, takeUntil} from \"rxjs\";\nimport {BankAccount, GroupingEnum, TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\nimport { MatFormField, MatLabel, MatHint, MatSuffix } from '@angular/material/form-field';\nimport { MatSelect } from '@angular/material/select';\nimport { MatDateRangeInput, MatStartDate, MatEndDate, MatDatepickerToggle, MatDateRangePicker } from '@angular/material/datepicker';\nimport { MatButton } from '@angular/material/button';\n\nexport const PICK_FORMATS = {\n  parse: {dateInput: {month: 'short', year: 'numeric', day: 'numeric'}},\n  display: {\n    dateInput: 'input',\n    monthYearLabel: {year: 'numeric', month: 'short'},\n    dateA11yLabel: {year: 'numeric', month: 'long', day: 'numeric'},\n    monthYearA11yLabel: {year: 'numeric', month: 'long'}\n  }\n};\n\nclass PickDateAdapter extends NativeDateAdapter {\n\n  override format(date: Date, displayFormat: Object): string {\n    if (displayFormat === 'input') {\n      return formatDate(date, 'dd-MMM-yyyy', this.locale);\n\n    } else {\n      return date.toDateString();\n    }\n  }\n}\n\n@Component({\n    selector: 'app-filters',\n    templateUrl: './filters.component.html',\n    styleUrls: ['./filters.component.scss'],\n    providers: [\n        { provide: DateAdapter, useClass: PickDateAdapter },\n        { provide: MAT_DATE_FORMATS, useValue: PICK_FORMATS }\n    ],\n    standalone: true,\n    imports: [FormsModule, ReactiveFormsModule, MatFormField, MatLabel, MatSelect, NgFor, MatOption, MatDateRangeInput, MatStartDate, MatEndDate, MatHint, MatDatepickerToggle, MatSuffix, MatDateRangePicker, MatButton]\n})\nexport class FiltersComponent implements OnInit {\n\n\n  bankAccountFormFieldGroup: FormGroup;\n\n\n  bankAccounts: BankAccount[] = [];\n\n  startEndDateFormFieldGroup: FormGroup;\n\n  groupingTypesFormFieldGroup: FormGroup;\n\n  groupingTypes: Map<string, GroupingEnum> = new Map<string, GroupingEnum>();\n  groupingTypeStringValues: string[];\n\n\n  transactionTypeFormFieldGroup: FormGroup;\n  transactionTypes: Map<string, TransactionTypeEnum> = new Map<string, TransactionTypeEnum>();\n  transactionTypeStringValues: string[];\n\n  startEndDateShortCuts: Map<string, StartEndDateShortcut> = new Map<string, StartEndDateShortcut>();\n  startEndDateShortCutStringValues: string[];\n\n\n  startDate = new FormControl<Date | null>(null);\n  endDate = new FormControl<Date | null>(null);\n  private destroy$ = new Subject<void>();\n\n  constructor(private appService: AppService, private formBuilder: FormBuilder) {\n    this.appService.fetchBankAccountsForUser()\n      .pipe(takeUntil(this.destroy$))\n\n      .subscribe(result => {\n          if (result == undefined) {\n            return;\n          }\n          this.appService.setBankAccount(result[0]);\n          return this.bankAccounts = result\n        }\n      )\n    this.bankAccountFormFieldGroup = formBuilder.group({queryForm: \"\"});\n    this.startEndDateFormFieldGroup = formBuilder.group({queryForm: \"\"});\n    this.transactionTypeFormFieldGroup = formBuilder.group({queryForm: \"\"});\n    this.transactionTypeFormFieldGroup = formBuilder.group({queryForm: \"\"});\n    this.groupingTypesFormFieldGroup = formBuilder.group({queryForm: \"\"});\n\n    this.groupingTypes.set(\"month\", GroupingEnum.month)\n    this.groupingTypes.set(\"year\", GroupingEnum.year)\n    this.groupingTypes.set(\"quarter\", GroupingEnum.quarter)\n    this.groupingTypeStringValues = Array.from(this.groupingTypes.keys());\n\n\n    this.startEndDateShortCuts.set(\"huidige maand\", StartEndDateShortcut.CURRENT_MONTH);\n    this.startEndDateShortCuts.set(\"huidig kwartaal\", StartEndDateShortcut.CURRENT_QUARTER);\n    this.startEndDateShortCuts.set(\"huidig jaar\", StartEndDateShortcut.CURRENT_YEAR);\n    this.startEndDateShortCuts.set(\"alles\", StartEndDateShortcut.ALL);\n    this.startEndDateShortCutStringValues = Array.from(this.startEndDateShortCuts.keys());\n\n\n    this.transactionTypes.set(\"in- & uitkomsten\", TransactionTypeEnum.BOTH)\n    this.transactionTypes.set(\"uitgaven\", TransactionTypeEnum.EXPENSES)\n    this.transactionTypes.set(\"inkomsten\", TransactionTypeEnum.REVENUE)\n    this.transactionTypeStringValues = Array.from(this.transactionTypes.keys());\n\n\n  }\n\n  ngOnInit() {\n  }\n\n  dateClass = (d: Date) => {\n    const date = d.getDay();\n    // Highlight saturday and sunday.\n    return (date === 0 || date === 6) ? 'highlight-dates' : undefined;\n  }\n\n  onBankAccountChange(bankAccount: BankAccount) {\n    this.appService.setBankAccount(bankAccount);\n\n\n  }\n\n\n  setStartAndEndDate() {\n    console.log(this.startDate.value);\n    console.log(this.endDate.value);\n    if (this.startDate.value && this.endDate.value) {\n\n      this.appService.setStartAndEndDate(this.startDate.value, this.endDate.value)\n    }\n  }\n\n  onTransactionTypeChange(transactionTypeStr: string) {\n    console.log(transactionTypeStr);\n    var transactionType: TransactionTypeEnum | undefined = this.transactionTypes.get(transactionTypeStr)\n    if (transactionType == undefined) {\n      transactionType = TransactionTypeEnum.BOTH;\n    }\n    this.appService.setTransactionType(transactionType);\n  }\n\n  onGroupingChange(groupingStr: string) {\n    console.log(groupingStr);\n    var groupingType: GroupingEnum | undefined = this.groupingTypes.get(groupingStr)\n    if (groupingType == undefined) {\n      groupingType = GroupingEnum.month;\n    }\n    this.appService.setGrouping(groupingType);\n  }\n\n  onPeriodShortCutClick(periodStr: string) {\n    var shortCut: StartEndDateShortcut | undefined = this.startEndDateShortCuts.get(periodStr);\n\n\n    if (shortCut == undefined) {\n      shortCut = StartEndDateShortcut.ALL;\n    }\n\n    this.appService.resolveStartEndDateShortcut(shortCut).subscribe(resolved => {\n\n      this.startDate.setValue(resolved.start);\n      this.endDate.setValue(resolved.end);\n    })\n\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".wrapper {\r\n    border: 1px solid gray;\r\n}\r\n.inline_block {\r\n    display: inline-block;\r\n    padding: 2px;\r\n    /* width:120px;\r\n    height:120px;\r\n    border: 1px solid red; */\r\n}\r\n",
                    "styleUrl": "./filters.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 74,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"wrapper\">\n  <div [formGroup]=\"bankAccountFormFieldGroup\" class=\"inline_block\">\n    <mat-form-field appearance=\"fill\">\n      <mat-label>Selecteer rekening</mat-label>\n      <mat-select placeholder=\"Rekening\" name=\"bankAccount\" (selectionChange)=\"onBankAccountChange($event.value)\">\n        <mat-option *ngFor=\"let bankAccount of bankAccounts\" [value]=\"bankAccount\">\n          {{bankAccount.accountNumber}}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div [formGroup]=\"startEndDateFormFieldGroup\" class=\"inline_block\">\n    <mat-form-field appearance=\"fill\">\n      <mat-label>Kies periode</mat-label>\n      <mat-date-range-input [rangePicker]=\"picker\">\n        <input matStartDate placeholder=\"Start datum\" [formControl]=\"startDate\">\n        <input matEndDate placeholder=\"Eind datum\" [formControl]=\"endDate\" (dateChange)=\"setStartAndEndDate()\">\n      </mat-date-range-input>\n      <mat-hint>DD/MM/YYYY – DD/MM/YYYY</mat-hint>\n      <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n      <mat-date-range-picker #picker></mat-date-range-picker>\n    </mat-form-field>\n  </div>\n\n\n  <div [formGroup]=\"transactionTypeFormFieldGroup\" class=\"inline_block\">\n    <mat-form-field appearance=\"fill\">\n      <mat-label>Selecteer transactietype</mat-label>\n      <mat-select placeholder=\"Transactietype\" name=\"type\" (selectionChange)=\"onTransactionTypeChange($event.value)\">\n        <mat-option *ngFor=\"let transactionType of transactionTypeStringValues\" [value]=\"transactionType\">\n          {{transactionType}}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div [formGroup]=\"groupingTypesFormFieldGroup\" class=\"inline_block\">\n    <mat-form-field appearance=\"fill\">\n      <mat-label>Selecteer groepering</mat-label>\n      <mat-select placeholder=\"Groepering\" name=\"type\" (selectionChange)=\"onGroupingChange($event.value)\">\n        <mat-option *ngFor=\"let groupingType of groupingTypeStringValues\" [value]=\"groupingType\">\n          {{groupingType}}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n</div>\n<div>\n  <div>\n    <div class=\"inline_block\" style=\"padding-top: 2px;\">\n      <label style=\"padding: 4px;\">Shortcuts periode:</label>\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('huidige maand')\">huidige maand</button>\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('huidig kwartaal')\">huidig kwartaal</button>\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('huidig jaar')\">huidig jaar</button>\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('alles')\">alles</button>\n    </div>\n  </div>\n</div>\n"
        },
        {
            "name": "GroupingTypeSelectionComponent",
            "id": "component-GroupingTypeSelectionComponent-2a7c103b08e417578544716264cc1fe7c65f1d9706bb1a856269beed926135e0d2bb2cf09942a994687320609e7b07f10f9384612960ce2a9c643717d67010ce",
            "file": "src/app/grouping-type-selection/grouping-type-selection.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "grouping-type-selection",
            "styleUrls": [
                "./grouping-type-selection.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./grouping-type-selection.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "change",
                    "defaultValue": "new EventEmitter<GroupingEnum>(true)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 24,
                    "type": "EventEmitter<GroupingEnum>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "groupingTypes",
                    "defaultValue": "new Map<string, GroupingEnum>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | GroupingEnum>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 21
                },
                {
                    "name": "groupingTypesFormFieldGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 19
                },
                {
                    "name": "groupingTypeStringValues",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "selectedGrouping",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "GroupingEnum",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 39,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onGroupingChange",
                    "args": [
                        {
                            "name": "groupingStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 49,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "groupingStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatLabel"
                },
                {
                    "name": "MatSelect"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatOption"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, EventEmitter, OnInit, Output} from '@angular/core';\nimport { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport {AppService} from '../app.service';\nimport {GroupingEnum} from \"@daanvdn/budget-assistant-client\";\nimport { MatFormField, MatLabel } from '@angular/material/form-field';\nimport { MatSelect } from '@angular/material/select';\nimport { NgFor } from '@angular/common';\nimport { MatOption } from '@angular/material/core';\n\n@Component({\n    selector: 'grouping-type-selection',\n    templateUrl: './grouping-type-selection.component.html',\n    styleUrls: ['./grouping-type-selection.component.scss'],\n    standalone: true,\n    imports: [FormsModule, ReactiveFormsModule, MatFormField, MatLabel, MatSelect, NgFor, MatOption]\n})\nexport class GroupingTypeSelectionComponent implements OnInit {\n\n  groupingTypesFormFieldGroup: FormGroup;\n\n  groupingTypes: Map<string, GroupingEnum> = new Map<string, GroupingEnum>();\n  groupingTypeStringValues: string[];\n  selectedGrouping!: GroupingEnum;\n  @Output() change: EventEmitter<GroupingEnum> = new EventEmitter<GroupingEnum>(true);\n\n\n\n  constructor(formBuilder: FormBuilder, private appService: AppService) {\n\n    this.groupingTypesFormFieldGroup = formBuilder.group({ queryForm: \"\" });\n    this.groupingTypes.set(\"month\", GroupingEnum.month)\n    this.groupingTypes.set(\"year\", GroupingEnum.year)\n    this.groupingTypes.set(\"quarter\", GroupingEnum.quarter)\n    this.groupingTypeStringValues = Array.from(this.groupingTypes.keys());\n    this.selectedGrouping = GroupingEnum.month;\n\n  }\n\n  ngOnInit() {\n    this.change.emit(this.selectedGrouping);\n    this.appService.setGrouping(this.selectedGrouping);\n\n  }\n\n\n\n\n\n  onGroupingChange(groupingStr: string) {\n\n    var groupingType: GroupingEnum | undefined = this.groupingTypes.get(groupingStr)\n    if (groupingType == undefined) {\n      this.selectedGrouping = GroupingEnum.month;\n    } else {\n      this.selectedGrouping = groupingType;\n    }\n    this.appService.setGrouping(this.selectedGrouping);\n    this.change.emit(this.selectedGrouping);\n\n  }\n\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./grouping-type-selection.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 24,
                "jsdoctags": [
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<div [formGroup]=\"groupingTypesFormFieldGroup\" class=\"inline_block\">\n  <mat-form-field appearance=\"fill\">\n    <mat-label>Selecteer groepering</mat-label>\n    <mat-select  placeholder=\"Groepering\" [(value)]=\"selectedGrouping\" name=\"type\" (selectionChange)=\"onGroupingChange($event.value)\">\n      <mat-option *ngFor=\"let groupingType of groupingTypeStringValues\" [value]=\"groupingType\">\n        {{groupingType}}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</div>\n"
        },
        {
            "name": "HomeLayoutComponent",
            "id": "component-HomeLayoutComponent-da3d58ec5b42b84f181e21811b14ba10905c8f10023dbe8570af1c00cb9a3846e4a799f90b0a52ad273195af2d73591aab0c5fa574cb14e05cd094ee2846933b",
            "file": "src/app/layouts/home-layout/home-layout.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-home-layout",
            "styleUrls": [
                "./home-layout.component.css"
            ],
            "styles": [],
            "templateUrl": [
                "./home-layout.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NavigationComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\nimport { NavigationComponent } from '../../navigation/navigation.component';\n\n@Component({\n    selector: 'app-home-layout',\n    templateUrl: './home-layout.component.html',\n    styleUrls: ['./home-layout.component.css'],\n    standalone: true,\n    imports: [NavigationComponent]\n})\nexport class HomeLayoutComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./home-layout.component.css"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 11
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<app-navigation class=\"mat-app-background\"></app-navigation>\n\n"
        },
        {
            "name": "InsightsComponent",
            "id": "component-InsightsComponent-8fef7311e87949846578a98d2f8060d3edf038a49b0cf835d692e157c357d8a3e9f7737ec7d909ce77f7ba1ae39bf674829609b84bdf8a45531e29e682296995",
            "file": "src/app/insights/insights.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "insights",
            "styleUrls": [
                "./insights.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./insights.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "budgetTrackingCriteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Criteria",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57
                },
                {
                    "name": "categoryDetailsCriteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Criteria",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "categoryOverviewCriteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Criteria",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56
                },
                {
                    "name": "expensesRevenueCriteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Criteria",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54
                },
                {
                    "name": "faSearch",
                    "defaultValue": "faSearch",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "showCriteriaToolbar",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27
                }
            ],
            "methodsClass": [
                {
                    "name": "getDynamicHeight",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 45,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 34,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onClosed",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatToolbar"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "FaIconComponent",
                    "type": "component"
                },
                {
                    "name": "MatTabGroup"
                },
                {
                    "name": "MatTab"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "CriteriaToolbarComponent",
                    "type": "component"
                },
                {
                    "name": "ExpensesRevenueComponent",
                    "type": "component"
                },
                {
                    "name": "RevenueExpensesPerPeriodAndCategoryComponent",
                    "type": "component"
                },
                {
                    "name": "CategoryDetailsComponent",
                    "type": "component"
                },
                {
                    "name": "BudgetTrackingComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {faSearch} from \"@fortawesome/free-solid-svg-icons/faSearch\";\nimport {BankAccount, GroupingEnum, TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {MatIconButton} from '@angular/material/button';\nimport {FaIconComponent} from '@fortawesome/angular-fontawesome';\nimport {MatTab, MatTabGroup} from '@angular/material/tabs';\nimport {NgIf} from '@angular/common';\nimport {CriteriaToolbarComponent} from '../criteria-toolbar/criteria-toolbar.component';\nimport {ExpensesRevenueComponent} from '../revenue-expenses/revenue-expenses.component';\nimport {\n    RevenueExpensesPerPeriodAndCategoryComponent\n} from '../revenue-expenses-per-period-and-category/revenue-expenses-per-period-and-category.component';\nimport {CategoryDetailsComponent} from '../category-details/category-details.component';\nimport {BudgetTrackingComponent} from '../budget-tracking/budget-tracking.component';\nimport {Criteria} from '../model/criteria.model';\n\n\n\n@Component({\n    selector: 'insights', templateUrl: './insights.component.html', styleUrls: ['./insights.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, MatIconButton, FaIconComponent, MatTabGroup, MatTab, NgIf, CriteriaToolbarComponent, ExpensesRevenueComponent, RevenueExpensesPerPeriodAndCategoryComponent, CategoryDetailsComponent, BudgetTrackingComponent]\n})\nexport class InsightsComponent implements OnInit {\n\n    showCriteriaToolbar: boolean = true;\n\n    constructor() {\n\n    }\n\n\n    ngOnInit() {\n\n\n    }\n\n    protected readonly faSearch = faSearch;\n\n    onClosed() {\n        this.showCriteriaToolbar = false;\n    }\n\n    getDynamicHeight(): string {\n        if (this.showCriteriaToolbar) {\n            return \"75vh\";\n        }\n\n        return \"85vh\";\n    }\n\n\n    expensesRevenueCriteria!: Criteria;\n    categoryDetailsCriteria!: Criteria;\n    categoryOverviewCriteria!: Criteria;\n    budgetTrackingCriteria!: Criteria;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".wrapper {\r\n  display: grid;\r\n  grid-template-columns: fit-content(1fr) fit-content() 1fr;\r\n  // gap: 10px;\r\n  // grid-auto-rows: 1fr;\r\n  align-items: start;\r\n  // column-gap: normal;\r\n  grid-column-gap: 0;\r\n  grid-row-gap: 0\r\n\r\n}\r\n\r\n.one {\r\n  grid-column: 1 /1;\r\n  grid-row: 1;\r\n\r\n}\r\n\r\n.two {\r\n  grid-column: 2;\r\n  grid-row: 1;\r\n\r\n}\r\n\r\n.three {\r\n  grid-column: 3;\r\n  grid-row: 1;\r\n\r\n}\r\n::ng-deep .mat-expansion-panel-header .mat-expansion-panel-header-title {\r\n  justify-content: center !important;\r\n}\r\n\r\n.button-container {\r\n  display: flex;\r\n  //justify-content: flex-end;\r\n  justify-content: center;\r\n}\r\n\r\n\r\n.toolbar-container {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  height: 8vh;\r\n}\r\n\r\n.title {\r\n  flex: 1;\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n\r\n.spacer {\r\n  flex: 1;\r\n}\r\n\r\n",
                    "styleUrl": "./insights.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 27
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<mat-toolbar color=\"primary\" class=\"toolbar-container\">\n    <span class=\"title\">Insights</span>\n    <button [disabled]=\"showCriteriaToolbar\" mat-icon-button class=\"button-container\"\n            (click)=\"showCriteriaToolbar=true\">\n        <fa-icon style=\"justify-content: center\" [fixedWidth]=\"true\" [icon]=\"faSearch\"></fa-icon>\n    </button>\n</mat-toolbar>\n<div style=\"overflow-x: hidden\">\n    <mat-tab-group #matTabGroup mat-stretch-tabs=\"false\" mat-align-tabs=\"center\">\n        <mat-tab label=\"Revenue and Expenses\">\n            <div *ngIf=\"showCriteriaToolbar\" style=\"height: 10vh; padding-left:2px\">\n                <criteria-toolbar (criteriaChange)=\"expensesRevenueCriteria = $event\" (closed)=\"onClosed()\" [enableExpensesRevenueToggle]=\"false\"></criteria-toolbar>\n            </div>\n            <div [style.height]=\"getDynamicHeight()\" style=\"overflow-y: scroll; padding-left:2px\">\n                <expenses-revenue [criteria]=\"expensesRevenueCriteria\"></expenses-revenue>\n            </div>\n        </mat-tab>\n        <mat-tab label=\"Category Overview\">\n\n            <div *ngIf=\"showCriteriaToolbar\" style=\"height: 10vh; padding-left:2px\">\n                <criteria-toolbar (criteriaChange)=\"categoryOverviewCriteria = $event\"  (closed)=\"onClosed()\"></criteria-toolbar>\n            </div>\n            <div [style.height]=\"getDynamicHeight()\" style=\"overflow-y: visible; padding-left:2px\">\n                <revenue-expenses-per-period-and-category [criteria]=\"categoryOverviewCriteria\">\n\n                </revenue-expenses-per-period-and-category>\n            </div>\n\n        </mat-tab>\n        <mat-tab label=\"Categories in Detail\">\n\n            <div *ngIf=\"showCriteriaToolbar\" style=\"height: 10vh; padding-left:2px\">\n                <criteria-toolbar (criteriaChange)=\"categoryDetailsCriteria = $event\" (closed)=\"onClosed()\"></criteria-toolbar>\n            </div>\n\n            <div [style.height]=\"getDynamicHeight()\" style=\"overflow-y: scroll; padding-left:2px\">\n                <category-details [criteria]=\"categoryDetailsCriteria\">\n\n                </category-details>\n            </div>\n\n        </mat-tab>\n        <mat-tab label=\"Budget Tracking\">\n\n            <div *ngIf=\"showCriteriaToolbar\" style=\"height: 10vh; padding-left:2px\">\n                <criteria-toolbar [enableExpensesRevenueToggle]=\"false\" (criteriaChange)=\"budgetTrackingCriteria = $event\" (closed)=\"onClosed()\"></criteria-toolbar>\n            </div>\n\n            <div [style.height]=\"getDynamicHeight()\" style=\"overflow-y: scroll; padding-left:2px\">\n                <budget-tracking [criteria]=\"budgetTrackingCriteria\">\n\n                </budget-tracking>\n            </div>\n\n        </mat-tab>\n    </mat-tab-group>\n</div>\n"
        },
        {
            "name": "LoginComponent",
            "id": "component-LoginComponent-d2b836807d7ace84b78f8c25a11ffb11c890edc7e504501e81f682e7041d7229251d0492ef6357c8ad5131630e9fbc7a62b44d665891c1d3e9ab933d55d82183",
            "file": "src/app/login/login.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-login",
            "styleUrls": [
                "./login.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./login.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24
                },
                {
                    "name": "formSubmitAttempt",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "hidePassword",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26
                }
            ],
            "methodsClass": [
                {
                    "name": "doLogin",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 78,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "isFieldInvalid",
                    "args": [
                        {
                            "name": "field",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 60,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 38,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "trimAndNotEmptyValidator",
                    "args": [],
                    "optional": false,
                    "returnType": "ValidatorFn",
                    "typeParameters": [],
                    "line": 47,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatCard"
                },
                {
                    "name": "MatCardContent"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatInput"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatError"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "MatSuffix"
                },
                {
                    "name": "MatIcon"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "RouterLink"
                },
                {
                    "name": "RouterLinkActive"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport { AbstractControl, FormBuilder, FormGroup, ValidatorFn, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms';\n\nimport {AuthService, Response} from '../auth/auth.service';\nimport {User} from \"../model\";\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport { MatCard, MatCardContent } from '@angular/material/card';\nimport { MatFormField, MatError, MatSuffix } from '@angular/material/form-field';\nimport { MatInput } from '@angular/material/input';\nimport { NgIf } from '@angular/common';\nimport { MatIconButton, MatButton } from '@angular/material/button';\nimport { MatIcon } from '@angular/material/icon';\nimport { RouterLink, RouterLinkActive } from '@angular/router';\n\n@Component({\n    selector: 'app-login',\n    templateUrl: './login.component.html',\n    styleUrls: ['./login.component.scss'],\n    standalone: true,\n    imports: [MatCard, MatCardContent, FormsModule, ReactiveFormsModule, MatFormField, MatInput, NgIf, MatError, MatIconButton, MatSuffix, MatIcon, MatButton, RouterLink, RouterLinkActive]\n})\nexport class LoginComponent implements OnInit {\n\n  form: FormGroup;\n  private formSubmitAttempt: boolean | undefined;\n  hidePassword = true;\n\n  constructor(\n    private fb: FormBuilder,\n    private authService: AuthService, private errorDialogService: ErrorDialogService\n  ) {\n    this.form = this.fb.group({\n      userName: ['', [Validators.required, this.trimAndNotEmptyValidator()]],\n      password: ['', [Validators.required, this.trimAndNotEmptyValidator()]]\n    });\n  }\n\n  ngOnInit() {\n\n\n\n  }\n\n\n\n\n  private trimAndNotEmptyValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      if (control.value) {\n        // Trim the input and check if it's empty after trimming.\n        const trimmedValue = control.value.trim();\n        if (trimmedValue === '') {\n          return {empty: true}; // Return a validation error if empty.\n        }\n      }\n      return null; // Return null if the input is valid.\n    };\n  }\n\n  isFieldInvalid(field: string) {\n\n\n    let fieldObj = this.form.get(field);\n    if(fieldObj === undefined || fieldObj === null){\n      return false;\n    }\n    let valid = fieldObj.valid;\n    // @ts-ignore\n    let touched = fieldObj.touched;\n    // @ts-ignore\n    let untouched = fieldObj.untouched;\n    return (\n      (!valid && touched) ||\n      (untouched && this.formSubmitAttempt)\n    );\n  }\n\n  doLogin() {\n    if(!this.form){\n      throw new Error();\n    }\n    if (this.form.valid) {\n\n      let user = this.form.value as User;\n      if (user.userName == '' || user.password == '') {\n        this.errorDialogService.openErrorDialog(\"Gebruikersnaam en paswoord moeten beiden ingevuld zijn!\", undefined)\n      } else {\n        this.authService.login(this.form.value).subscribe(response => {\n          if(response.response == Response.FAILED){\n            this.errorDialogService.openErrorDialog(\"Aanmelden is mislukt!\", response.errorMessage)\n          }\n        });\n\n      }\n    }\n    this.formSubmitAttempt = true;\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "\n/* TODO(mdc-migration): The following rule targets internal classes of card that may no longer apply for the MDC version. */\nmat-card {\r\n  max-width: 400px;\r\n  margin: 2em auto;\r\n  text-align: center;\r\n}\r\n.signin-content {\r\n  padding: 60px 1rem;\r\n}\r\n.full-width-input {\r\n  width: 100%;\r\n}\r\n\r\n\r\n",
                    "styleUrl": "./login.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 26,
                "jsdoctags": [
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "\n<div class=\"signin-content\">\n  <mat-card appearance=\"outlined\">\n    <mat-card-content>\n      <form [formGroup]=\"form\" (ngSubmit)=\"doLogin()\">\n        <p>Meld u aan</p>\n        <mat-form-field class=\"full-width-input\">\n          <input matInput type=\"text\" placeholder=\"Gebruikersnaam\" formControlName=\"userName\" required>\n          <mat-error *ngIf=\"isFieldInvalid('userName')\">\n            Gebruikersnaam invoeren.\n          </mat-error>\n        </mat-form-field>\n        <mat-form-field class=\"full-width-input\">\n          <input style=\"width: 90%\" matInput [type]=\"hidePassword ? 'password' : 'text'\" placeholder=\"Paswoord\" formControlName=\"password\" required>\n          <mat-error *ngIf=\"isFieldInvalid('password')\">\n            Paswoord invoeren.\n          </mat-error>\n          <button mat-icon-button matSuffix (mousedown)=\"hidePassword = false\" (mouseup)=\"hidePassword = true\" [attr.aria-label]=\"hidePassword ? 'Toon paswoord' : 'Verberg paswoord'\">\n            <mat-icon>{{ hidePassword ? 'visibility_off' : 'visibility' }}</mat-icon>\n          </button>\n        </mat-form-field>\n\n        <button mat-raised-button color=\"primary\" type=\"submit\" (click)=\"doLogin()\">Aanmelden</button>\n        <div style=\"padding-top: 20px\">\n          <a routerLink=\"/register\" routerLinkActive=\"activebutton\" ariaCurrentWhenActive=\"page\"\n              style=\";font-size: smaller\">Geen account? Klik hier om te registeren</a></div>\n\n\n      </form>\n    </mat-card-content>\n  </mat-card>\n</div>\n"
        },
        {
            "name": "LoginLayoutComponent",
            "id": "component-LoginLayoutComponent-effb644905432ce375b4eabb2dfa767b877d58dda8a415671c7aa7c9074e521842e97d616e1474be13ed9e5f9fc99e65378a9f393d5266c687f4b8d262c8102d",
            "file": "src/app/layouts/login-layout/login-layout.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-login-layout",
            "styleUrls": [
                "./login-layout.component.css"
            ],
            "styles": [],
            "templateUrl": [
                "./login-layout.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 15,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "RouterOutlet"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\nimport { RouterOutlet } from '@angular/router';\n\n@Component({\n    selector: 'app-login-layout',\n    templateUrl: './login-layout.component.html',\n    styleUrls: ['./login-layout.component.css'],\n    standalone: true,\n    imports: [RouterOutlet]\n})\nexport class LoginLayoutComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./login-layout.component.css"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 11
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<router-outlet class=\"mat-app-background\"></router-outlet>\n"
        },
        {
            "name": "ManualCategorizationViewComponent",
            "id": "component-ManualCategorizationViewComponent-70965ee21c0e838de03c524ca1d8534c39684b54d1e3f49d020939ee21de39f3a2e682fe13e11f4ad29ab11cedabca1c7097bc7d1806e2def7c403d7f4eae0c2",
            "file": "src/app/manual-categorization-view/manual-categorization-view.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-manual-categorization-view",
            "styleUrls": [
                "./manual-categorization-view.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./manual-categorization-view.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "activeView",
                    "defaultValue": "new BehaviorSubject<TransactionTypeEnum>(TransactionTypeEnum.EXPENSES)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BehaviorSubject<TransactionTypeEnum>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 108,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "activeViewObservable",
                    "defaultValue": "this.activeView.asObservable()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 109,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "bankAccount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccount",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 102,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "categoryMap",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryMap",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 100
                },
                {
                    "name": "dataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "GroupByCounterpartyDataSource",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 99
                },
                {
                    "name": "displayedColumns",
                    "defaultValue": "[\n    \"transaction\",\n    \"amount\",\n    \"category\"\n  ]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 103
                },
                {
                    "name": "paginator",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatPaginator",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 93,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatPaginator, {static: false}"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "sort",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatSort",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 94,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatSort, {static: false}"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "table",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTable<Transaction>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 95,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatTable"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "tableElement",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ElementRef",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 96,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'table', {read: ElementRef, static: false}"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "amountType",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction | GroupBy",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AmountType",
                    "typeParameters": [],
                    "line": 173,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction | GroupBy",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initDataSource",
                    "args": [
                        {
                            "name": "account",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "GroupByCounterpartyDataSource",
                    "typeParameters": [],
                    "line": 133,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "account",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "transactionType",
                            "type": "TransactionTypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isGroup",
                    "args": [
                        {
                            "name": "index",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "item",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 185,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "index",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "item",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 130,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onToggleChange",
                    "args": [
                        {
                            "name": "$event",
                            "type": "MatButtonToggleChange",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 189,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "$event",
                            "type": "MatButtonToggleChange",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "saveTransaction",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 151,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setCategory",
                    "args": [
                        {
                            "name": "row",
                            "type": "",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "selectedCategoryQualifiedNameStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 155,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "row",
                            "type": "",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "selectedCategoryQualifiedNameStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatToolbar"
                },
                {
                    "name": "BankAccountSelectionComponent",
                    "type": "component"
                },
                {
                    "name": "MatButtonToggleGroup"
                },
                {
                    "name": "MatButtonToggle"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatPaginator"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "CategoryTreeDropdownComponent",
                    "type": "component"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                },
                {
                    "name": "AsyncPipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, ElementRef, OnInit, ViewChild} from '@angular/core';\nimport {MatPaginator} from \"@angular/material/paginator\";\nimport {MatSort} from \"@angular/material/sort\";\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable\n} from \"@angular/material/table\";\nimport {PaginationDataSource, SimpleDataSource} from \"@daanvdn/ngx-pagination-data-source\";\nimport {AppService} from \"../app.service\";\nimport {BehaviorSubject, map, Observable} from \"rxjs\";\nimport {MatButtonToggle, MatButtonToggleChange, MatButtonToggleGroup} from \"@angular/material/button-toggle\";\nimport {BankAccount, SimpleCategory, Transaction, TransactionTypeEnum} from \"@daanvdn/budget-assistant-client\";\nimport {AmountType, CategoryMap, inferAmountType} from \"../model\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {AsyncPipe, NgIf} from '@angular/common';\nimport {CategoryTreeDropdownComponent} from '../category-tree-dropdown/category-tree-dropdown.component';\n\n\ninterface GroupBy {\n  counterparty: string;\n  isGroupBy: boolean;\n  transactions: Transaction[];\n  isExpense: boolean;\n}\n\nclass GroupByCounterpartyDataSource implements SimpleDataSource<Transaction | GroupBy> {\n\n\n\n  constructor(public backingPaginationDataSource: PaginationDataSource<Transaction, BankAccount>, private isExpense: boolean) {\n  }\n\n  connect(): Observable<Array<Transaction | GroupBy>> {\n    return this.backingPaginationDataSource.connect().pipe(map(data => {\n\n      let mapByCounterpartyName = new Map<string, Transaction[]>();\n\n      for (const transaction of data) {\n        let name = transaction.counterparty;\n        if (!name) {\n          name = \"\";\n        }\n        let transactionsForCounterparty = mapByCounterpartyName.has(name) ? mapByCounterpartyName.get(name) : [];\n        transactionsForCounterparty?.push(transaction);\n        mapByCounterpartyName.set(name, transactionsForCounterparty as Transaction[]);\n      }\n      let sortedKeys = Array.from(mapByCounterpartyName.keys()).sort();\n      let result = new Array<Transaction | GroupBy>();\n      for (const aKey of sortedKeys) {\n        let transactionsForKey = mapByCounterpartyName.get(aKey) as Transaction[];\n        let groupBy: GroupBy = {\n          counterparty: aKey, isGroupBy: true, transactions: transactionsForKey, isExpense: this.isExpense\n        };\n        result.push(groupBy)\n        result.push(...transactionsForKey)\n\n      }\n\n      return result;\n    }));\n  }\n\n  disconnect(): void {\n    this.backingPaginationDataSource.disconnect();\n  }\n\n\n  fetch(page: number, pageSize?: number): void {\n    this.backingPaginationDataSource.fetch(page, pageSize);\n  }\n\n\n}\n\n@Component({\n    selector: 'app-manual-categorization-view',\n    templateUrl: './manual-categorization-view.component.html',\n    styleUrls: ['./manual-categorization-view.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, BankAccountSelectionComponent, MatButtonToggleGroup, MatButtonToggle, NgIf, MatPaginator, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, CategoryTreeDropdownComponent, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, AsyncPipe]\n})\nexport class ManualCategorizationViewComponent implements OnInit {\n\n  @ViewChild(MatPaginator, { static: false }) paginator!: MatPaginator;\n  @ViewChild(MatSort, { static: false }) sort!: MatSort;\n  @ViewChild(MatTable) table!: MatTable<Transaction>;\n  @ViewChild('table', {read: ElementRef, static: false}) tableElement!: ElementRef;\n\n\n  dataSource!: GroupByCounterpartyDataSource;\n  categoryMap!: CategoryMap;\n\n  private bankAccount!: BankAccount;\n  displayedColumns = [\n    \"transaction\",\n    \"amount\",\n    \"category\"\n  ];\n  private activeView: BehaviorSubject<TransactionTypeEnum> = new BehaviorSubject<TransactionTypeEnum>(TransactionTypeEnum.EXPENSES);\n  private activeViewObservable = this.activeView.asObservable();\n  constructor(private appService: AppService) {\n    appService.selectedBankAccountObservable$.subscribe(account => {\n      if (account){\n        this.bankAccount = account;\n        this.dataSource = this.initDataSource(account, this.activeView.getValue());\n      }\n    });\n    appService.categoryMapObservable$.subscribe(categoryMap => {\n      if (categoryMap) {\n        this.categoryMap = categoryMap;\n      }}\n    )\n\n\n    this.activeViewObservable.subscribe(activeView => {\n      this.dataSource = this.initDataSource(this.bankAccount, activeView);\n    })\n\n  }\n\n  ngOnInit( ): void {\n  }\n\n  private initDataSource(account: BankAccount, transactionType: TransactionTypeEnum): GroupByCounterpartyDataSource {\n    if (transactionType == TransactionTypeEnum.BOTH){\n      throw new Error(\"TransactionType.BOTH not supported\")\n    }\n\n    let isExpense = transactionType === TransactionTypeEnum.EXPENSES;\n\n    let paginationDataSource = new PaginationDataSource<Transaction, BankAccount>(\n      (request, query) => {\n        request.size = 50;\n        return this.appService.pageTransactionsToManuallyReview(request, transactionType);\n      },\n      {property: 'counterparty', order: 'asc'}, account\n    );\n    return new GroupByCounterpartyDataSource(paginationDataSource, isExpense);\n  }\n\n\n  saveTransaction(transaction: Transaction) {\n    this.appService.saveTransaction(transaction)\n  }\n\n  setCategory(row: (Transaction | GroupBy), selectedCategoryQualifiedNameStr: string) {\n    // Get the SimpleCategory object from the CategoryMap\n    const category = this.categoryMap.getSimpleCategory(selectedCategoryQualifiedNameStr);\n\n    // Check if row is an interface that has key 'isGroupBy'\n    if (\"isGroupBy\" in row) {\n      (row as GroupBy).transactions.forEach(transaction => {\n        transaction.category = category;\n        this.saveTransaction(transaction);\n      });\n      return;\n    } else {\n      let transaction = row as Transaction;\n      transaction.category = category;\n      this.saveTransaction(transaction);\n    }\n  }\n\n  amountType(transaction: Transaction | GroupBy): AmountType {\n    if (\"isGroupBy\" in transaction) {\n      return transaction.isExpense ? AmountType.EXPENSES : AmountType.REVENUE;\n    }\n    if (transaction.amount === undefined || transaction.amount === null) {\n      throw new Error(\"Amount is undefined or null\");\n    }\n    return inferAmountType(transaction.amount)\n\n\n  }\n\n  isGroup(index: any, item: any): boolean {\n    return item.isGroupBy;\n  }\n\n  onToggleChange($event: MatButtonToggleChange) {\n    this.tableElement.nativeElement.scrollIntoView({behavior: 'smooth', block: 'start'});\n    const value = $event.value;\n    if (value === \"expenses\") {\n      this.activeView.next(TransactionTypeEnum.EXPENSES);\n    } else if (value === \"revenue\") {\n      this.activeView.next(TransactionTypeEnum.REVENUE);\n    } else {\n      throw new Error(\"Unknown value \" + value);\n    }\n\n\n\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "section {\r\n  display: flex;\r\n  align-items: flex-start;\r\n}\r\n\r\n\r\n.spinner-container {\r\n  background-color: #ffffff; /* Change this to your desired color */\r\n  padding: 20px;\r\n  border-radius: 10px;\r\n  display: flex; /* Add this line */\r\n  justify-content: center; /* Add this line */\r\n  align-items: center; /* Add this line */\r\n  flex-direction: column;\r\n}\r\n.overlay {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: rgba(0, 0, 0, 0.3);\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  z-index: 9999;\r\n}\r\n\r\n\r\nbutton {\r\n\r\n  padding: 1.40em 0;\r\n  line-height: 1;\r\n\r\n}\r\n\r\n.example-element-detail {\r\n  overflow: hidden;\r\n  display: flex;\r\n}\r\n\r\n.stacked-items {\r\n  min-width: 250px;\r\n  padding: 8px;\r\n  margin: 8px 0;\r\n\r\n}\r\n\r\n\r\n.flex-container {\r\n  display: flex;\r\n}\r\n\r\n.flex-child{\r\n  flex: 1;\r\n}\r\n\r\n.flex-child:first-child {\r\n  margin-right: 2px;\r\n}\r\n",
                    "styleUrl": "./manual-categorization-view.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 109,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<mat-toolbar color=\"primary\" class=\"toolbar-header\">\n  <span>Uncategorized Transactions</span>\n</mat-toolbar>\n<div style=\"background: white\">\n  <div #parent\n       style=\"height: 10vh; display: flex; justify-content: space-between;align-items: center; position: relative;\">\n    <div #one>\n      <bank-account-selection>\n      </bank-account-selection>\n    </div>\n    <div #two style=\"position: absolute; left: 50%; transform: translateX(-50%);\">\n      <mat-button-toggle-group (change)=\"onToggleChange($event)\" name=\"fontStyle\" aria-label=\"Font Style\">\n        <mat-button-toggle [checked]=\"true\" value=\"expenses\">Expenses</mat-button-toggle>\n        <mat-button-toggle value=\"revenue\">Revenue</mat-button-toggle>\n      </mat-button-toggle-group>\n    </div>\n    <!--    <div #three style=\"flex-grow: 1\">-->\n    <div #three style=\"position: absolute; right: 0;\">\n      <mat-paginator *ngIf=\"dataSource.backingPaginationDataSource.page$ | async as page\"\n                     [length]=\"page.totalElements\"\n                     [pageSize]=\"page.size\"\n                     [pageIndex]=\"page.number\" (page)=\"dataSource.fetch($event.pageIndex)\">\n      </mat-paginator>\n\n    </div>\n  </div>\n  <div style=\"height: 75vh;background-color:white; align-content: space-between; overflow-y: auto;\">\n    <table #table mat-table [dataSource]=\"dataSource\" class=\"mat-z8\" style=\"border-collapse: separate; width: 100%\">\n      <ng-container matColumnDef=\"transaction\">\n        <th mat-header-cell *matHeaderCellDef style=\"font-size: large;width: 50%\"></th>\n        <td mat-cell style=\"font-size: large\" *matCellDef=\"let item\">\n          <div class=\"stacked-items\"\n               style=\"font-weight: lighter;padding-block: 8px; ;  overflow-wrap: break-word;\">\n            <div>{{ item.transaction }}</div>\n            <div *ngIf=\"item.transaction !== item.communications\"\n                 style=\"padding-block: 8px\">{{ item.communications }}\n            </div>\n          </div>\n        </td>\n      </ng-container>\n      <ng-container matColumnDef=\"amount\">\n        <th mat-header-cell *matHeaderCellDef style=\"font-size: large; width: 10%\"></th>\n        <td mat-cell style=\"font-size: large\" *matCellDef=\"let item\">\n          <div class=\"stacked-items\" style=\"min-width: 100px;\">\n            <div>{{ item.amount }} {{ item.currency }}</div>\n          </div>\n        </td>\n      </ng-container>\n      <ng-container matColumnDef=\"category\">\n        <th mat-header-cell *matHeaderCellDef style=\"font-size: large; width: 40%\">Categorie</th>\n        <td mat-cell style=\"font-size: large;\" *matCellDef=\"let item\">\n          <div>\n            <app-category-tree-dropdown\n              (selectionChange)=\"setCategory(item, $event)\"\n              [selectedCategoryQualifiedNameStr]=\"item.category?.qualifiedName\"\n              [transactionTypeEnum]=\"amountType(item)\"\n            >\n            </app-category-tree-dropdown>\n          </div>\n\n        </td>\n      </ng-container>\n\n      <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n      <tr VALIGN=TOP mat-row *matRowDef=\"let row; columns: displayedColumns\"></tr>\n\n      <!-- Group header -->\n      <ng-container matColumnDef=\"groupHeader\">\n        <td mat-cell *matCellDef=\"let groupBy\">\n          <strong>Tegenpartij: {{ groupBy.counterparty ? groupBy.counterparty : 'N/A' }}</strong></td>\n      </ng-container>\n\n      <tr mat-row *matRowDef=\"let row; columns: ['groupHeader','amount','category']; when: isGroup\"></tr>\n    </table>\n  </div>\n  <div #three style=\"position: absolute; right: 0;height: 5vh\">\n    <mat-paginator *ngIf=\"dataSource.backingPaginationDataSource.page$ | async as page\"\n                   [length]=\"page.totalElements\"\n                   [pageSize]=\"page.size\"\n                   [pageIndex]=\"page.number\" (page)=\"dataSource.fetch($event.pageIndex)\">\n    </mat-paginator>\n\n  </div>\n\n</div>\n"
        },
        {
            "name": "NavigationComponent",
            "id": "component-NavigationComponent-05ecfc36d4b4c80e0a66e08382f1996fed524e1431cb1719c113bfe5b158016f31ae8eeebeb100ab7d91bf513ce188fc442f673b202d3938839be76c78155fd5",
            "file": "src/app/navigation/navigation.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-navigation",
            "styleUrls": [
                "./navigation.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./navigation.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "authService",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "AuthService",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 32,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "faChartPie",
                    "defaultValue": "faChartPie",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "faDollarSign",
                    "defaultValue": "faDollarSign",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "faNetworkWired",
                    "defaultValue": "faNetworkWired",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "faRightFromBracket",
                    "defaultValue": "faRightFromBracket",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 50,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "faScaleBalanced",
                    "defaultValue": "faScaleBalanced",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "faTag",
                    "defaultValue": "faTag",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 51,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "faUser",
                    "defaultValue": "faUser",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 46,
                    "modifierKind": [
                        124,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 36,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onLogout",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 40,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatDrawerContainer"
                },
                {
                    "name": "MatDrawer"
                },
                {
                    "name": "MatNavList"
                },
                {
                    "name": "RouterLink"
                },
                {
                    "name": "RouterLinkActive"
                },
                {
                    "name": "MatListItem"
                },
                {
                    "name": "FaIconComponent",
                    "type": "component"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "MatDrawerContent"
                },
                {
                    "name": "RouterOutlet"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, OnInit } from '@angular/core';\nimport {AuthService} from \"../auth/auth.service\";\nimport {Observable} from \"rxjs\";\nimport {\n  faChartPie,\n  faDollarSign,\n  faNetworkWired,\n  faRightFromBracket,\n  faScaleBalanced,\n  faUser,\n  faTag\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { MatDrawerContainer, MatDrawer, MatDrawerContent } from '@angular/material/sidenav';\nimport { MatNavList, MatListItem } from '@angular/material/list';\nimport { RouterLink, RouterLinkActive, RouterOutlet } from '@angular/router';\nimport { FaIconComponent } from '@fortawesome/angular-fontawesome';\nimport { MatIconButton } from '@angular/material/button';\n\n@Component({\n    selector: 'app-navigation',\n    templateUrl: './navigation.component.html',\n    styleUrls: ['./navigation.component.scss'],\n    standalone: true,\n    imports: [MatDrawerContainer, MatDrawer, MatNavList, RouterLink, RouterLinkActive, MatListItem, FaIconComponent, MatIconButton, MatDrawerContent, RouterOutlet]\n})\nexport class NavigationComponent implements OnInit {\n\n\n\n  // isLoggedIn$: Observable<boolean>;\n\n  constructor(public authService: AuthService) {\n    // this.isLoggedIn$ = this.authService.isLoggedIn;\n  }\n\n  ngOnInit() {\n    // this.isLoggedIn$ = this.authService.isLoggedIn;\n  }\n\n  onLogout() {\n    this.authService.logout();\n  }\n\n\n  protected readonly faNetworkWired = faNetworkWired;\n  protected readonly faUser = faUser;\n  protected readonly faDollarSign = faDollarSign;\n  protected readonly faChartPie = faChartPie;\n  protected readonly faScaleBalanced = faScaleBalanced;\n  protected readonly faRightFromBracket = faRightFromBracket;\n  protected readonly faTag = faTag;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".example-container{\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n\r\n}\r\n\r\nmat-nav-list {\r\n  width: 60px;\r\n  overflow: hidden;\r\n  transition: width 0.3s;\r\n\r\n  h4 {\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\nmat-drawer:hover {\r\n  mat-nav-list {\r\n    width: 180px;\r\n\r\n    h4 {\r\n      opacity: 1;\r\n      margin: auto 10px;\r\n      transition: all 0.1s ease-in 0.2s;\r\n    }\r\n  }\r\n}\r\n\r\n* {\r\n  box-sizing: border-box;\r\n}\r\n",
                    "styleUrl": "./navigation.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 26,
                "jsdoctags": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<mat-drawer-container class=\"example-container mat-typography mat-app-background\">\n  <mat-drawer #drawer mode=\"side\" disableClose=\"true\" opened=\"true\">\n    <mat-nav-list>\n      <a routerLink=\"/profiel\" routerLinkActive=\"activebutton\" ariaCurrentWhenActive=\"page\">\n        <mat-list-item>\n          <fa-icon [icon]=\"faUser\" [fixedWidth]=\"true\"></fa-icon>\n          <h4>Profiel</h4>\n        </mat-list-item>\n      </a>\n      <a routerLink=\"/transacties\" routerLinkActive=\"activebutton\" ariaCurrentWhenActive=\"page\">\n        <mat-list-item>\n          <fa-icon [icon]=\"faDollarSign\" [fixedWidth]=\"true\"></fa-icon>\n          <h4>Transacties</h4>\n        </mat-list-item>\n      </a>\n      <a routerLink=\"/inzichten\" routerLinkActive=\"activebutton\" ariaCurrentWhenActive=\"page\">\n        <mat-list-item>\n          <fa-icon [icon]=\"faChartPie\" [fixedWidth]=\"true\"></fa-icon>\n          <h4>Inzichten</h4>\n        </mat-list-item>\n      </a>\n      <a routerLink=\"/regels\" routerLinkActive=\"activebutton\" ariaCurrentWhenActive=\"page\">\n        <mat-list-item>\n          <fa-icon [icon]=\"faNetworkWired\" [fixedWidth]=\"true\"></fa-icon>\n          <h4>Regels</h4>\n        </mat-list-item>\n      </a>\n      <a routerLink=\"/budget\" routerLinkActive=\"activebutton\" ariaCurrentWhenActive=\"page\">\n        <mat-list-item>\n          <fa-icon [icon]=\"faScaleBalanced\" [fixedWidth]=\"true\"></fa-icon>\n          <h4>Budget</h4>\n        </mat-list-item>\n      </a>\n      <a (click)=\"onLogout()\">\n        <mat-list-item>\n          <fa-icon [icon]=\"faRightFromBracket\" [fixedWidth]=\"true\"></fa-icon>\n          <h4>Logout</h4>\n        </mat-list-item>\n      </a>\n\n\n    </mat-nav-list>\n      <button mat-icon-button></button>\n  </mat-drawer>\n  <mat-drawer-content style=\"overflow-y: hidden; overflow-x: hidden\">\n    <router-outlet></router-outlet>\n  </mat-drawer-content>\n</mat-drawer-container>\n"
        },
        {
            "name": "PeriodSelectionComponent",
            "id": "component-PeriodSelectionComponent-335aca2c1e090f252828a8a930335c97ab771705d2b4d4c11058724da057ad96d7d6da160ecd008b1d470e42b1ddb32d8a86475ab2b36bad5228c8844d964583",
            "file": "src/app/period-selection/period-selection.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": "{ provide: DateAdapter, useClass: PickDateAdapter }"
                },
                {
                    "name": "{ provide: MAT_DATE_FORMATS, useValue: PICK_FORMATS }"
                }
            ],
            "selector": "period-selection",
            "styleUrls": [
                "./period-selection.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./period-selection.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "change",
                    "defaultValue": "new EventEmitter<Date[]>(true)",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 60,
                    "type": "EventEmitter<Date[]>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "allowDate",
                    "defaultValue": "function (date: Date | null): boolean {\n    if (!date) {\n      return false;\n    }\n    //check if date is first day of month or last day of month\n    return date.getDate() === 1 || new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate() === date.getDate();\n\n\n\n  }",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "DateFilterFn<any>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 66
                },
                {
                    "name": "displayShortcutsAsDropdown",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "endDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49
                },
                {
                    "name": "formFieldGroup",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 47
                },
                {
                    "name": "ngSelect",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "NgSelectComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "NgSelectComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "periodShortcutDropDownSelection",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63
                },
                {
                    "name": "range",
                    "defaultValue": "new FormGroup({\n    start: new FormControl<Date | null>(null),\n    end: new FormControl<Date | null>(null),\n  })",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "startDate",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 48
                },
                {
                    "name": "startEndDateShortCuts",
                    "defaultValue": "new Map<string, StartEndDateShortcut>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | StartEndDateShortcut>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52
                },
                {
                    "name": "startEndDateShortCutStringValues",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53
                }
            ],
            "methodsClass": [
                {
                    "name": "doFileter",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 172,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getDropdownKeys",
                    "args": [],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 107,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnChanges",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 111,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 92,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onDropDownChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 145,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nwe cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n",
                    "description": "<p>we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround</p>\n",
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 5265,
                                "end": 5272,
                                "kind": 80,
                                "id": 0,
                                "flags": 16842752,
                                "transformFlags": 0,
                                "escapedText": "returns"
                            },
                            "comment": ""
                        }
                    ]
                },
                {
                    "name": "onPeriodShortCutClick",
                    "args": [
                        {
                            "name": "periodStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 120,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "periodStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatLabel"
                },
                {
                    "name": "MatDateRangeInput"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatStartDate"
                },
                {
                    "name": "MatEndDate"
                },
                {
                    "name": "MatDatepickerToggle"
                },
                {
                    "name": "MatSuffix"
                },
                {
                    "name": "MatDateRangePicker"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "MatSelect"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatOption"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { formatDate, NgIf, NgFor } from '@angular/common';\nimport {Component, EventEmitter, OnChanges, OnInit, Output, ViewChild} from '@angular/core';\nimport { FormBuilder, FormControl, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { DateAdapter, MAT_DATE_FORMATS, NativeDateAdapter, MatOption } from '@angular/material/core';\nimport {NgSelectComponent} from '@ng-select/ng-select';\nimport {AppService} from '../app.service';\nimport {StartEndDateShortcut} from '../model';\nimport { DateFilterFn, MatDateRangeInput, MatStartDate, MatEndDate, MatDatepickerToggle, MatDateRangePicker } from \"@angular/material/datepicker\";\nimport { MatFormField, MatLabel, MatSuffix } from '@angular/material/form-field';\nimport { MatButton } from '@angular/material/button';\nimport { MatSelect } from '@angular/material/select';\n\nexport const PICK_FORMATS = {\n  parse: { dateInput: { month: 'short', year: 'numeric', day: 'numeric' } },\n  display: {\n    dateInput: 'input',\n    monthYearLabel: { year: 'numeric', month: 'short' },\n    dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },\n    monthYearA11yLabel: { year: 'numeric', month: 'long' }\n  }\n};\n\nclass PickDateAdapter extends NativeDateAdapter {\n\n  override format(date: Date, displayFormat: Object): string {\n    if (displayFormat === 'input') {\n      return formatDate(date, 'dd-MMM-yyyy', this.locale);\n    } else {\n      return date.toDateString();\n    }\n  }\n}\n\n@Component({\n    selector: 'period-selection',\n    templateUrl: './period-selection.component.html',\n    styleUrls: ['./period-selection.component.scss'],\n    providers: [\n        { provide: DateAdapter, useClass: PickDateAdapter },\n        { provide: MAT_DATE_FORMATS, useValue: PICK_FORMATS }\n    ],\n    standalone: true,\n    imports: [MatFormField, MatLabel, MatDateRangeInput, FormsModule, ReactiveFormsModule, MatStartDate, MatEndDate, MatDatepickerToggle, MatSuffix, MatDateRangePicker, NgIf, MatButton, MatSelect, NgFor, MatOption]\n})\nexport class PeriodSelectionComponent implements OnInit, OnChanges {\n\n  formFieldGroup: FormGroup;\n  startDate: any;\n  endDate: any;\n\n\n  startEndDateShortCuts: Map<string, StartEndDateShortcut> = new Map<string, StartEndDateShortcut>();\n  startEndDateShortCutStringValues: string[];\n\n  range = new FormGroup({\n    start: new FormControl<Date | null>(null),\n    end: new FormControl<Date | null>(null),\n  });\n\n  @Output() change: EventEmitter<Date[]> = new EventEmitter<Date[]>(true);\n\n  displayShortcutsAsDropdown: boolean = true;\n  periodShortcutDropDownSelection!: string;\n  @ViewChild(NgSelectComponent) ngSelect!: NgSelectComponent;\n\n  allowDate: DateFilterFn<any> = function (date: Date | null): boolean {\n    if (!date) {\n      return false;\n    }\n    //check if date is first day of month or last day of month\n    return date.getDate() === 1 || new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate() === date.getDate();\n\n\n\n  };\n\n  constructor(private appService: AppService, private formBuilder: FormBuilder) {\n      this.formFieldGroup = formBuilder.group({ queryForm: \"\" });\n\n    this.startEndDateShortCuts.set(\"huidige maand\", StartEndDateShortcut.CURRENT_MONTH);\n    this.startEndDateShortCuts.set(\"vorige maand\", StartEndDateShortcut.PREVIOUS_MONTH);\n    this.startEndDateShortCuts.set(\"huidig kwartaal\", StartEndDateShortcut.CURRENT_QUARTER);\n    this.startEndDateShortCuts.set(\"vorig kwartaal\", StartEndDateShortcut.PREVIOUS_QUARTER);\n    this.startEndDateShortCuts.set(\"huidig jaar\", StartEndDateShortcut.CURRENT_YEAR);\n    this.startEndDateShortCuts.set(\"vorig jaar\", StartEndDateShortcut.PREVIOUS_YEAR);\n    this.startEndDateShortCuts.set(\"alles\", StartEndDateShortcut.ALL);\n    this.startEndDateShortCutStringValues = Array.from(this.startEndDateShortCuts.keys());\n\n\n  }\n\n  ngOnInit() {\n    this.appService.resolveStartEndDateShortcut(StartEndDateShortcut.ALL).subscribe(resolved => {\n      this.range.controls.start = new FormControl<Date>(new Date(resolved.start));\n      this.range.controls.end = new FormControl<Date>(new Date(resolved.end));\n      this.startDate = resolved.start;\n      this.endDate = resolved.end;\n      this.change.emit([this.startDate, this.endDate]);\n      this.appService.setStartAndEndDate(this.startDate, this.endDate);\n\n    })\n\n\n\n  }\n\n  getDropdownKeys(): string[] {\n    return Array.from(this.startEndDateShortCuts.keys())\n  }\n\n  ngOnChanges() {\n    let startDate = new Date(this.startDate);\n    let endDate = new Date(this.endDate);\n    this.change.emit([startDate, endDate]);\n    this.appService.setStartAndEndDate(startDate, endDate);\n  }\n\n\n\n  onPeriodShortCutClick(periodStr: string) {\n\n    var shortCut: StartEndDateShortcut | undefined = this.startEndDateShortCuts.get(periodStr);\n    if (shortCut == undefined) {\n      shortCut = StartEndDateShortcut.ALL;\n    }\n\n    this.appService.resolveStartEndDateShortcut(shortCut).subscribe(resolved => {\n\n      this.range.controls.start.setValue(new Date(resolved.start));\n      this.range.controls.end.setValue(new Date(resolved.end));\n      this.startDate = resolved.start;\n      this.endDate = resolved.end;\n      this.ngOnChanges();\n\n    })\n\n\n  }\n\n\n  /**\n   * we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n   * @returns\n   */\n  onDropDownChange() {\n    if (this.periodShortcutDropDownSelection === null || this.periodShortcutDropDownSelection === undefined) {\n        return;\n    }\n\n    var shortCut: StartEndDateShortcut | undefined = this.startEndDateShortCuts.get(this.periodShortcutDropDownSelection);\n    if (shortCut == undefined) {\n      shortCut = StartEndDateShortcut.ALL;\n    }\n\n    this.appService.resolveStartEndDateShortcut(shortCut).subscribe(resolved => {\n\n      this.range.controls.start.setValue(new Date(resolved.start));\n      this.range.controls.end.setValue(new Date(resolved.end));\n      this.startDate = resolved.start;\n      this.endDate = resolved.end;\n      this.ngOnChanges();\n\n    })\n\n\n\n\n\n  }\n\n\n  doFileter() {\n\n\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "\n/* TODO(mdc-migration): The following rule targets internal classes of form-field that may no longer apply for the MDC version. */\n::ng-deep .mat-form-field-appearance-fill .mat-form-field-flex {\r\n    background-color: #fff;\r\n  }\r\n\r\n  .grid-container {\r\n    display: grid;\r\n    grid-template-columns: 50px 1fr;\r\n    grid-gap: 20px;\r\n}",
                    "styleUrl": "./period-selection.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 75,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<!-- <div formGroupName=\"startEndDateFormFieldGroup\"  [formGroup]=\"startEndDateFormFieldGroup\" class=\"inline_block\" style=\"width: 100%;\"> -->\n<div class=\"inline_block\" style=\" padding-right: 10px\">\n  <mat-form-field appearance=\"fill\" style=\"min-width: 290px; width: 100% \">\n    <mat-label style=\";\">Kies periode</mat-label>\n    <mat-date-range-input [formGroup]=\"range\" [rangePicker]=\"picker\" [dateFilter]=\"allowDate\">\n      <input matStartDate placeholder=\"Startdatum\" formControlName=\"start\" (dateChange)=\"ngOnChanges()\"\n        [value]=\"startDate\">\n      <input matEndDate placeholder=\"Einddatum\" formControlName=\"end\" (dateChange)=\"ngOnChanges()\" [value]=\"endDate\">\n    </mat-date-range-input>\n    <!-- <mat-hint>DD/MM/YYYY – DD/MM/YYYY</mat-hint> -->\n    <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n    <mat-date-range-picker #picker></mat-date-range-picker>\n  </mat-form-field>\n</div>\n\n<div *ngIf=\"displayShortcutsAsDropdown===false\"\n  style=\" padding-top: 2px;padding-bottom: 30px; border-style: solid; border-width: 1px; border-color: lightgray;\"\n  class=\"inline_block\">\n  <p style=\"text-align: center; font-style: italic; text-decoration: underline;\">shortcuts periode</p>\n  <div class=\"grid-container\" style=\"margin-bottom: 5px;\">\n    <div class=\"grid-child\" style=\"margin-left: 5px; margin-right: 15px;font-style: italic;\">jaar</div>\n    <div class=\"grid-child\">\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('huidig jaar')\"\n        style=\"margin-left: 5px; margin-right:5px; width: 50px;\">huidig</button>\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('vorig jaar')\"\n        style=\"margin-right:5px; width: 50px;\">vorig</button>\n    </div>\n  </div>\n  <div class=\"grid-container\" style=\"margin-bottom: 5px;\">\n    <div class=\"grid-child\" style=\"margin-left: 5px; margin-right: 15px;font-style: italic\">maand</div>\n    <div class=\"grid-child\">\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('huidige maand')\"\n        style=\"margin-left: 5px;margin-right:5px; width: 50px;\">huidige</button>\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('vorige maand')\"\n        style=\"margin-right:5px; width: 50px;\">vorige</button>\n    </div>\n  </div>\n  <div class=\"grid-container\" style=\"margin-bottom: 5px;\">\n    <div class=\"grid-child\" style=\"margin-left: 5px; margin-right: 15px;font-style: italic\">kwartaal</div>\n    <div class=\"grid-child\">\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('huidig kwartaal')\"\n        style=\"margin-left: 5px;margin-right:5px; width: 50px;\">huidig</button>\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('vorig kwartaal')\"\n        style=\"margin-right:5px; width: 50px;\">vorig</button>\n    </div>\n  </div>\n  <div class=\"grid-container\" style=\"margin-bottom: 5px;\">\n    <div class=\"grid-child\" style=\"margin-left: 5px; margin-right: 15px;font-style: italic\">alles</div>\n    <div class=\"grid-child\">\n      <button mat-raised-button (click)=\"onPeriodShortCutClick('alles')\"\n        style=\"margin-left: 5px;margin-right:5px; width: 50px;\">alles</button>\n    </div>\n  </div>\n</div>\n\n<!-- <div *ngIf=\"displayShortcutsAsDropdown===true\" class=\"inline_block\"\n  style=\"min-width: 290px;font: larger; min-height:100px;\">\n  <ng-select style=\"font-size: larger; height:30px\" [items]=\"getDropdownKeys()\" autofocus\n    (ngModel)=\"periodShortcutDropDownSelection\" (change)=\"onDropDownChange()\" placeholder=\"Snelkoppeling periode\">\n  </ng-select>\n</div> -->\n\n<div *ngIf=\"displayShortcutsAsDropdown===true\" [formGroup]=\"formFieldGroup\" class=\"inline_block\">\n  <mat-form-field appearance=\"fill\" style=\"width: 100%;\" >\n    <mat-label>Snelkoppeling periode</mat-label>\n    <mat-select placeholder=\"Rekening\" name=\"rekening\" [(value)]=\"periodShortcutDropDownSelection\" (selectionChange)=\"onDropDownChange()\">\n      <mat-option *ngFor=\"let period of getDropdownKeys()\" [value]=\"period\">\n        {{period}}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</div>\n"
        },
        {
            "name": "ProfileComponent",
            "id": "component-ProfileComponent-aa299b4d00c421929a9fe328f5f2940ead41963dd770517cb1f705fe6efb868c45dac65c40947d72100c49c52586546142a53c42319e380b748f24a5bed314ab",
            "file": "src/app/profile/profile.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-profile",
            "styleUrls": [
                "./profile.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./profile.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "bankAccounts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccount[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "currentUser",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "User",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "dataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTableDataSource<BankAccount>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "displayedColumns",
                    "defaultValue": "['accountNumber', 'alias', 'saveOrEditButton']",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "faSearch",
                    "defaultValue": "faSearch",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 77,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "hidePassword",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 58,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "saveAlias",
                    "args": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 70,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "bankAccount",
                            "type": "BankAccount",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatToolbar"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatCard"
                },
                {
                    "name": "MatCardContent"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatInput"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "MatSuffix"
                },
                {
                    "name": "MatIcon"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                },
                {
                    "name": "UpperCasePipe",
                    "type": "pipe"
                },
                {
                    "name": "IbanPipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport {AuthService} from \"../auth/auth.service\";\nimport {User} from \"../model\";\nimport {FormBuilder, FormGroup, FormsModule, ReactiveFormsModule} from \"@angular/forms\";\nimport {AppService} from \"../app.service\";\nimport {\n  MatCell,\n  MatCellDef,\n  MatColumnDef,\n  MatHeaderCell,\n  MatHeaderCellDef,\n  MatHeaderRow,\n  MatHeaderRowDef,\n  MatRow,\n  MatRowDef,\n  MatTable,\n  MatTableDataSource\n} from \"@angular/material/table\";\nimport {faSearch} from \"@fortawesome/free-solid-svg-icons/faSearch\";\nimport {BankAccount} from \"@daanvdn/budget-assistant-client\";\nimport {MatToolbar} from '@angular/material/toolbar';\nimport {MatCard, MatCardContent} from '@angular/material/card';\nimport {MatFormField, MatSuffix} from '@angular/material/form-field';\nimport {MatInput} from '@angular/material/input';\nimport {MatIconButton} from '@angular/material/button';\nimport {MatIcon} from '@angular/material/icon';\nimport {NgIf, UpperCasePipe} from '@angular/common';\nimport {IbanPipe} from '../iban.pipe';\n\n@Component({\n    selector: 'app-profile',\n    templateUrl: './profile.component.html',\n    styleUrls: ['./profile.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, FormsModule, ReactiveFormsModule, MatCard, MatCardContent, MatFormField, MatInput, MatIconButton, MatSuffix, MatIcon, NgIf, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, UpperCasePipe, IbanPipe]\n})\nexport class ProfileComponent implements OnInit {\n\n  currentUser!: User;\n  hidePassword = true;\n  form: FormGroup;\n  bankAccounts!: BankAccount[];\n  displayedColumns: string[] = ['accountNumber', 'alias', 'saveOrEditButton'];\n  dataSource!: MatTableDataSource<BankAccount>;\n\n\n  constructor(private authService : AuthService, private fb: FormBuilder, private appService: AppService) {\n    this.form = this.fb.group({\n      password: \"\"\n    });\n\n\n\n  }\n\n\n\n  ngOnInit(): void {\n    this.authService.getUserObservable().subscribe(u => {\n      this.currentUser = u;\n    })\n    this.appService.fetchBankAccountsForUser().subscribe(bankAccounts => {\n      this.bankAccounts = bankAccounts;\n      this.dataSource = new MatTableDataSource(this.bankAccounts);\n    });\n  }\n\n\n\n  saveAlias(bankAccount: BankAccount): void {\n\n\n    this.appService.saveBankAccountAlias(bankAccount).subscribe(() => {});\n  }\n\n\n  protected readonly faSearch = faSearch;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".label {\r\n  width: 120px; /* Adjust the width as needed */\r\n  display: inline-block;\r\n  padding-right: 10px;\r\n  text-align: left;\r\n}\r\n.card-content-wrapper {\r\n  display: flex;\r\n  flex-direction: row; /* Arranges them side by side */\r\n  justify-content: space-between; /* Distributes space evenly between them */\r\n}\r\n\r\n.default-items {\r\n  padding-right: 20px;\r\n  // font-weight: lighter;\r\n  //margin: 8px 8px;\r\n  max-width: 100%;\r\n  white-space: nowrap;\r\n}\r\n\r\n.table-header{\r\n  text-align: left;\r\n}\r\n\r\n.toolbar-container {\r\n  display: flex;\r\n  justify-content: center;\r\n  height: 8vh;\r\n}\r\n",
                    "styleUrl": "./profile.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 44,
                "jsdoctags": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<mat-toolbar color=\"primary\" class=\"toolbar-container\">\n    <span class=\"title\">Profile</span>\n</mat-toolbar>\n<div  [formGroup]=\"form\">\n  <div class=\"mat-z8\" >\n\n    <mat-card appearance=\"outlined\">\n      <h2 style=\"padding-top: 5px; padding-bottom: 5px\">Account</h2>\n      <div class=\"card-content-wrapper\">\n        <mat-card-content>\n\n          <p>\n            <span class=\"label\">Naam: </span>\n            <span style=\"font-style: italic\">{{ currentUser!.firstName }} {{ currentUser!.lastName }}</span>\n          </p>\n          <p>\n            <span class=\"label\">Gebruikersnaam: </span>\n            <span style=\"font-style: italic\">{{ currentUser!.userName }}</span>\n          </p>\n          <p>\n            <span class=\"label\">Paswoord: </span>\n            <span>\n              <mat-form-field style=\"font-style: italic\">\n                <input matInput [type]=\"hidePassword ? 'password' : 'text'\"\n                       formControlName=\"password\" [(ngModel)]=\"currentUser!.password\" name=\"password\"\n                       style=\"width: auto; max-width: none;\" readonly>\n                <button mat-icon-button matSuffix (mousedown)=\"hidePassword = false\" (mouseup)=\"hidePassword = true\"\n                        [attr.aria-label]=\"hidePassword ? 'Toon paswoord' : 'Verberg paswoord'\">\n                  <mat-icon>{{ hidePassword ? 'visibility_off' : 'visibility' }}</mat-icon>\n                </button>\n              </mat-form-field>\n            </span>\n          </p>\n\n        </mat-card-content>\n      </div>\n    </mat-card>\n    <mat-card appearance=\"outlined\" style=\"margin-top: 5px\" *ngIf=\"dataSource\">\n      <h2 style=\"padding-top: 5px; padding-bottom: 5px\">Rekeningen</h2>\n      <div class=\"card-content-wrapper\">\n        <mat-card-content>\n          <table mat-table [dataSource]=\"dataSource\" class=\"mat-z8\" style=\"border-collapse: separate\">\n            <!-- Account Number Column -->\n            <ng-container matColumnDef=\"accountNumber\">\n              <th class=\"table-header\" mat-header-cell *matHeaderCellDef>Rekeningnummer</th>\n              <td mat-cell *matCellDef=\"let bankAccount\">\n                <div class=\"default-items\">\n                  {{ bankAccount.accountNumber | uppercase | iban }}\n                </div>\n              </td>\n            </ng-container>\n\n            <!-- Alias Column -->\n            <ng-container matColumnDef=\"alias\">\n              <th class=\"table-header\" mat-header-cell *matHeaderCellDef  style=\"min-width: 300px\">Alias</th>\n              <td mat-cell *matCellDef=\"let bankAccount\"  style=\"min-width: 300px\">\n                <div *ngIf=\"!bankAccount.editAlias; else edit\" class=\"default-items\">\n                  <span *ngIf=\"bankAccount.alias; else noAlias\" style=\"font-weight: bold\" class=\"default-items\">{{bankAccount.alias |uppercase }}</span>\n                  <ng-template #noAlias>\n                    <span style=\"font-style: italic\" class=\"default-items\">This account has no alias. Please add an alias</span>\n                  </ng-template>\n\n                </div>\n                <ng-template #edit>\n                  <div class=\"default-items\" style=\"min-width: 300px\">\n                    <input style=\"min-width: 300px\" [(ngModel)]=\"bankAccount.alias\"\n                           [ngModelOptions]=\"{standalone: true}\">\n                  </div>\n                </ng-template>\n              </td>\n            </ng-container>\n            <!-- SaveOrEditButton Column -->\n            <ng-container matColumnDef=\"saveOrEditButton\">\n              <th mat-header-cell *matHeaderCellDef></th>\n              <td mat-cell *matCellDef=\"let bankAccount\">\n                <button *ngIf=\"!bankAccount.editAlias; else edit\" mat-icon-button\n                        (click)=\"bankAccount.editAlias = true\">\n                  <mat-icon>edit</mat-icon>\n                </button>\n                <ng-template #edit>\n                  <button mat-icon-button (click)=\"saveAlias(bankAccount)\">\n                    <mat-icon>save</mat-icon>\n                  </button>\n                </ng-template>\n              </td>\n            </ng-container>\n\n            <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n            <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\n          </table>\n        </mat-card-content>\n      </div>\n    </mat-card>\n  </div>\n</div>\n\n\n\n"
        },
        {
            "name": "QueryBuilderComponent",
            "id": "component-QueryBuilderComponent-1e1147c4509ff29e4477775298d115a94a87726aec3cf64cb8cd8cf9946916cf01c5fe330c55ffa32e538e98f0c8f48bcb05c838b962fcf674b8c8d5617aa1fb",
            "file": "src/app/query-builder/query-builder.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [
                {
                    "name": "CONTROL_VALUE_ACCESSOR"
                },
                {
                    "name": "VALIDATOR"
                }
            ],
            "selector": "query-builder",
            "styleUrls": [
                "./query-builder.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./query-builder.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "allowCollapse",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 142,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "allowRuleset",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 141,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "classNames",
                    "defaultValue": "{}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 144,
                    "type": "QueryBuilderClassNames",
                    "decorators": []
                },
                {
                    "name": "config",
                    "defaultValue": "{fields: {}}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 147,
                    "type": "QueryBuilderConfig",
                    "decorators": []
                },
                {
                    "name": "data",
                    "defaultValue": "new RuleSet('and', [])",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 130,
                    "type": "RuleSet",
                    "decorators": []
                },
                {
                    "name": "disabled",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 129,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "emptyMessage",
                    "defaultValue": "'A ruleset cannot be empty. Please add a rule or remove it all together.'",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 143,
                    "type": "string",
                    "decorators": []
                },
                {
                    "name": "operatorMap",
                    "defaultValue": "{}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 145,
                    "type": "literal type",
                    "decorators": []
                },
                {
                    "name": "parentChangeCallback",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 150,
                    "type": "function",
                    "decorators": []
                },
                {
                    "name": "parentTouchedCallback",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 151,
                    "type": "function",
                    "decorators": []
                },
                {
                    "name": "parentValue",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 146,
                    "type": "RuleSet",
                    "decorators": []
                },
                {
                    "name": "persistValueOnFieldChange",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 152,
                    "type": "boolean",
                    "decorators": []
                },
                {
                    "name": "value",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 300,
                    "type": "RuleSet",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "defaultClassNames",
                    "defaultValue": "{\n    arrowIconButton: 'q-arrow-icon-button',\n    arrowIcon: 'q-icon q-arrow-icon',\n    removeIcon: 'q-icon q-remove-icon',\n    addIcon: 'q-icon q-add-icon',\n    button: 'q-button',\n    buttonGroup: 'q-button-group',\n    removeButton: 'q-remove-button',\n    switchGroup: 'q-switch-group',\n    switchLabel: 'q-switch-label',\n    switchRadio: 'q-switch-radio',\n    rightAlign: 'q-right-align',\n    transition: 'q-transition',\n    collapsed: 'q-collapsed',\n    treeContainer: 'q-tree-container',\n    tree: 'q-tree',\n    row: 'q-row',\n    connector: 'q-connector',\n    rule: 'q-rule',\n    ruleSet: 'q-ruleset',\n    invalidRuleSet: 'q-invalid-ruleset',\n    emptyWarning: 'q-empty-warning',\n    fieldControl: 'q-field-control',\n    fieldControlSize: 'q-control-size',\n    operatorControl: 'q-operator-control',\n    operatorControlSize: 'q-control-size',\n    inputControl: 'q-input-control',\n    inputControlSize: 'q-control-size'\n  }",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "QueryBuilderClassNames",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 100,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "fieldNames",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 97,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "fields",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Field[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 95,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "filterFields",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Field[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 96,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "getDisabledState",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 330
                },
                {
                    "name": "MATCH_TYPES",
                    "defaultValue": "MATCH_TYPES",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 92,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "onChangeCallback",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 138,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "onTouchedCallback",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "function",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 139,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "panelOpenState",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 98,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "RuleUtils",
                    "defaultValue": "RuleUtils",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 93,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "treeContainer",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ElementRef",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 154,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'treeContainer', {static: true}"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "typeToFieldMapWrapper",
                    "defaultValue": "new FieldsMetaData()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 94,
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "addRule",
                    "args": [
                        {
                            "name": "parent",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 436,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "parent",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "addRuleSet",
                    "args": [
                        {
                            "name": "parent",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 578,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "parent",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "addStringValue",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "expansionPanel",
                            "type": "MatExpansionPanel",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 233,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "expansionPanel",
                            "type": "MatExpansionPanel",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "changeCondition",
                    "args": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 638,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "changeField",
                    "args": [
                        {
                            "name": "field",
                            "type": "Field",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 698,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "Field",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "changeFieldArray",
                    "args": [
                        {
                            "name": "field",
                            "type": "Field[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 719,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "Field[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "changeFieldMatchType",
                    "args": [
                        {
                            "name": "fieldMatchType",
                            "type": "RuleMatchType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 665,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fieldMatchType",
                            "type": "RuleMatchType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "changeFieldType",
                    "args": [
                        {
                            "name": "fieldType",
                            "type": "FieldType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 756,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fieldType",
                            "type": "FieldType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "changeInput",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 688,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "changeOperator",
                    "args": [
                        {
                            "name": "value",
                            "type": "Operator",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 652,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "type": "Operator",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "changeValueMatchType",
                    "args": [
                        {
                            "name": "valueMatchType",
                            "type": "RuleMatchType",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 676,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "valueMatchType",
                            "type": "RuleMatchType",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "checkEmptyRuleInRuleset",
                    "args": [
                        {
                            "name": "ruleset",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 788,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "ruleset",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "compareMatSelectItems",
                    "args": [
                        {
                            "name": "o1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "o2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 171,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "o1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "o2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "computedTreeContainerHeight",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 631,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "currentRuleIsInvalid",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 432,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "currentRuleSetIsInvalid",
                    "args": [
                        {
                            "name": "ruleSet",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 419,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "ruleSet",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "fieldValueIsEmpty",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 884,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getClassNames",
                    "args": [
                        {
                            "name": "args",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "dotDotDotToken": true
                        }
                    ],
                    "optional": false,
                    "returnType": "any | []",
                    "typeParameters": [],
                    "line": 386,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "args",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "dotDotDotToken": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFieldsForSelectedType",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Field[]",
                    "typeParameters": [],
                    "line": 335,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getFieldTypes",
                    "args": [],
                    "optional": false,
                    "returnType": "string[]",
                    "typeParameters": [],
                    "line": 821,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getOperatorsForSelectedType",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Operator[]",
                    "typeParameters": [],
                    "line": 365,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getOptionsForField",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "Option[]",
                    "typeParameters": [],
                    "line": 343,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getQueryItemClassName",
                    "args": [
                        {
                            "name": "local",
                            "type": "LocalRuleMeta",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 779,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "local",
                            "type": "LocalRuleMeta",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "handleDataChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 802,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "handleFormForRule",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 463,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "handleTouched",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 812,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 193,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "oneControlIsNotEmptyValidator",
                    "args": [
                        {
                            "name": "controlNames",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "ValidatorFn",
                    "typeParameters": [],
                    "line": 394,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ],
                    "jsdoctags": [
                        {
                            "name": "controlNames",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "recurivelySetRuleFormField",
                    "args": [
                        {
                            "name": "ruleSet",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 177,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "ruleSet",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnChange",
                    "args": [
                        {
                            "name": "fn",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 315,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "registerOnTouched",
                    "args": [
                        {
                            "name": "fn",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 319,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "fn",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "removeRule",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "parent",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 564,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "parent",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "removeRuleSet",
                    "args": [
                        {
                            "name": "ruleset",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        },
                        {
                            "name": "parent",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 605,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "ruleset",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "parent",
                            "type": "RuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "optional": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "removeStringValueFromStringField",
                    "args": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 218,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "index",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "requireExpansionPanelOpen",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 896,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setDisabledState",
                    "args": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 323,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "isDisabled",
                            "type": "boolean",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showEmptyFieldNameError",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 830,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showFieldMatchTypeError",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 848,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showOperatorError",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 860,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showValueMatchTypeError",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "boolean",
                    "typeParameters": [],
                    "line": 872,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "submitHandler",
                    "args": [
                        {
                            "name": "e",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 229,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "e",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "toggleCollapse",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 624,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "transitionEnd",
                    "args": [
                        {
                            "name": "e",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 620,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "e",
                            "type": "Event",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "validate",
                    "args": [
                        {
                            "name": "control",
                            "type": "AbstractControl",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "ValidationErrors | null",
                    "typeParameters": [],
                    "line": 279,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "control",
                            "type": "AbstractControl",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "writeValue",
                    "args": [
                        {
                            "name": "obj",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 311,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "obj",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [
                {
                    "name": "attr.query-builder-condition",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 133,
                    "type": "any",
                    "decorators": []
                }
            ],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgClass"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatSelect"
                },
                {
                    "name": "MatOption"
                },
                {
                    "name": "NgSwitch"
                },
                {
                    "name": "NgSwitchCase"
                },
                {
                    "name": "MatError"
                },
                {
                    "name": "MatExpansionPanel"
                },
                {
                    "name": "MatExpansionPanelHeader"
                },
                {
                    "name": "MatInput"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "MatIcon"
                },
                {
                    "name": "MatCheckbox"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { AbstractControl, ControlValueAccessor, FormBuilder, NG_VALIDATORS, NG_VALUE_ACCESSOR, ValidationErrors, Validator, ValidatorFn, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport {\n  CategoricalOperators, Comparator,\n  Field, FieldType,\n  LocalRuleMeta,\n  MATCH_TYPES, MatchTypes,\n  MultiMap, NumericalOperators, Operator,\n  Option,\n  QueryBuilderClassNames,\n  QueryBuilderConfig,\n  Rule,\n  RuleSet,\n  RuleUtils, StringOperators\n} from './query-builder.interfaces';\nimport {\n  ChangeDetectorRef, Component, ElementRef, forwardRef, HostBinding, Input, OnChanges, SimpleChanges, ViewChild\n} from '@angular/core';\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport {AppService} from \"../app.service\";\nimport { MatExpansionPanel, MatExpansionPanelHeader } from \"@angular/material/expansion\";\nimport { NgClass, NgIf, NgFor, NgSwitch, NgSwitchCase } from '@angular/common';\nimport { MatButton, MatIconButton } from '@angular/material/button';\nimport { MatFormField, MatError } from '@angular/material/form-field';\nimport { MatSelect } from '@angular/material/select';\nimport { MatOption } from '@angular/material/core';\nimport { MatInput } from '@angular/material/input';\nimport { MatIcon } from '@angular/material/icon';\nimport { MatCheckbox } from '@angular/material/checkbox';\nimport {FieldTypeEnum, RuleMatchType, RuleOperator} from \"@daanvdn/budget-assistant-client\";\nimport {ConditionEnum} from \"@daanvdn/budget-assistant-client\";\n\n\nexport class FieldsMetaData {\n\n  type2fields = new MultiMap<string, Field>();\n  field2Type = new Map<string, string>;\n\n\n  fieldToOptions = new MultiMap<string, Option>();\n\n  public registerField(field: Field): void {\n    this.type2fields.set(field.type, field);\n    this.field2Type.set(field.name as string, field.type);\n\n    if (field.options) {\n      for (const option of field.options) {\n        this.fieldToOptions.set(field.name as string, option);\n      }\n    }\n\n  }\n\n  public getFieldTypes(): string[] {\n    return this.type2fields.keys();\n  }\n\n  public getFieldType(field: string) {\n    let type = this.field2Type.get(field);\n    if (!type) {\n      return null;\n    }\n\n    return type;\n  }\n\n\n}\n\nexport const CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => QueryBuilderComponent),\n  multi: true\n};\n\nexport const VALIDATOR: any = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => QueryBuilderComponent),\n  multi: true\n};\n\n\n@Component({\n    selector: 'query-builder',\n    templateUrl: './query-builder.component.html',\n    styleUrls: ['./query-builder.component.scss'],\n    providers: [CONTROL_VALUE_ACCESSOR, VALIDATOR],\n    standalone: true,\n    imports: [NgClass, NgIf, FormsModule, NgFor, MatButton, ReactiveFormsModule, MatFormField, MatSelect, MatOption, NgSwitch, NgSwitchCase, MatError, MatExpansionPanel, MatExpansionPanelHeader, MatInput, MatIconButton, MatIcon, MatCheckbox]\n})\nexport class QueryBuilderComponent implements OnChanges, ControlValueAccessor, Validator {\n\n  protected readonly MATCH_TYPES = MATCH_TYPES;\n  protected readonly RuleUtils = RuleUtils;\n  public typeToFieldMapWrapper = new FieldsMetaData();\n  public fields: Field[];\n  public filterFields: Field[];\n  public fieldNames: string[];\n  public panelOpenState: boolean = true;\n\n  public defaultClassNames: QueryBuilderClassNames = {\n    arrowIconButton: 'q-arrow-icon-button',\n    arrowIcon: 'q-icon q-arrow-icon',\n    removeIcon: 'q-icon q-remove-icon',\n    addIcon: 'q-icon q-add-icon',\n    button: 'q-button',\n    buttonGroup: 'q-button-group',\n    removeButton: 'q-remove-button',\n    switchGroup: 'q-switch-group',\n    switchLabel: 'q-switch-label',\n    switchRadio: 'q-switch-radio',\n    rightAlign: 'q-right-align',\n    transition: 'q-transition',\n    collapsed: 'q-collapsed',\n    treeContainer: 'q-tree-container',\n    tree: 'q-tree',\n    row: 'q-row',\n    connector: 'q-connector',\n    rule: 'q-rule',\n    ruleSet: 'q-ruleset',\n    invalidRuleSet: 'q-invalid-ruleset',\n    emptyWarning: 'q-empty-warning',\n    fieldControl: 'q-field-control',\n    fieldControlSize: 'q-control-size',\n    operatorControl: 'q-operator-control',\n    operatorControlSize: 'q-control-size',\n    inputControl: 'q-input-control',\n    inputControlSize: 'q-control-size'\n  };\n  @Input() disabled = false;\n  @Input() data: RuleSet = new RuleSet('and', []);\n\n\n  @HostBinding('attr.query-builder-condition') get condition() {\n    return this.data?.condition;\n  }\n\n  // For ControlValueAccessor interface\n  public onChangeCallback!: () => void;\n  public onTouchedCallback!: () => any;\n\n  @Input() allowRuleset = true;\n  @Input() allowCollapse = false;\n  @Input() emptyMessage = 'A ruleset cannot be empty. Please add a rule or remove it all together.';\n  @Input() classNames: QueryBuilderClassNames = {};\n  @Input() operatorMap: { [key: string]: string[] } = {};\n  @Input() parentValue?: RuleSet;\n  @Input() config: QueryBuilderConfig = {fields: {}};\n\n\n  @Input() parentChangeCallback!: () => void;\n  @Input() parentTouchedCallback!: () => void;\n  @Input() persistValueOnFieldChange = false;\n\n  @ViewChild('treeContainer', {static: true}) treeContainer!: ElementRef;\n\n\n  constructor(private changeDetectorRef: ChangeDetectorRef, private formBuilder: FormBuilder,\n              private errorDialogService: ErrorDialogService, private appService: AppService\n  ) {\n    this.fields = [];\n    this.fieldNames = [];\n    this.filterFields = [];\n\n  }\n\n  // ----------OnInit Implementation----------\n\n  // ----------OnChanges Implementation----------\n\n\n  compareMatSelectItems(o1: any, o2: any): boolean {\n\n    return new Comparator().equals(o1, o2);\n\n  }\n\n  recurivelySetRuleFormField(ruleSet: RuleSet): void {\n    if (ruleSet.rules) {\n      for (let rule of ruleSet.rules) {\n        if (rule.rules) {\n          this.recurivelySetRuleFormField(rule as RuleSet);\n        } else {\n          this.handleFormForRule(rule as Rule);\n        }\n      }\n    }\n\n    this.changeInput();\n\n  }\n\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['data'] && changes['data'].currentValue !== changes['data'].previousValue) {\n      let currentRuleSet: RuleSet = changes['data'].currentValue as RuleSet;\n      this.recurivelySetRuleFormField(currentRuleSet);\n\n    }\n    const config = this.config;\n    const type = typeof config;\n    if (type === 'object') {\n\n      this.fields = Object.keys(config.fields).map((value) => {\n        const field = config.fields[value];\n        field.value = field.value || value;\n        if (field.type && field.type !== 'category') {\n          this.typeToFieldMapWrapper.registerField(field);\n        }\n        return field;\n      });\n\n    } else {\n      throw new Error(`Expected 'config' must be a valid object, got ${type} instead.`);\n    }\n\n  }\n\n  removeStringValueFromStringField(index: number, rule: Rule): void {\n\n    if (this.disabled) {\n      return;\n    }\n    //remove the item in rule.value at the index position\n    rule.value?.splice(index, 1);\n    this.handleDataChange();\n    this.handleTouched();\n  }\n\n  submitHandler(e: any) {\n    e.preventDefault();\n  }\n\n  addStringValue(rule: Rule, expansionPanel: MatExpansionPanel): void {\n    let formcontrol = rule.ruleForm?.get('fieldValueGroup')?.get('inputTextForStringField');\n    if (!formcontrol) {\n      throw new Error(\"Form control not found!\");\n    }\n    let input = formcontrol?.value;\n    if (!input || input === '') {\n\n\n      this.changeDetectorRef.detectChanges(); // Add this line\n      // Wrap the expansionPanel.open() call inside a setTimeout function\n      setTimeout(() => {\n        expansionPanel.open();\n      }, 0);\n      return;\n    }\n    if (rule.value === undefined) {\n      rule.value = [];\n    }\n\n\n    // Check if the value is not already in the array\n    if (rule.value.indexOf(input) === -1) {\n      // Directly push the value to the rule.value array\n      rule.value.push(input);\n      // formcontrol.reset();\n      this.handleTouched();\n      this.handleDataChange();\n      this.changeDetectorRef.detectChanges(); // Add this line\n      // Wrap the expansionPanel.open() call inside a setTimeout function\n      setTimeout(() => {\n        expansionPanel.open();\n      }, 0);\n    }\n    formcontrol.reset();\n\n    this.changeDetectorRef.detectChanges(); // Add this line\n    // Wrap the expansionPanel.open() call inside a setTimeout function\n    setTimeout(() => {\n      expansionPanel.open();\n    }, 0);\n\n  }\n\n  // ----------Validator Implementation----------\n\n  validate(control: AbstractControl): ValidationErrors | null {\n    const errors: { [key: string]: any } = {};\n    const ruleErrorStore = [] as any;\n    let hasErrors = false;\n\n    if (!this.config.allowEmptyRulesets && this.checkEmptyRuleInRuleset(this.data)) {\n      errors['empty'] = 'Empty rulesets are not allowed.';\n      hasErrors = true;\n    }\n\n\n    if (ruleErrorStore.length) {\n      errors['rules'] = ruleErrorStore;\n      hasErrors = true;\n    }\n    return hasErrors ? errors : null;\n  }\n\n  // ----------ControlValueAccessor Implementation----------\n\n  @Input()\n  get value(): RuleSet {\n    return this.data;\n  }\n\n  set value(value: RuleSet) {\n    // When component is initialized without a formControl, null is passed to value\n    this.data = value || new RuleSet('and', []);\n    this.recurivelySetRuleFormField(this.data);\n    this.handleDataChange();\n  }\n\n  writeValue(obj: any): void {\n    this.value = obj;\n  }\n\n  registerOnChange(fn: any): void {\n    this.onChangeCallback = () => fn(this.data);\n  }\n\n  registerOnTouched(fn: any): void {\n    this.onTouchedCallback = () => fn(this.data);\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this.changeDetectorRef.detectChanges();\n  }\n\n  // ----------END----------\n\n  getDisabledState = (): boolean => {\n    return this.disabled;\n  }\n\n\n  getFieldsForSelectedType(rule: Rule): Field[] {\n    if (rule.fieldType) {\n      let fields = this.typeToFieldMapWrapper.type2fields.get(rule.fieldType) as Field[];\n      return fields;\n    }\n    return [];\n  }\n\n  getOptionsForField(rule: Rule): Option[] {\n\n    if (!rule.field) {\n      return [];\n    }\n    if (RuleUtils.fieldIsArray(rule) && (rule.field as any).length > 1) {\n      throw new Error('Expected field to not be an array!');\n\n    }\n\n\n    //get random element from set and get options\n\n    let options = (rule.field as any).options;\n    if (!options) {\n      return [];\n    }\n    return options as Option[];\n\n  }\n\n\n  getOperatorsForSelectedType(rule: Rule): Operator[] {\n    const fieldType = rule.fieldType;\n    if (!fieldType) {\n      return [];\n    }\n    switch (fieldType) {\n      case \"string\":\n        return StringOperators.ALL;\n      case \"number\":\n        return NumericalOperators.ALL;\n      case \"categorical\":\n        return CategoricalOperators.ALL;\n      default:\n        throw new Error(`Unexpected field type: ${fieldType}`);\n\n    }\n\n\n  }\n\n\n  getClassNames(...args: string[]): any | string[] {\n    const clsLookup = this.classNames ? this.classNames : this.defaultClassNames as any;\n    const defaultClassNames = this.defaultClassNames as any;\n    const classNames = args.map((id: any) => clsLookup[id] || defaultClassNames[id]).filter((c: any) => !!c);\n    return classNames.length ? classNames.join(' ') : [];\n  }\n\n\n  public oneControlIsNotEmptyValidator(controlNames: string[]): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      let controls = new Array<AbstractControl>();\n      for (const controlName of controlNames) {\n        controls.push(control.get(controlName) as AbstractControl);\n      }\n\n      //logic to count how many controls are empty\n      let emptyCount = 0;\n      for (const control of controls) {\n        if (control.value == null || control.value === '') {\n          emptyCount++;\n        }\n      }\n      // If all controls are empty, return an error\n      if (emptyCount === controls.length) {\n        // return {oneControlRequired: true};\n        return {oneControlRequired: true};\n      }\n\n      // If at least one control is non-empty, no error\n      return null;\n    };\n  }\n\n  currentRuleSetIsInvalid(ruleSet: RuleSet): boolean {\n    if (ruleSet.rules) {\n      return ruleSet.rules.some((item: RuleSet | any) => {\n        if (item.rules) {\n          return this.currentRuleSetIsInvalid(item);\n        } else {\n          return this.currentRuleIsInvalid(item);\n        }\n      });\n    }\n    return false;\n  }\n\n  currentRuleIsInvalid(rule: Rule): boolean {\n    return !RuleUtils.isValid(rule);\n  }\n\n  addRule(parent?: RuleSet): void {\n    if (this.disabled) {\n      return;\n    }\n\n    parent = parent || this.data;\n    if (parent.rules && parent.rules.length > 0) {\n      //get last item of rules\n      let lastItem = parent.rules[parent.rules.length - 1];\n      if (!(RuleUtils.isRuleSetObject(lastItem)) && this.currentRuleIsInvalid(lastItem as Rule)) {\n        this.errorDialogService.openErrorDialog(\"Error\", \"Please fill out the current rule before adding a new one!\");\n        return;\n      }\n\n\n    }\n\n\n    let rule: Rule = new Rule([], 'string', undefined, [], undefined, undefined, undefined);\n    this.handleFormForRule(rule);\n\n    parent.rules = parent.rules.concat([rule]);\n\n    this.handleTouched();\n    this.handleDataChange();\n  }\n\n  handleFormForRule(rule: Rule) {\n    if (rule.ruleForm) {\n      //the form is already created; nothing to do\n      return;\n    }\n    rule.ruleForm = this.formBuilder.group({\n      fieldType: ['string', Validators.required],\n      fieldMatchType: ['', Validators.required],\n      fieldGroup: this.formBuilder.group({\n        fieldSingle: ['', Validators.required], fieldMultiple: ['', Validators.required],\n      }, {validators: this.oneControlIsNotEmptyValidator(['fieldSingle', 'fieldMultiple'])}),\n      operator: ['', Validators.required],\n      valueMatchType: ['', Validators.required],\n      fieldValueGroup: this.formBuilder.group({\n        inputTextForStringField: ['', /*Validators.required*/], // fieldValueNumber: ['', /*Validators.required*/],\n        // fieldValueDate: ['', /*Validators.required*/],\n        // fieldValueTime: ['', /*Validators.required*/],\n        fieldValueCategorical: ['', /*Validators.required*/], // fieldValueBoolean: ['', /*Validators.required*/],\n      })\n\n    });\n\n    if (rule.fieldType) {\n      let fieldType: AbstractControl = rule.ruleForm.get('fieldType') as AbstractControl;\n      fieldType.setValue(rule.fieldType);\n    }\n\n    rule.ruleForm.get('fieldType')?.valueChanges.subscribe((value) => {\n      this.changeFieldType(value, rule);\n    });\n\n    if (rule.fieldMatchType) {\n      let fieldMatchType = rule.ruleForm.get('fieldMatchType') as AbstractControl;\n      fieldMatchType.setValue(rule.fieldMatchType);\n    }\n    rule.ruleForm.get('fieldMatchType')?.valueChanges.subscribe((value) => {\n      this.changeFieldMatchType(value, rule);\n\n    });\n\n    if (rule.field) {\n      if (RuleUtils.allowMultipleFields(rule)) {\n\n        rule.ruleForm.get(\"fieldGroup\")?.get('fieldMultiple')?.setValue(rule.field);\n      } else {\n\n        rule.ruleForm.get(\"fieldGroup\")?.get('fieldSingle')?.setValue(rule.field);\n      }\n    }\n\n    rule.ruleForm.get(\"fieldGroup\")?.get('fieldMultiple')?.valueChanges.subscribe((value) => {\n      this.changeFieldArray(value, rule);\n    });\n    rule.ruleForm.get(\"fieldGroup\")?.get('fieldSingle')?.valueChanges.subscribe((value) => {\n      this.changeField(value, rule);\n    });\n\n    if (rule.operator) {\n      rule.ruleForm.get('operator')?.setValue(rule.operator);\n    }\n\n    rule.ruleForm.get('operator')?.valueChanges.subscribe((value) => {\n      this.changeOperator(value, rule);\n\n    });\n\n    if (rule.valueMatchType) {\n      rule.ruleForm.get('valueMatchType')?.setValue(rule.valueMatchType);\n    }\n\n    rule.ruleForm.get('valueMatchType')?.valueChanges.subscribe((value) => {\n      this.changeValueMatchType(value, rule);\n\n    });\n    rule.ruleForm.get('fieldValueGroup')?.get('inputTextForStringField')?.valueChanges.subscribe((value) => {\n\n    });\n\n    /*rule.ruleForm.get('fieldValueGroup')?.get('fieldValueNumber')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });\n    rule.ruleForm.get('fieldValueGroup')?.get('fieldValueDate')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });\n    rule.ruleForm.get('fieldValueGroup')?.get('fieldValueTime')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });*/\n    rule.ruleForm.get('fieldValueGroup')?.get('fieldValueCategorical')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });\n\n    /*rule.ruleForm.get('fieldValueGroup')?.get('fieldValueBoolean')?.valueChanges.subscribe((value) => {\n      rule.value = value;\n      this.changeInput();\n    });*/\n  }\n\n  removeRule(rule: Rule, parent?: RuleSet): void {\n    if (this.disabled) {\n      return;\n    }\n\n    parent = parent || this.data;\n\n    parent.rules = parent.rules.filter((r) => r !== rule);\n\n\n    this.handleTouched();\n    this.handleDataChange();\n  }\n\n  addRuleSet(parent?: RuleSet): void {\n    if (this.disabled) {\n      return;\n    }\n\n    parent = parent || this.data;\n    //set lastItem to last item of rules or undefined if RuleSet.rules is undefined\n    let lastItem = parent.rules=== undefined? undefined : parent.rules[parent.rules.length - 1];\n\n    // let lastItem = parent.rules[parent.rules.length - 1];\n    if ( lastItem && (RuleUtils.isRuleSetObject(lastItem)) && this.currentRuleSetIsInvalid(lastItem as RuleSet)) {\n      this.errorDialogService.openErrorDialog(\"Error\", \"Please fill out the current rule before adding a new one!\");\n      return;\n    } else if ( lastItem &&!(RuleUtils.isRuleSetObject(lastItem)) && this.currentRuleIsInvalid(lastItem as Rule)) {\n      this.errorDialogService.openErrorDialog(\"Error\", \"Please fill out the current rule before adding a new one!\");\n      return;\n    }\n\n\n    let ruleSet: RuleSet = new RuleSet('and', []);\n    parent.rules = parent.rules.concat([ruleSet]);\n\n\n    this.handleTouched();\n    this.handleDataChange();\n  }\n\n  removeRuleSet(ruleset?: RuleSet, parent?: RuleSet): void {\n    if (this.disabled) {\n      return;\n    }\n\n    ruleset = ruleset || this.data;\n    parent = parent || this.parentValue;\n    if (parent) {\n      parent.rules = parent.rules.filter((r) => r !== ruleset);\n    }\n\n    this.handleTouched();\n    this.handleDataChange();\n  }\n\n  transitionEnd(e: Event): void {\n    this.treeContainer.nativeElement.style.maxHeight = null;\n  }\n\n  toggleCollapse(): void {\n    this.computedTreeContainerHeight();\n    setTimeout(() => {\n      this.data.collapsed = !this.data.collapsed;\n    }, 100);\n  }\n\n  computedTreeContainerHeight(): void {\n    const nativeElement: HTMLElement = this.treeContainer.nativeElement;\n    if (nativeElement && nativeElement.firstElementChild) {\n      nativeElement.style.maxHeight = (nativeElement.firstElementChild.clientHeight + 8) + 'px';\n    }\n  }\n\n  changeCondition(value: string): void {\n    if (this.disabled) {\n      return;\n    }\n    //check that value satisfies ConditionEnum\n    if (value.toLowerCase() !== 'and' && value.toLowerCase() !== 'or') {\n      throw new Error('Invalid condition value');\n    }\n    this.data.condition = value.toUpperCase() as  ConditionEnum;\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges();\n  }\n\n  changeOperator(value: Operator, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n    rule.operator = value;\n\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n\n  changeFieldMatchType(fieldMatchType: RuleMatchType, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n\n    rule.fieldMatchType = fieldMatchType;\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n  changeValueMatchType(valueMatchType: RuleMatchType, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n\n    rule.valueMatchType = valueMatchType;\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n\n  changeInput(): void {\n    if (this.disabled) {\n      return;\n    }\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n  changeField(field: Field, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n    if (!field || !rule) {\n      return;\n    }\n\n\n    // delete rule.value;\n    rule.field = [field.name];\n    if (field.operators?.[0] !== undefined){\n\n      rule.operator = field.operators?.[0].asOperator() as RuleOperator;\n    }\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n  changeFieldArray(field: Field[], rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n\n\n    rule.value = [];\n    if (!rule.field) {\n      rule.field = [];\n    } else {\n      if (!RuleUtils.fieldIsArray(rule)) {\n        throw new Error('Expected field to be an array!');\n      }\n    }\n    //check if field is already in rule array\n    let fieldArray: Field[] = rule.field as any;\n    for (const fieldItem of field) {\n      if (fieldArray.indexOf(fieldItem) === -1) {\n        fieldArray.push(fieldItem);\n      }\n    }\n    rule.field = fieldArray.map((f) => f.name);\n\n    let operator = field[0]?.operators?.[0];\n    if (operator){\n\n      rule.operator = operator;\n    } else {\n        rule.operator = StringOperators.CONTAINS;\n    }\n\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n  changeFieldType(fieldType: FieldType, rule: Rule): void {\n    if (this.disabled) {\n      return;\n    }\n    if(fieldType === null){\n      return;\n    }\n\n\n    rule.fieldType = fieldType as FieldTypeEnum;\n    rule.field = [];\n    rule.fieldMatchType = MatchTypes.ANY_OF;\n    // delete rule.value;\n    rule.valueMatchType = MatchTypes.ANY_OF;\n    rule.operator = StringOperators.CONTAINS;\n\n\n    this.handleTouched();\n    this.handleDataChange();\n    this.changeDetectorRef.detectChanges(); // Add this line\n  }\n\n\n  getQueryItemClassName(local: LocalRuleMeta): string {\n    let cls = this.getClassNames('row', 'connector', 'transition');\n    cls += ' ' + this.getClassNames(local.ruleset ? 'ruleSet' : 'rule');\n    if (local.invalid) {\n      cls += ' ' + this.getClassNames('invalidRuleSet');\n    }\n    return cls as string;\n  }\n\n  private checkEmptyRuleInRuleset(ruleset: RuleSet): boolean {\n    if (!ruleset || !ruleset.rules || ruleset.rules.length === 0) {\n      return true;\n    } else {\n      return ruleset.rules.some((item: RuleSet | any) => {\n        if (item.rules) {\n          return this.checkEmptyRuleInRuleset(item);\n        } else {\n          return false;\n        }\n      });\n    }\n  }\n\n  private handleDataChange(): void {\n    this.changeDetectorRef.markForCheck();\n    if (this.onChangeCallback) {\n      this.onChangeCallback();\n    }\n    if (this.parentChangeCallback) {\n      this.parentChangeCallback();\n    }\n  }\n\n  private handleTouched(): void {\n    if (this.onTouchedCallback) {\n      this.onTouchedCallback();\n    }\n    if (this.parentTouchedCallback) {\n      this.parentTouchedCallback();\n    }\n  }\n\n  getFieldTypes(): string[] {\n    return this.typeToFieldMapWrapper.getFieldTypes();\n\n\n  }\n\n\n\n\n  showEmptyFieldNameError(rule: Rule): boolean {\n    let fieldGroup = rule.ruleForm?.get(\"fieldGroup\");\n    if (RuleUtils.allowMultipleFields(rule)) {\n      let errors = fieldGroup?.get('fieldMultiple')?.errors;\n      if (errors && errors['required']) {\n        return true;\n      }\n    } else {\n      let errors = fieldGroup?.get('fieldSingle')?.errors;\n      if (errors && errors['required']) {\n        return true;\n      }\n    }\n    return false;\n\n\n  }\n\n  showFieldMatchTypeError(rule: Rule) {\n    let fieldMatchType = rule.ruleForm?.get(\"fieldMatchType\");\n    if (fieldMatchType && fieldMatchType.errors) {\n      if (fieldMatchType.errors['required']) {\n        return true;\n      }\n\n    }\n\n    return false;\n  }\n\n  showOperatorError(rule: Rule) {\n    let operator = rule.ruleForm?.get(\"operator\");\n    if (operator && operator.errors) {\n      if (operator.errors['required']) {\n        return true;\n      }\n\n    }\n\n    return false;\n  }\n\n  showValueMatchTypeError(rule: Rule) {\n    let valueMatchType = rule.ruleForm?.get(\"valueMatchType\");\n    if (valueMatchType && valueMatchType.errors) {\n      if (valueMatchType.errors['required']) {\n        return true;\n      }\n\n    }\n\n    return false;\n  }\n\n  fieldValueIsEmpty(rule: Rule) {\n    if (!rule.value) {\n      return true;\n    }\n    if (Array.isArray(rule.value) && rule.value.length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n\n  requireExpansionPanelOpen(rule: Rule) {\n    let value = rule.value;\n    if (!value){\n\n      return false;\n\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false;\n    }\n    return true;\n\n\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ":host {\r\n  display: block;\r\n  width: 100%;\r\n  overflow-x: auto;\r\n  white-space: nowrap;\r\n\r\n  ::ng-deep .mat-mdc-list-base .mat-mdc-list-item, .mat-list-base .mat-list-option  {\r\n    padding: 0 !important;  // Adjust as needed\r\n    margin: 0 !important;  // Adjust as needed\r\n    height: 20px !important;  // Adjust as needed\r\n  }\r\n\r\n  .q-icon {\r\n    font-style: normal;\r\n    font-size: 12px;\r\n  }\r\n\r\n  .q-remove-icon {\r\n    &::before {\r\n      content: '❌'\r\n    }\r\n  }\r\n\r\n  .q-arrow-icon-button {\r\n    float: left;\r\n    margin: 4px 6px 4px 0;\r\n    transform: rotate(90deg);\r\n    transition: linear 0.25s transform;\r\n    cursor: pointer;\r\n\r\n    &.q-collapsed {\r\n      transform: rotate(0);\r\n    }\r\n  }\r\n\r\n  .q-arrow-icon {\r\n    &::before {\r\n      content: '▶'\r\n    }\r\n  }\r\n\r\n  .q-add-icon {\r\n    color: #555;\r\n\r\n    &::before {\r\n      content: '➕'\r\n    }\r\n  }\r\n\r\n  .q-remove-button {\r\n    color: #B3415D;\r\n    width: 31px;\r\n  }\r\n\r\n  .q-switch-group, .q-button-group {\r\n    font-family: \"Lucida Grande\", Tahoma, Verdana, sans-serif;\r\n    //overflow: hidden;\r\n  }\r\n\r\n  .q-right-align {\r\n    float: right;\r\n  }\r\n\r\n  .q-button {\r\n    margin-left: 8px;\r\n    padding: 0 8px;\r\n    background-color: white;\r\n\r\n    &:disabled {\r\n      display: none;\r\n    }\r\n  }\r\n\r\n  .q-control-size {\r\n    display: inline-block;\r\n    vertical-align: top;\r\n    padding-right: 2px;\r\n\r\n  }\r\n\r\n  .q-input-control, .q-operator-control, .q-field-control, .q-entity-control {\r\n    display: inline-block;\r\n    padding: 2px 6px;\r\n    color: #555;\r\n    background-color: #fff;\r\n    background-image: none;\r\n    border: 1px solid #ccc;\r\n    border-radius: 2px;\r\n    box-sizing: border-box;\r\n    min-width: 50px;\r\n    max-width: 120px;\r\n\r\n\r\n\r\n    &:disabled {\r\n      border-color: transparent;\r\n    }\r\n  }\r\n\r\n  .q-operator-control, .q-field-control, .q-entity-control, .q-input-control:not([type='checkbox']) {\r\n    min-height: 32px;\r\n    -webkit-appearance: none;\r\n  }\r\n\r\n  .q-switch-label, .q-button {\r\n    float: left;\r\n    margin-bottom: 0;\r\n    font-size: 14px;\r\n    line-height: 30px;\r\n    font-weight: normal;\r\n    text-align: center;\r\n    text-shadow: none;\r\n    border: 1px solid rgba(0, 0, 0, 0.2);\r\n    box-sizing: border-box;\r\n\r\n    &:hover {\r\n      cursor: pointer;\r\n      background-color: #F0F0F0;\r\n    }\r\n  }\r\n\r\n  .q-switch-label {\r\n    background-color: #e4e4e4;\r\n    padding: 0 8px;\r\n  }\r\n\r\n  .q-switch-radio {\r\n    position: absolute;\r\n    clip: rect(0, 0, 0, 0);\r\n    height: 1px;\r\n    width: 1px;\r\n    border: 0;\r\n    overflow: hidden;\r\n\r\n    &:checked + .q-switch-label {\r\n      border: 1px solid rgb(97, 158, 215);\r\n      background: white;\r\n      color: rgb(49, 118, 179);\r\n    }\r\n\r\n    &:disabled + .q-switch-label {\r\n      display: none;\r\n    }\r\n\r\n    &:checked:disabled + .q-switch-label {\r\n      display: initial;\r\n      color: initial;\r\n      cursor: default;\r\n      border-color: transparent;\r\n    }\r\n  }\r\n\r\n  .q-invalid-ruleset {\r\n    border: 1px solid rgba(179, 65, 93, 0.5) !important;\r\n    background: rgba(179, 65, 93, 0.1) !important;\r\n  }\r\n\r\n  .q-empty-warning {\r\n    color: rgb(141, 37, 46);\r\n    text-align: center;\r\n  }\r\n\r\n  .q-ruleset {\r\n    border: 1px solid #CCC;\r\n  }\r\n\r\n  .q-rule {\r\n    border: 1px solid #CCC;\r\n    background: white;\r\n  }\r\n\r\n  .q-transition {\r\n    -webkit-transition: all 0.1s ease-in-out;\r\n    -moz-transition: all 0.1s ease-in-out;\r\n    -ms-transition: all 0.1s ease-in-out;\r\n    -o-transition: all 0.1s ease-in-out;\r\n    transition: all 0.1s ease-in-out;\r\n  }\r\n\r\n  .q-tree-container {\r\n    width: 100%;\r\n    overflow: hidden;\r\n    transition: ease-in 0.25s max-height;\r\n\r\n    &.q-collapsed {\r\n      max-height: 0 !important;\r\n    }\r\n  }\r\n\r\n  .q-tree {\r\n    list-style: none;\r\n    margin: 4px 0 2px;\r\n  }\r\n\r\n  .q-row {\r\n    padding: 6px 8px;\r\n    margin-top: 6px;\r\n  }\r\n\r\n  .q-connector {\r\n    position: relative;\r\n\r\n    &::before {\r\n      top: -5px;\r\n      border-width: 0 0 2px 2px;\r\n    }\r\n\r\n    &::after {\r\n      border-width: 0 0 0 2px;\r\n      top: 50%;\r\n    }\r\n\r\n    &::before, &::after {\r\n      content: '';\r\n      left: -12px;\r\n      border-color: #CCC;\r\n      border-style: solid;\r\n      width: 9px;\r\n      height: calc(50% + 6px);\r\n      position: absolute;\r\n    }\r\n\r\n    &:last-child::after {\r\n      content: none;\r\n    }\r\n  }\r\n\r\n  .q-inline-block-display {\r\n    display: inline-block;\r\n    vertical-align: top;\r\n  }\r\n\r\n  .q-field-title {\r\n    font-size: smaller;\r\n    text-decoration: underline;\r\n    text-align: center\r\n  }\r\n  .grid-container {\r\n    display: grid;\r\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\r\n    grid-gap: 10px;\r\n  }\r\n\r\n  .grid-item {\r\n    border: 1px solid #ccc;\r\n    padding: 10px;\r\n    text-align: center;\r\n  }\r\n}\r\n\r\n.list-input-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  border-style: solid;\r\n  border-width: 1px;\r\n  border-color: #ccc;\r\n  padding-bottom: 2px ;\r\n\r\n  mat-form-field {\r\n    width: 100%;\r\n    margin-bottom: 3px;\r\n    border-style: solid;\r\n    border-width: 1px;\r\n    border-color: #ccc;\r\n  }\n  /* TODO(mdc-migration): The following rule targets internal classes of list that may no longer apply for the MDC version.*/\n  mat-list-item {\r\n    display: flex;\r\n    align-items: center;\r\n  }\r\n\r\n  button {\r\n    margin-left: 10px;\r\n  }\r\n}\r\n\r\n.list-input-container-empty {\r\n  display: flex;\r\n  flex-direction: column;\r\n\r\n  mat-form-field {\r\n    width: 100%;\r\n    margin-bottom: 4px;\r\n    border-style: solid;\r\n    border-width: 1px;\r\n    border-color: #ccc;\r\n  }\n  /* TODO(mdc-migration): The following rule targets internal classes of list that may no longer apply for the MDC version.*/\n  mat-list-item {\r\n    display: flex;\r\n    align-items: center;\r\n  }\r\n\r\n  button {\r\n    margin-left: 10px;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n",
                    "styleUrl": "./query-builder.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "changeDetectorRef",
                        "type": "ChangeDetectorRef",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 154,
                "jsdoctags": [
                    {
                        "name": "changeDetectorRef",
                        "type": "ChangeDetectorRef",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnChanges",
                "ControlValueAccessor",
                "Validator"
            ],
            "accessors": {
                "condition": {
                    "name": "condition",
                    "getSignature": {
                        "name": "condition",
                        "type": "",
                        "returnType": "",
                        "line": 133
                    }
                },
                "value": {
                    "name": "value",
                    "setSignature": {
                        "name": "value",
                        "type": "void",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "args": [
                            {
                                "name": "value",
                                "type": "RuleSet",
                                "deprecated": false,
                                "deprecationMessage": ""
                            }
                        ],
                        "returnType": "void",
                        "line": 304,
                        "jsdoctags": [
                            {
                                "name": "value",
                                "type": "RuleSet",
                                "deprecated": false,
                                "deprecationMessage": "",
                                "tagName": {
                                    "text": "param"
                                }
                            }
                        ]
                    },
                    "getSignature": {
                        "name": "value",
                        "type": "",
                        "returnType": "RuleSet",
                        "line": 300
                    }
                }
            },
            "templateData": "<div [ngClass]=\"getClassNames('switchRow')\">\n\n\n  <a *ngIf=\"allowCollapse\" (click)=\"toggleCollapse()\"\n     [ngClass]=\"getClassNames('arrowIconButton', data.collapsed ? 'collapsed' : '')\">\n    <i [ngClass]=\"getClassNames('arrowIcon')\"></i>\n  </a>\n\n\n  <!--  button group-->\n\n  <div [ngClass]=\"getClassNames('buttonGroup', 'rightAlign')\">\n    <button type=\"button\" (click)=\"addRule()\" [ngClass]=\"getClassNames('button')\" [disabled]=disabled>\n      <i [ngClass]=\"getClassNames('addIcon')\"></i> Rule\n    </button>\n    <button type=\"button\" (click)=\"addRuleSet()\" [ngClass]=\"getClassNames('button')\" *ngIf=\"allowRuleset\"\n            [disabled]=disabled>\n      <i [ngClass]=\"getClassNames('addIcon')\"></i> Ruleset\n    </button>\n    <ng-container *ngIf=\"!!parentValue && allowRuleset\">\n      <button type=\"button\" (click)=\"removeRuleSet()\" [ngClass]=\"getClassNames('button', 'removeButton')\"\n              [disabled]=disabled>\n        <i [ngClass]=\"getClassNames('removeIcon')\"></i>\n      </button>\n    </ng-container>\n  </div>\n\n\n  <!--  switch group-->\n  <div [ngClass]=\"getClassNames('switchGroup', 'transition')\" *ngIf=\"data\">\n    <div [ngClass]=\"getClassNames('switchControl')\">\n      <input type=\"radio\" [ngClass]=\"getClassNames('switchRadio')\" [(ngModel)]=\"data.condition\" [disabled]=disabled\n             value=\"AND\" #andOption/>\n      <label (click)=\"changeCondition(andOption.value)\" [ngClass]=\"getClassNames('switchLabel')\">AND</label>\n    </div>\n    <div [ngClass]=\"getClassNames('switchControl')\">\n      <input type=\"radio\" [ngClass]=\"getClassNames('switchRadio')\" [(ngModel)]=\"data.condition\" [disabled]=disabled\n             value=\"OR\" #orOption/>\n      <label (click)=\"changeCondition(orOption.value)\" [ngClass]=\"getClassNames('switchLabel')\">OR</label>\n    </div>\n  </div>\n\n</div>\n\n<div #treeContainer (transitionend)=\"transitionEnd($event)\" style=\"overflow-x: auto\"\n     [ngClass]=\"getClassNames('treeContainer', data.collapsed ? 'collapsed' : '')\">\n  <ul [ngClass]=\"getClassNames('tree')\" *ngIf=\"data && data.rules\">\n    <ng-container *ngFor=\"let rule of data.rules;let i=index\">\n\n      <ng-container\n              *ngIf=\"{ruleset: !!rule.rules, invalid: !config.allowEmptyRulesets && rule.rules && rule.rules.length === 0 ? true : false} as local\">\n\n      <li [ngClass]=\"getQueryItemClassName(local)\">\n          <ng-container *ngIf=\"!local.ruleset\">\n\n            <!--removeButton-->\n            <div [ngClass]=\"getClassNames('removeButtonSize', 'rightAlign')\">\n              <button mat-button type=\"button\" [ngClass]=\"getClassNames('button', 'removeButton')\"\n                      (click)=\"removeRule(rule, data)\" [disabled]=disabled>\n                <i [ngClass]=\"getClassNames('removeIcon')\"></i>\n              </button>\n            </div>\n\n\n            <form [formGroup]=\"rule.ruleForm\" onSubmit={this.submitHandler}>\n              <!--fieldType-->\n              <div [ngClass]=\"getClassNames('fieldControlSize')\">\n\n                <div class=\"q-field-title\">field type</div>\n                <mat-form-field [ngClass]=\"getClassNames('fieldControl')\">\n                  <mat-select formControlName=\"fieldType\"\n                              [disabled]=\"disabled\" [multiple]=\"false\" [compareWith]=\"compareMatSelectItems\">\n                    <mat-option *ngFor=\"let fieldType of getFieldTypes()\" [value]=\"fieldType\">\n                      {{ fieldType }}\n                    </mat-option>\n                  </mat-select>\n                </mat-form-field>\n              </div>\n\n              <!-- fieldMatchType-->\n              <div [ngClass]=\"getClassNames('fieldControlSize')\" [ngSwitch]=\"rule.fieldType\">\n                <div *ngSwitchCase=\"'string'\">\n                  <div class=\"q-field-title\">match type</div>\n                  <mat-form-field [ngClass]=\"getClassNames('fieldControl')\">\n                    <mat-select formControlName=\"fieldMatchType\"\n                                [disabled]=\"disabled\" [multiple]=\"false\" [compareWith]=\"compareMatSelectItems\">\n                      <mat-option *ngFor=\"let fieldMatchType of MATCH_TYPES\" [value]=\"fieldMatchType\">\n                        {{ fieldMatchType.value }}\n                      </mat-option>\n                    </mat-select>\n\n                  </mat-form-field>\n                  <mat-error *ngIf=\"showFieldMatchTypeError(rule)\" style=\"font-size: xx-small\">\n                    'match type' must not be empty!\n                  </mat-error>\n                </div>\n              </div>\n\n              <!-- fields -->\n              <!-- multiple selection mat-select -->\n\n              <div formGroupName=\"fieldGroup\" [ngClass]=\"getClassNames('fieldControlSize')\">\n                <div *ngIf=\"RuleUtils.allowMultipleFields(rule)\" [ngClass]=\"getClassNames('fieldControlSize')\">\n                  <div class=\"q-field-title\">field name</div>\n                  <mat-form-field [ngClass]=\"getClassNames('fieldControl')\" style=\"min-width: 200px\">\n                    <mat-select formControlName=\"fieldMultiple\"\n                                [disabled]=\"disabled\" [multiple]=\"true\" [compareWith]=\"compareMatSelectItems\">\n                      <mat-option *ngFor=\"let field of getFieldsForSelectedType(rule)\" [value]=\"field\">\n                        {{ field.value }}\n                      </mat-option>\n                    </mat-select>\n                  </mat-form-field>\n                  <mat-error *ngIf=\"showEmptyFieldNameError(rule)\" style=\"font-size: xx-small\">\n                    'field name' must not be empty!\n                  </mat-error>\n                </div>\n\n                <!-- single selection mat-select -->\n                <div *ngIf=\"!RuleUtils.allowMultipleFields(rule)\" [ngClass]=\"getClassNames('fieldControlSize')\"\n                     style=\"min-width: 150px\">\n                  <div class=\"q-field-title\">field name</div>\n                  <mat-form-field [ngClass]=\"getClassNames('fieldControl')\" style=\"min-width: 200px\">\n                    <mat-select formControlName=\"fieldSingle\"\n                                [disabled]=\"disabled\" [multiple]=\"false\" [compareWith]=\"compareMatSelectItems\">\n                      <mat-option *ngFor=\"let field of getFieldsForSelectedType(rule)\" [value]=\"field\">\n                        {{ field.value }}\n                      </mat-option>\n                    </mat-select>\n                  </mat-form-field>\n                  <mat-error *ngIf=\"showEmptyFieldNameError(rule)\" style=\"font-size: xx-small\">\n                    'field name' must not be empty!\n                  </mat-error>\n                </div>\n\n              </div>\n\n\n              <!-- operators -->\n              <div [ngClass]=\"getClassNames('operatorControlSize')\">\n                <div>\n                  <div class=\"q-field-title\">operator</div>\n                  <mat-form-field [ngClass]=\"getClassNames('fieldControl')\">\n                    <mat-select formControlName=\"operator\"\n                                [disabled]=\"disabled\" [compareWith]=\"compareMatSelectItems\">\n                      <mat-option *ngFor=\"let operator of getOperatorsForSelectedType(rule)\" [value]=\"operator\">\n                        {{ operator.value }}\n                      </mat-option>\n                    </mat-select>\n                  </mat-form-field>\n                  <mat-error *ngIf=\"showOperatorError(rule)\" style=\"font-size: xx-small\">\n                    'operator' must not be empty!\n                  </mat-error>\n                </div>\n              </div>\n\n              <!-- valueMatchType-->\n              <div [ngClass]=\"getClassNames('fieldControlSize')\" *ngIf=\"!RuleUtils.hideValueMatchType(rule)\">\n                <div>\n                  <div class=\"q-field-title\">match type</div>\n                  <mat-form-field [ngClass]=\"getClassNames('fieldControl')\">\n                    <mat-select formControlName=\"valueMatchType\"\n                                [disabled]=\"disabled\" [multiple]=\"false\" [compareWith]=\"compareMatSelectItems\">\n                      <mat-option *ngFor=\"let valueMatchType of MATCH_TYPES\" [value]=\"valueMatchType\">\n                        {{ valueMatchType.name }}\n                      </mat-option>\n                    </mat-select>\n                  </mat-form-field>\n                  <mat-error *ngIf=\"showValueMatchTypeError(rule)\" style=\"font-size: xx-small\">\n                    'match type' must not be empty!\n                  </mat-error>\n                </div>\n              </div>\n\n\n              <!-- field value-->\n              <div [ngClass]=\"getClassNames('fieldControlSize')\" formGroupName=\"fieldValueGroup\">\n                <div class=\"q-field-title\">field value</div>\n                <div [ngClass]=\"getClassNames('inputControlSize')\" [ngSwitch]=\"rule.fieldType\">\n                  <!-- string field-->\n                  <div *ngSwitchCase=\"'string'\"\n                       [ngClass]=\"fieldValueIsEmpty(rule) ? 'list-input-container-empty' : 'list-input-container'\">\n                    <mat-expansion-panel [expanded]=\"requireExpansionPanelOpen(rule)\" #expansionPanel style=\"min-width: fit-content\" (opened)=\"panelOpenState = true\"\n                                         (closed)=\"panelOpenState = false\">\n                      <mat-expansion-panel-header   style=\"min-height: 60px; padding-bottom: 5px;\" >\n\n                        <div style=\" display: flex; flex-direction: column\">\n                          <mat-form-field>\n                            <input matInput formControlName=\"inputTextForStringField\"\n                                   (keydown.enter)=\"addStringValue(rule, expansionPanel); $event.preventDefault()\"\n                                   placeholder=\"string to match\" type=\"text\">\n                          </mat-form-field>\n                          <mat-error *ngIf=\"fieldValueIsEmpty(rule)\" style=\"font-size: xx-small\">\n                            'field value' must not be empty!\n                          </mat-error>\n                        </div>\n                      </mat-expansion-panel-header>\n\n                      <!--display the contents of rule.value in a mat-list-->\n                        <li *ngFor=\"let item of rule.value\" style=\"height: 20px !important\">\n                          <button mat-icon-button (click)=\"removeStringValueFromStringField(i, rule)\">\n                            <mat-icon style=\"font-size: 12px\">cancel</mat-icon>\n                          </button>\n                          <span>{{ item }}</span>\n                        </li>\n                    </mat-expansion-panel>\n\n                  </div>\n\n                  <!-- number field-->\n                  <div *ngSwitchCase=\"'number'\" [ngClass]=\"getClassNames('fieldControl')\">\n                    <mat-form-field>\n                      <input matInput\n                             formControlName=\"fieldValueNumber\"\n                             [disabled]=\"disabled\" type=\"number\">\n                    </mat-form-field>\n                  </div>\n\n                  <!-- date field-->\n                  <div *ngSwitchCase=\"'date'\" [ngClass]=\"getClassNames('fieldControl')\">\n                    <mat-form-field>\n                      <input formControlName=\"fieldValueDate\" matInput [disabled]=\"disabled\" type=\"date\">\n                    </mat-form-field>\n                    <mat-error *ngIf=\"fieldValueIsEmpty(rule)\" style=\"font-size: xx-small\">\n                      'field value' must not be empty!\n                    </mat-error>\n                  </div>\n\n                  <!-- time field-->\n                  <div *ngSwitchCase=\"'time'\" [ngClass]=\"getClassNames('fieldControl')\">\n                    <mat-form-field>\n                      <input formControlName=\"fieldValueTime\" matInput [disabled]=\"disabled\" type=\"time\">\n                    </mat-form-field>\n                    <mat-error *ngIf=\"fieldValueIsEmpty(rule)\" style=\"font-size: xx-small\">\n                      'field value' must not be empty!\n                    </mat-error>\n                  </div>\n\n                  <!-- category field-->\n                  <div *ngSwitchCase=\"'categorical'\">\n                    <mat-form-field [ngClass]=\"getClassNames('fieldControl')\">\n                      <mat-select formControlName=\"fieldValueCategorical\"\n                                  [disabled]=\"disabled\" [multiple]=\"true\" [compareWith]=\"compareMatSelectItems\">\n                        <mat-option *ngFor=\"let opt of getOptionsForField(rule)\" [value]=\"opt.value\">\n                          {{ opt.name }}\n                        </mat-option>\n                      </mat-select>\n                    </mat-form-field>\n                    <mat-error *ngIf=\"fieldValueIsEmpty(rule)\" style=\"font-size: xx-small\">\n                      'field value' must not be empty!\n                    </mat-error>\n                  </div>\n\n                  <!-- boolean field-->\n                  <div *ngSwitchCase=\"'boolean'\" [ngClass]=\"getClassNames('fieldControl')\">\n                    <mat-checkbox>\n                      <input formControlName=\"fieldValueBoolean\"\n                             [disabled]=\"disabled\">\n                    </mat-checkbox>\n                    <mat-error *ngIf=\"fieldValueIsEmpty(rule)\" style=\"font-size: xx-small\">\n                      'field value' must not be empty!\n                    </mat-error>\n                  </div>\n\n\n                </div>\n              </div>\n            </form>\n\n\n          </ng-container>\n\n          <query-builder *ngIf=\"local.ruleset\" [data]=\"rule\" [disabled]=\"disabled\"\n                         [parentTouchedCallback]=\"parentTouchedCallback || onTouchedCallback\"\n                         [parentChangeCallback]=\"parentChangeCallback || onChangeCallback\"\n                         [parentValue]=\"data\" [classNames]=\"classNames\" [config]=\"config\"\n                         [allowRuleset]=\"allowRuleset\"\n                         [allowCollapse]=\"allowCollapse\" [emptyMessage]=\"emptyMessage\" [operatorMap]=\"operatorMap\">\n          </query-builder>\n          <p [ngClass]=\"getClassNames('emptyWarning')\" *ngIf=\"local.invalid\">\n            {{ emptyMessage }}\n          </p>\n\n        </li>\n      </ng-container>\n    </ng-container>\n  </ul>\n</div>\n\n"
        },
        {
            "name": "RecurrenceComponent",
            "id": "component-RecurrenceComponent-268ebf578d291c7bd3a0233e3b093995fc1b05158194adb3d2a3deb2ec3067ad7e042ab2e6fa6d4009b5e28b7142a64d113ac64a64d8434f97a0d38cf5cc6741",
            "file": "src/app/recurrence/recurrence.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-recurrence",
            "styleUrls": [
                "./recurrence.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./recurrence.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "expensesRecurrenceChangeEmitter",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 20,
                    "type": "EventEmitter<boolean>"
                },
                {
                    "name": "revenueRecurrenceChangeEmitter",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 21,
                    "type": "EventEmitter<boolean>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "selectedExpensesRecurrence",
                    "defaultValue": "\"both\"",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 17
                },
                {
                    "name": "selectedRevenueRecurrence",
                    "defaultValue": "\"both\"",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 18
                },
                {
                    "name": "types",
                    "defaultValue": "[\"recurrent\", \"non-recurrent\", \"both\"]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 16
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 29,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onInkomstenChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 37,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onUitgavenChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 33,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatRadioGroup"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "MatRadioButton"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, EventEmitter, OnInit, Output } from '@angular/core';\nimport { AppService } from '../app.service';\nimport { MatRadioGroup, MatRadioButton } from '@angular/material/radio';\nimport { FormsModule } from '@angular/forms';\nimport { NgFor } from '@angular/common';\n\n@Component({\n    selector: 'app-recurrence',\n    templateUrl: './recurrence.component.html',\n    styleUrls: ['./recurrence.component.scss'],\n    standalone: true,\n    imports: [MatRadioGroup, FormsModule, NgFor, MatRadioButton]\n})\nexport class RecurrenceComponent implements OnInit {\n\n  types = [\"recurrent\", \"non-recurrent\", \"both\"];\n  selectedExpensesRecurrence:string = \"both\";\n  selectedRevenueRecurrence:string = \"both\";\n\n  @Output() expensesRecurrenceChangeEmitter: EventEmitter<boolean> = new EventEmitter<boolean>();\n  @Output() revenueRecurrenceChangeEmitter: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  constructor(private appService: AppService) {\n    this.selectedExpensesRecurrence = \"both\"\n    this.appService.setExpensesRecurrence(this.selectedExpensesRecurrence);\n    this.appService.setRevenueRecurrence(this.selectedRevenueRecurrence);\n  }\n\n  ngOnInit() {\n  }\n\n\n  onUitgavenChange(){\n    this.expensesRecurrenceChangeEmitter.emit();\n    this.appService.setExpensesRecurrence(this.selectedExpensesRecurrence);\n  }\n  onInkomstenChange(){\n    this.revenueRecurrenceChangeEmitter.emit();\n    this.appService.setRevenueRecurrence(this.selectedRevenueRecurrence);\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./recurrence.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 21,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"inline_block\" style=\"padding-top: 10px; padding-left: 10px;\">\n  <div>\n    <label style=\"padding-right: 19px;text-decoration: underline\">Uitgaven</label>\n    <mat-radio-group [(ngModel)]=\"selectedExpensesRecurrence\" (ngModelChange)=\"onUitgavenChange()\">\n      <mat-radio-button style=\"padding-right: 5px\" *ngFor=\"let type of types\" [value]=\"type\">\n        {{type}}\n      </mat-radio-button>\n    </mat-radio-group>\n  </div>\n  <div>\n    <label style=\"padding-right: 5px; padding-top: 5px; text-decoration: underline\">Inkomsten</label>\n    <mat-radio-group [(ngModel)]=\"selectedRevenueRecurrence\" (ngModelChange)=\"onInkomstenChange()\">\n      <mat-radio-button style=\"padding-right: 5px\" *ngFor=\"let type of types\" [value]=\"type\">\n        {{type}}\n      </mat-radio-button>\n    </mat-radio-group>\n  </div>\n\n</div>\n"
        },
        {
            "name": "RegisterComponent",
            "id": "component-RegisterComponent-404fae0a2f56002c71786f117e564751acd68e18878008a7cf8e66f21398902d0f59be2a79e3bd3010bceba5295333788c38434d233d75bcb1eaf213dcbfcadd",
            "file": "src/app/register/register.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-register",
            "styleUrls": [
                "./register.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./register.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "form",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "FormGroup",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 22
                },
                {
                    "name": "formSubmitAttempt",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean | undefined",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "hidePassword",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27
                }
            ],
            "methodsClass": [
                {
                    "name": "getFailureErrorMessage",
                    "args": [
                        {
                            "name": "response",
                            "type": "RegisterResponse",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 101,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "response",
                            "type": "RegisterResponse",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isFieldInvalid",
                    "args": [
                        {
                            "name": "field",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 63,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "field",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 51,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onSubmit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 81,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "togglePasswordVisibility",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 29,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "trimAndNotEmptyValidator",
                    "args": [],
                    "optional": false,
                    "returnType": "ValidatorFn",
                    "typeParameters": [],
                    "line": 37,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatCard"
                },
                {
                    "name": "MatCardContent"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "ReactiveFormsModule",
                    "type": "module"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatInput"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatError"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "MatSuffix"
                },
                {
                    "name": "MatIcon"
                },
                {
                    "name": "MatButton"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, OnInit} from '@angular/core';\nimport { AbstractControl, FormBuilder, FormGroup, ValidatorFn, Validators, FormsModule, ReactiveFormsModule } from \"@angular/forms\";\nimport {AuthService, RegisterFailureReason, RegisterResponse, Response} from \"../auth/auth.service\";\nimport {User} from \"../model\";\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport { MatCard, MatCardContent } from '@angular/material/card';\nimport { MatFormField, MatError, MatSuffix } from '@angular/material/form-field';\nimport { MatInput } from '@angular/material/input';\nimport { NgIf } from '@angular/common';\nimport { MatIconButton, MatButton } from '@angular/material/button';\nimport { MatIcon } from '@angular/material/icon';\n\n@Component({\n    selector: 'app-register',\n    templateUrl: './register.component.html',\n    styleUrls: ['./register.component.scss'],\n    standalone: true,\n    imports: [MatCard, MatCardContent, FormsModule, ReactiveFormsModule, MatFormField, MatInput, NgIf, MatError, MatIconButton, MatSuffix, MatIcon, MatButton]\n})\nexport class RegisterComponent implements OnInit {\n\n  form!: FormGroup;\n\n\n  private formSubmitAttempt: boolean | undefined;\n\n  hidePassword = true;\n\n  togglePasswordVisibility(): void {\n    this.hidePassword = !this.hidePassword;\n  }\n\n  constructor(private authService: AuthService, private fb: FormBuilder, private errorDialogService: ErrorDialogService) {\n\n  }\n\n  private trimAndNotEmptyValidator(): ValidatorFn {\n    return (control: AbstractControl): { [key: string]: any } | null => {\n      if (control.value) {\n        // Trim the input and check if it's empty after trimming.\n        const trimmedValue = control.value.trim();\n        if (trimmedValue === '') {\n          return {empty: true}; // Return a validation error if empty.\n        }\n      }\n      return null; // Return null if the input is valid.\n    };\n  }\n\n\n  ngOnInit(): void {\n\n    this.form = this.fb.group({\n\n      firstName: ['', [Validators.required, this.trimAndNotEmptyValidator()]],\n      lastName: ['', [Validators.required, this.trimAndNotEmptyValidator()]],\n      email: ['', [Validators.required, this.trimAndNotEmptyValidator()]],\n      password: ['', [Validators.required, this.trimAndNotEmptyValidator()]]\n    });\n  }\n\n\n  isFieldInvalid(field: string) {\n\n\n    let fieldObj = this.form.get(field);\n    if (fieldObj === undefined || fieldObj === null) {\n      return false;\n    }\n    let valid = fieldObj.valid;\n    // @ts-ignore\n    let touched = fieldObj.touched;\n    // @ts-ignore\n    let untouched = fieldObj.untouched;\n    return (\n      (!valid && touched) ||\n      (untouched && this.formSubmitAttempt)\n    );\n  }\n\n  onSubmit() {\n    if (!this.form) {\n      throw new Error();\n    }\n    if (this.form.valid) {\n\n      let user = this.form.value as User;\n\n      this.authService.register(user).subscribe(response => {\n        if (response.response == Response.FAILED) {\n\n          this.errorDialogService.openErrorDialog(\"Registration failed!\", this.getFailureErrorMessage(response))\n           }\n      });\n\n\n    }\n    this.formSubmitAttempt = true;\n  }\n\n  getFailureErrorMessage(response: RegisterResponse): string {\n    if (response.failureReason == RegisterFailureReason.EMPTY_FIELDS) {\n      return \"Some fields are empty! All fields need to be filled out!\"\n\n    } else if (response.failureReason == RegisterFailureReason.USER_ALREADY_EXISTS) {\n      return `User with email ${response.user.userName} already exists! Please choose another email!`\n    } else if (response.failureReason == RegisterFailureReason.SERVER_ERROR) {\n      return \"There is a server error!\"\n    }\n\n    throw new Error();\n\n  }\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "\n/* TODO(mdc-migration): The following rule targets internal classes of card that may no longer apply for the MDC version. */\nmat-card {\r\n  max-width: 400px;\r\n  margin: 2em auto;\r\n  text-align: center;\r\n}\r\n.signin-content {\r\n  padding: 60px 1rem;\r\n}\r\n.full-width-input {\r\n  width: 100%;\r\n}\r\n",
                    "styleUrl": "./register.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 31,
                "jsdoctags": [
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "fb",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<div class=\"signin-content\">\n  <mat-card appearance=\"outlined\">\n    <mat-card-content>\n      <form [formGroup]=\"form\" >\n        <p>Create an account</p>\n        <mat-form-field class=\"full-width-input\">\n          <input matInput placeholder=\"First name\" formControlName=\"firstName\" required>\n          <mat-error *ngIf=\"isFieldInvalid('firstName')\">\n            Enter first name.\n          </mat-error>\n        </mat-form-field>\n        <mat-form-field class=\"full-width-input\">\n          <input matInput placeholder=\"Last name\" formControlName=\"lastName\" required>\n          <mat-error *ngIf=\"isFieldInvalid('lastName')\">\n            Enter last name.\n          </mat-error>\n        </mat-form-field>\n        <mat-form-field class=\"full-width-input\">\n          <input matInput type=\"text\" placeholder=\"Email\" formControlName=\"email\" required>\n          <mat-error *ngIf=\"isFieldInvalid('email')\">\n            Enter email.\n          </mat-error>\n        </mat-form-field>\n        <mat-form-field class=\"full-width-input\">\n          <input style=\"width: 90%\" matInput [type]=\"hidePassword ? 'password' : 'text'\" placeholder=\"Password\" formControlName=\"password\" required>\n          <mat-error *ngIf=\"isFieldInvalid('password')\">\n            Enter password.\n          </mat-error>\n          <button\n            mat-icon-button\n            matSuffix\n            (click)=\"togglePasswordVisibility()\"\n            [attr.aria-label]=\"hidePassword ? 'Show password' : 'Hide password'\">\n            <mat-icon>{{ hidePassword ? 'visibility_off' : 'visibility' }}</mat-icon>\n          </button>\n        </mat-form-field>\n\n        <button mat-raised-button color=\"primary\" type=\"submit\" (click)=\"onSubmit()\">Register</button>\n\n      </form>\n    </mat-card-content>\n  </mat-card>\n</div>\n"
        },
        {
            "name": "RevenueExpensesPerPeriodAndCategoryComponent",
            "id": "component-RevenueExpensesPerPeriodAndCategoryComponent-365a31a7f2f0b59347011c192faa1aed6c66112dca240669c52d59e29534ef57323274e38ea69a4ef894ad7a4d4a5ac79ad4448f648f6552ada35ea798c62124",
            "file": "src/app/revenue-expenses-per-period-and-category/revenue-expenses-per-period-and-category.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "revenue-expenses-per-period-and-category",
            "styleUrls": [
                "./revenue-expenses-per-period-and-category.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./revenue-expenses-per-period-and-category.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "criteria",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 46,
                    "type": "Criteria",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "anomaliesToolTip",
                    "defaultValue": "\"Anomalies are transactions that are significantly different from the average amount\" +\n      \" for that category and period. Anomalies are calculated using the Z-score. A Z-score is the number of\" +\n      \" standard deviations a data point is from the mean. Anomalies are marked in red\"",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 57
                },
                {
                    "name": "categoryMap",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryMap",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63
                },
                {
                    "name": "chartOptions",
                    "defaultValue": "this.initChartOptions()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 42
                },
                {
                    "name": "currentTransactionInContextQuery",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionInContextQuery",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 62
                },
                {
                    "name": "datatIsLoaded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 41
                },
                {
                    "name": "dialog",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatDialog",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 65,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "displayedColumns",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54
                },
                {
                    "name": "displayedColumnsExceptFirst",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "dummyIsLoaded",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "expensesData",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 43
                },
                {
                    "name": "expensesDataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTableDataSource<DistributionByCategoryForPeriodTableData>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 50
                },
                {
                    "name": "expensesDataSourceAll",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTableDataSource<DistributionByCategoryForPeriodTableData>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 51
                },
                {
                    "name": "firstColumn",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56
                },
                {
                    "name": "plugins",
                    "defaultValue": "[ChartDataLabels, autocolors]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 45
                },
                {
                    "name": "revenueData",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 44
                },
                {
                    "name": "revenueDataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTableDataSource<DistributionByCategoryForPeriodTableData>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 52
                },
                {
                    "name": "revenueDataSourceAll",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTableDataSource<DistributionByCategoryForPeriodTableData>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53
                },
                {
                    "name": "table",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTable<DistributionByCategoryForPeriodTableData>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 49,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatTable"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "TransactionType",
                    "defaultValue": "TransactionTypeEnum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 197,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "TransactionTypeEnum",
                    "defaultValue": "TransactionTypeEnum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 249,
                    "modifierKind": [
                        124,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "doQuery",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 114,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleDataSelect",
                    "args": [
                        {
                            "name": "$event",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 210,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "$event",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "initChartOptions",
                    "args": [],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 76,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 203,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 200,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onShowTransactions",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 236,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "openContextMenu",
                    "args": [
                        {
                            "name": "period",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "category",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "event",
                            "type": "MouseEvent",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 221,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "period",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "category",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "event",
                            "type": "MouseEvent",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "transformChartDataToPrimeNgFormat",
                    "args": [
                        {
                            "name": "chartData",
                            "type": "DistributionByCategoryForPeriodChartData[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "any",
                    "typeParameters": [],
                    "line": 150,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "chartData",
                            "type": "DistributionByCategoryForPeriodChartData[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "NgIf"
                },
                {
                    "name": "CdkMenu"
                },
                {
                    "name": "CdkMenuItem"
                },
                {
                    "name": "ChartModule",
                    "type": "module"
                },
                {
                    "name": "MatTooltip"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "NgFor"
                },
                {
                    "name": "NgClass"
                },
                {
                    "name": "CdkContextMenuTrigger"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, Input, OnChanges, OnInit, SimpleChanges, ViewChild} from '@angular/core';\nimport ChartDataLabels from 'chartjs-plugin-datalabels';\n\nimport {AppService} from '../app.service';\nimport {CategoryMap} from '../model';\nimport {Criteria} from \"../model/criteria.model\";\n// @ts-ignore\nimport autocolors from 'chartjs-plugin-autocolors';\nimport { MatTable, MatTableDataSource, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from \"@angular/material/table\";\nimport {MatDialog} from \"@angular/material/dialog\";\nimport {TransactionsInContextDialogComponent} from \"../transaction-dialog/transactions-in-context-dialog.component\";\nimport {\n  ApiBudgetAssistantBackendClientService,\n  DistributionByCategoryForPeriodChartData,\n  DistributionByCategoryForPeriodTableData,\n  ExpensesRecurrenceEnum,\n  Period,\n  RevenueAndExpensesPerPeriodAndCategory,\n  RevenueExpensesQuery,\n  RevenueRecurrenceEnum,\n  TransactionInContextQuery,\n  TransactionTypeEnum\n} from \"@daanvdn/budget-assistant-client\";\nimport { NgIf, NgFor, NgClass } from '@angular/common';\nimport { CdkMenu, CdkMenuItem, CdkContextMenuTrigger } from '@angular/cdk/menu';\nimport { ChartModule } from 'primeng/chart';\nimport { MatTooltip } from '@angular/material/tooltip';\n\n@Component({\n    selector: 'revenue-expenses-per-period-and-category',\n    templateUrl: './revenue-expenses-per-period-and-category.component.html',\n    styleUrls: ['./revenue-expenses-per-period-and-category.component.scss'],\n    standalone: true,\n    imports: [NgIf, CdkMenu, CdkMenuItem, ChartModule, MatTooltip, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, NgFor, NgClass, CdkContextMenuTrigger, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow]\n})\nexport class RevenueExpensesPerPeriodAndCategoryComponent implements OnInit, OnChanges {\n\n\n  dummyIsLoaded = false\n  //chart stuff\n  datatIsLoaded: Boolean = false;\n  chartOptions: any = this.initChartOptions();\n  expensesData!: any;\n  revenueData!: any;\n  plugins: any[] = [ChartDataLabels, autocolors];\n  @Input() criteria!: Criteria\n\n  //table stuff\n  @ViewChild(MatTable) table!: MatTable<DistributionByCategoryForPeriodTableData>;\n  expensesDataSource!: MatTableDataSource<DistributionByCategoryForPeriodTableData>;\n  expensesDataSourceAll!: MatTableDataSource<DistributionByCategoryForPeriodTableData>;\n  revenueDataSource!: MatTableDataSource<DistributionByCategoryForPeriodTableData>;\n  revenueDataSourceAll!: MatTableDataSource<DistributionByCategoryForPeriodTableData>;\n  displayedColumns!: string[];\n  displayedColumnsExceptFirst!: string[];\n  firstColumn!: string;\n  anomaliesToolTip: string = \"Anomalies are transactions that are significantly different from the average amount\" +\n      \" for that category and period. Anomalies are calculated using the Z-score. A Z-score is the number of\" +\n      \" standard deviations a data point is from the mean. Anomalies are marked in red\"\n\n\n  currentTransactionInContextQuery!: TransactionInContextQuery;\n  categoryMap!: CategoryMap;\n\n  constructor(private appService: AppService, public dialog: MatDialog, private apiBudgetAssistantBackendClientService: ApiBudgetAssistantBackendClientService) {\n    this.appService.categoryMapObservable$.subscribe((categoryMap) => {\n      if (categoryMap) {\n        this.categoryMap = categoryMap;\n      }\n    });\n\n\n\n  }\n\n  initChartOptions(): any {\n    return {\n      plugins: {\n        datalabels: {\n          display: false,\n          align: 'end',\n          anchor: 'end',\n          formatter: Math.round\n        },\n        autocolors: {\n          enabled: true,\n          mode: 'dataset', // or 'data' or 'label'\n          // other options...\n        }\n      },\n      indexAxis: 'y',\n      tooltips: {\n        mode: 'index',\n        intersect: false\n      },\n      responsive: true,\n      scales: {\n        x: {\n          stacked: true\n\n        },\n        y: {\n          stacked: true\n\n\n        }\n      }\n    };\n\n  }\n\n\n\n  doQuery() {\n    if (!this.criteria) {\n      throw new Error(\"Query parameters are not initialized!\");\n    }\n    this.datatIsLoaded = false;\n    let query: RevenueExpensesQuery = {\n      accountNumber: this.criteria.bankAccount.accountNumber,\n      grouping: this.criteria.grouping,\n      transactionType: TransactionTypeEnum.BOTH,\n      start: JSON.stringify(this.criteria.startDate),\n      end: JSON.stringify(this.criteria.endDate),\n      expensesRecurrence: ExpensesRecurrenceEnum.BOTH,\n      revenueRecurrence: RevenueRecurrenceEnum.BOTH\n\n    };\n\n\n    this.apiBudgetAssistantBackendClientService.apiAnalysisRevenueExpensesPerPeriodAndCategoryCreate(query)\n        .subscribe((res: RevenueAndExpensesPerPeriodAndCategory) => {\n      this.expensesData = this.transformChartDataToPrimeNgFormat(res.chartDataExpenses);\n      this.revenueData = this.transformChartDataToPrimeNgFormat(res.chartDataRevenue);\n      let tableDataRevenue: DistributionByCategoryForPeriodTableData[] = res.tableDataRevenue;\n      let tableDataExpenses: DistributionByCategoryForPeriodTableData[] = res.tableDataExpenses;\n          let tableColumnNames = [...res.tableColumnNamesRevenue, ...res.tableColumnNamesExpenses];\n          this.displayedColumns = tableColumnNames.filter(column => column !== 'categoryId');\n      this.displayedColumnsExceptFirst = this.displayedColumns.slice(1);\n      this.firstColumn = this.displayedColumns[0];\n      this.expensesDataSource = new MatTableDataSource<DistributionByCategoryForPeriodTableData>(tableDataExpenses);\n      this.expensesDataSourceAll = new MatTableDataSource<DistributionByCategoryForPeriodTableData>(tableDataExpenses);\n      this.revenueDataSource = new MatTableDataSource<DistributionByCategoryForPeriodTableData>(tableDataRevenue);\n      this.revenueDataSourceAll = new MatTableDataSource<DistributionByCategoryForPeriodTableData>(tableDataRevenue);\n      this.datatIsLoaded = true;\n    })\n  }\n\n\n  transformChartDataToPrimeNgFormat(chartData: DistributionByCategoryForPeriodChartData[]): any {\n    let labels: string[] = [];\n    let datasets: any[] = [];\n\n    // First, we need to get all unique categories across all periods\n    let allCategories: string[] = [];\n    chartData.forEach(data => {\n      data.entries.forEach(entry => {\n        if (!allCategories.includes(entry.category.qualifiedName as string)) {\n          allCategories.push(entry.category.qualifiedName as string);\n        }\n      });\n    });\n\n    // Initialize datasets for each category\n    allCategories.forEach(category => {\n      datasets.push({\n        label: category,\n        //backgroundColor: '#' + (Math.random() * 0xFFFFFF << 0).toString(16), // generate random color\n        data: []\n      });\n    });\n\n    // Fill in the data for each period\n    chartData.forEach(data => {\n      labels.push((data.period as Period).value);\n\n      // Initialize a map to store the amount for each category in this period\n      let categoryAmountMap: { [key: string]: number } = {};\n      data.entries.forEach(entry => {\n        categoryAmountMap[entry.category.qualifiedName as string] = Math.abs(entry.amount);\n      });\n\n      // Fill in the data for each dataset\n      datasets.forEach(dataset => {\n        dataset.data.push(categoryAmountMap[dataset.label] || 0);\n        dataset.maxBarThickness = 50;\n      });\n    });\n\n    return {\n      labels: labels,\n      datasets: datasets\n    };\n  }\n\n\n  protected readonly TransactionType = TransactionTypeEnum;\n\n\n  ngOnInit(): void {\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['criteria']?.currentValue) {\n      this.doQuery();\n    }\n\n  }\n\n  handleDataSelect($event: any) {\n    console.log($event);\n    let datasetIndex = $event.element.datasetIndex;\n    if (this.criteria.transactionType === TransactionTypeEnum.EXPENSES) {\n      let label = this.expensesData.labels[datasetIndex];\n      let data = this.expensesData.datasets[datasetIndex].data;\n\n    }\n\n  }\n\n  openContextMenu(period: string, category: number, event: MouseEvent) {\n    //fixme: change data model so that we don't store category string but category object\n    // Prevent the browser's default context menu from being opened\n    event.preventDefault();\n\n    this.currentTransactionInContextQuery = {\n      period: period,\n      categoryId: category,\n      bankAccount: this.criteria.bankAccount.accountNumber,\n      transactionType: this.criteria.transactionType as TransactionTypeEnum\n    }\n\n\n  }\n\n  onShowTransactions() {\n    //open TransactionsInContextDialogComponent and pass in currentTransactionInContextQuery\n    const dialogRef = this.dialog.open(TransactionsInContextDialogComponent, {\n      data: this.currentTransactionInContextQuery\n    });\n\n\n\n\n\n  }\n\n\n  protected readonly TransactionTypeEnum = TransactionTypeEnum;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "\r\n.mat-mdc-table {\r\n  border-collapse: collapse;\r\n  td, th {\r\n    border: 1px solid #ddd;\r\n    padding: 8px;\r\n    text-align: left;\r\n\r\n  }\r\n  th {\r\n    background-color: #f2f2f2;\r\n    font-weight: bold;\r\n\r\n  }\r\n  td{\r\n\r\n  }\r\n}\r\n\r\n\r\n.mat-mdc-table-sticky {\r\n  background: #59abfd;\r\n  opacity: 1;\r\n}\r\n.mat-mdc-table-sticky-border-elem-top {\r\n  border-bottom: 2px solid midnightblue;\r\n}\r\n\r\n.mat-mdc-table-sticky-border-elem-right {\r\n  border-left: 2px solid midnightblue;\r\n}\r\n\r\n.mat-mdc-table-sticky-border-elem-bottom {\r\n  border-top: 2px solid midnightblue;\r\n}\r\n\r\n.mat-mdc-table-sticky-border-elem-left {\r\n  border-right: 2px solid midnightblue;\r\n}\r\n\r\n.color-red {\r\n  color: red;\r\n\r\n}\r\n.color-light-coral {\r\n  background: lightcoral;\r\n\r\n}\r\n\r\n.color-green {\r\n  color: green;\r\n}\r\n\r\n.example-menu {\r\n  display: inline-flex;\r\n  flex-direction: column;\r\n  min-width: 180px;\r\n  max-width: 280px;\r\n  background-color: lightgray;\r\n  padding: 6px 0;\r\n}\r\n\r\n.example-menu-item {\r\n  background-color: transparent;\r\n  cursor: pointer;\r\n  border: none;\r\n\r\n  user-select: none;\r\n  min-width: 64px;\r\n  line-height: 36px;\r\n  padding: 0 16px;\r\n\r\n  display: flex;\r\n  align-items: center;\r\n  flex-direction: row;\r\n  flex: 1;\r\n}\r\n\r\n.example-menu-item:hover {\r\n  background-color: rgb(208, 208, 208);\r\n}\r\n\r\n.example-menu-item:active {\r\n  background-color: rgb(170, 170, 170);\r\n}\r\n",
                    "styleUrl": "./revenue-expenses-per-period-and-category.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "apiBudgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 63,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "apiBudgetAssistantBackendClientService",
                        "type": "ApiBudgetAssistantBackendClientService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<div *ngIf=\"datatIsLoaded && this.criteria\">\n<!--<div *ngIf=\"dummyIsLoaded && this.criteria\">-->\n    <ng-template #showTransactions cdkMenuPanel>\n        <div class=\"example-menu\" cdkMenu>\n            <button class=\"example-menu-item\" cdkMenuItem (click)=\"onShowTransactions()\">Show Transactions</button>\n        </div>\n    </ng-template>\n    <div style=\"display: flex; justify-content: space-between;overflow-y: auto; overflow-x: auto; padding-top: 5px\">\n        <div style=\"width: 100%; height: fit-content\">\n            <p-chart type=\"bar\" [data]=\"this.criteria.transactionType == TransactionType.EXPENSES ? expensesData : revenueData\"\n                     [options]=\"chartOptions\" [plugins]=\"plugins\" (onDataSelect)=\"handleDataSelect($event)\"></p-chart>\n        </div>\n    </div>\n    <div style=\" padding-top: 10px; width: 100%; overflow-x: auto\">\n        <h2 [matTooltip]=\"anomaliesToolTip\"  matTooltipPosition=\"above\" style=\"text-align: center; color: rgba(0, 0, 0, 0.50)\">Anomalies</h2>\n        <table style=\"width: 99%\" mat-table\n               [dataSource]=\"this.criteria.transactionType == TransactionTypeEnum.EXPENSES ? expensesDataSource : revenueDataSource\"\n               class=\"mat-z8 full-width-table wrapper\">\n            <!-- Category Column -->\n\n            <ng-container matColumnDef=\"category\" [sticky]=\"true\">\n                <th mat-header-cell *matHeaderCellDef\n                    style=\"position: sticky; top: 0; background: white;\">{{ firstColumn }}\n                </th>\n                <td mat-cell style=\"background-color: #f2f2f2\"\n                    *matCellDef=\"let element\"> {{ element[firstColumn] }}\n                </td>\n            </ng-container>\n\n            <!-- Dynamic table headers -->\n            <ng-container *ngFor=\"let column of displayedColumnsExceptFirst\"\n                          style=\"padding-right: 15px; height: auto; width: auto; word-wrap: anywhere\">\n                <ng-container [matColumnDef]=\"column\"\n                              style=\"padding-right: 15px; height: auto; width: auto; word-wrap: anywhere\">\n                    <th mat-header-cell *matHeaderCellDef\n                        style=\"position: sticky; top: 0; background: white;\">{{ column }}\n                    </th>\n                    <td #amountCell mat-cell style=\"width: max-content\" *matCellDef=\"let element\"\n                        [ngClass]=\"{'color-light-coral' : element[column].color ==='LIGHT_RED'}\"\n                        (contextmenu)=\"openContextMenu(column, element['category'],$event)\"\n                        [cdkContextMenuTriggerFor]=\"showTransactions\"\n\n                    >{{ element[column].value}}</td>\n                </ng-container>\n            </ng-container>\n\n            <!-- Table rows -->\n            <tr mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"></tr>\n            <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\n        </table>\n    </div>\n</div>\n\n\n\n"
        },
        {
            "name": "RulesBuilderComponent",
            "id": "component-RulesBuilderComponent-04735bc33b4322bbcb43f1b88c0d67ec96d8bad9e957827d796a505818903ef606d802406687821d8676e60542c461c4de3277318444566d2241f93e03ee469a",
            "file": "src/app/rules-builder/rules-builder.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "category-rules",
            "styleUrls": [
                "./rules-builder.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./rules-builder.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [
                {
                    "name": "categoryNode",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 26,
                    "type": "CategoryNode",
                    "decorators": []
                }
            ],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "config",
                    "defaultValue": "DEFAULT_QUERY_BUILDER_CONFIG",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "QueryBuilderConfig",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33
                },
                {
                    "name": "ruleSet",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RuleSet",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 28
                },
                {
                    "name": "ruleSetWrapper",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RuleSetWrapper",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 30
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnChanges",
                    "args": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 41,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "changes",
                            "type": "SimpleChanges",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 62,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onRuleSetWrapperChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 66,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "QueryBuilderComponent",
                    "type": "component"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, Input, OnChanges, OnInit, SimpleChanges} from '@angular/core';\nimport {\n    convertClientRuleSetToRuleSet,\n    DEFAULT_QUERY_BUILDER_CONFIG,\n    QueryBuilderConfig,\n    RuleSet\n} from \"../query-builder/query-builder.interfaces\";\nimport {AppService} from \"../app.service\";\nimport {AuthService} from \"../auth/auth.service\";\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport {CategoryNode} from \"../model\";\nimport {QueryBuilderComponent} from '../query-builder/query-builder.component';\nimport {FormsModule} from '@angular/forms';\nimport {TypeEnum, RuleSetWrapper} from \"@daanvdn/budget-assistant-client\";\n\n\n@Component({\n    selector: 'category-rules',\n    templateUrl: './rules-builder.component.html',\n    styleUrls: ['./rules-builder.component.scss'],\n    standalone: true,\n    imports: [QueryBuilderComponent, FormsModule]\n})\nexport class RulesBuilderComponent implements OnInit, OnChanges {\n\n  @Input() categoryNode!: CategoryNode;\n\n  ruleSet!: RuleSet;\n\n  ruleSetWrapper!: RuleSetWrapper;\n\n\n  config: QueryBuilderConfig = DEFAULT_QUERY_BUILDER_CONFIG;\n\n  constructor(private appService: AppService, private authService: AuthService,\n              private errorDialogService: ErrorDialogService) {\n\n\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes['categoryNode']) {\n      // categoryNode input has changed, do something with it\n      let categoryType: TypeEnum = this.categoryNode.type as TypeEnum;\n      let user = this.authService.getUser();\n      if (!user || !user.userName) {\n        this.errorDialogService.openErrorDialog(\"User is not defined!\", undefined);\n        return;\n      }\n      this.appService.getOrCreateRuleSetWrapper(this.categoryNode, categoryType)\n          .subscribe((response: RuleSetWrapper) => {\n              this.ruleSetWrapper = response;\n              this.ruleSet =  convertClientRuleSetToRuleSet(this.ruleSetWrapper.ruleSet);\n            });\n\n\n    }\n\n\n  }\n\n  ngOnInit(): void {\n  }\n\n\n  onRuleSetWrapperChange() {\n    if (this.ruleSet.isComplete()) {\n\n      this.appService.saveRuleSetWrapper(this.ruleSetWrapper).subscribe((response: any) => {\n      });\n\n\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./rules-builder.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 33,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "OnChanges"
            ],
            "templateData": "<div style=\"overflow-x: auto; overflow-y: auto\">\n  <div style=\"padding-top: 10px; text-align: center\">Create rule for category <span style=\"font-weight: bold\">{{ categoryNode.name }}</span></div>\n  <query-builder [allowCollapse]=\"true\" [(ngModel)]='ruleSet' [config]='config' (ngModelChange)=\"onRuleSetWrapperChange()\">\n  </query-builder>\n</div>\n"
        },
        {
            "name": "RulesViewComponent",
            "id": "component-RulesViewComponent-4f05e9743491edc839389e7a4c4703c5b26e6de1bfb250d6e4a9d5a6917040fa285784e66e693611a7565ff325da8300bb8680be6443acb24dba40f080d064ac",
            "file": "src/app/rules-view/rules-view.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-expenses-rules-view",
            "styleUrls": [
                "./rules-view.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./rules-view.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "activeView",
                    "defaultValue": "ActiveView.EXPENSES",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ActiveView",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54
                },
                {
                    "name": "ActiveView",
                    "defaultValue": "ActiveView",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 103,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "dialog",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatDialog",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "expensesCategoryWrapper",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryTreeWrapper",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55
                },
                {
                    "name": "faNetworkWired",
                    "defaultValue": "faNetworkWired",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 82,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "faPlay",
                    "defaultValue": "faPlay",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 83,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "faSearch",
                    "defaultValue": "faSearch",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 142,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "hasChild",
                    "defaultValue": "() => {...}",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 79
                },
                {
                    "name": "revenueCategoryTreeWrapper",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryTreeWrapper",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56
                },
                {
                    "name": "selectedCategoryNode",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryNode",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 58
                },
                {
                    "name": "showCategoryTree",
                    "defaultValue": "true",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "boolean",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                }
            ],
            "methodsClass": [
                {
                    "name": "getTooltip",
                    "args": [
                        {
                            "name": "node",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 86,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "node",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 74,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onChangeSelectedBankAccountsForCurrentRule",
                    "args": [
                        {
                            "name": "$event",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 138,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "$event",
                            "type": "string[]",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onClickCreateRule",
                    "args": [
                        {
                            "name": "node",
                            "type": "CategoryNode",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 69,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "node",
                            "type": "CategoryNode",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "onClickNavigateBackToCategories",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 105,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onToggleChange",
                    "args": [
                        {
                            "name": "$event",
                            "type": "MatButtonToggleChange",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 92,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "$event",
                            "type": "MatButtonToggleChange",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "openDialog",
                    "args": [
                        {
                            "name": "data",
                            "type": "TransactionsCategorizationResponse",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 130,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "data",
                            "type": "TransactionsCategorizationResponse",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "runRules",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 109,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatToolbar"
                },
                {
                    "name": "MatIconButton"
                },
                {
                    "name": "FaIconComponent",
                    "type": "component"
                },
                {
                    "name": "MatTooltip"
                },
                {
                    "name": "NgSwitch"
                },
                {
                    "name": "NgSwitchCase"
                },
                {
                    "name": "MatButtonToggleGroup"
                },
                {
                    "name": "MatButtonToggle"
                },
                {
                    "name": "MatTree"
                },
                {
                    "name": "MatTreeNodeDef"
                },
                {
                    "name": "MatTreeNode"
                },
                {
                    "name": "MatTreeNodeToggle"
                },
                {
                    "name": "MatIcon"
                },
                {
                    "name": "MatNestedTreeNode"
                },
                {
                    "name": "MatTreeNodeOutlet"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "RulesBuilderComponent",
                    "type": "component"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {NestedTreeControl} from '@angular/cdk/tree';\nimport {Component, Inject, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport { MatTreeNestedDataSource, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodeToggle, MatNestedTreeNode, MatTreeNodeOutlet } from \"@angular/material/tree\";\nimport {faNetworkWired, faPlay} from \"@fortawesome/free-solid-svg-icons\";\nimport { MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggle } from \"@angular/material/button-toggle\";\nimport { MAT_DIALOG_DATA, MatDialog, MatDialogRef, MatDialogTitle, MatDialogContent, MatDialogActions } from \"@angular/material/dialog\";\nimport {ActiveView, CategoryNode, TransactionsCategorizationResponse} from \"../model\";\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport {AuthService} from \"../auth/auth.service\";\nimport {faSearch} from \"@fortawesome/free-solid-svg-icons/faSearch\";\nimport { MatToolbar } from '@angular/material/toolbar';\nimport { MatIconButton, MatButton } from '@angular/material/button';\nimport { FaIconComponent } from '@fortawesome/angular-fontawesome';\nimport { MatTooltip } from '@angular/material/tooltip';\nimport { NgSwitch, NgSwitchCase } from '@angular/common';\nimport { MatIcon } from '@angular/material/icon';\nimport { RulesBuilderComponent } from '../rules-builder/rules-builder.component';\nimport { CdkScrollable } from '@angular/cdk/scrolling';\n\n\n@Component({\n    selector: 'app-dialog', templateUrl: './run-categorization-dialog-component.component.html',\n    standalone: true,\n    imports: [\n        MatDialogTitle,\n        CdkScrollable,\n        MatDialogContent,\n        MatDialogActions,\n        MatButton,\n    ],\n})\nexport class RunCategorizationDialogComponent {\n\n  constructor(public dialogRef: MatDialogRef<RunCategorizationDialogComponent>,\n              @Inject(MAT_DIALOG_DATA) public data: TransactionsCategorizationResponse) {\n  }\n\n  onOkClick(): void {\n    this.dialogRef.close();\n  }\n\n}\n\n@Component({\n    selector: 'app-expenses-rules-view',\n    templateUrl: './rules-view.component.html',\n    styleUrls: ['./rules-view.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, MatIconButton, FaIconComponent, MatTooltip, NgSwitch, NgSwitchCase, MatButtonToggleGroup, MatButtonToggle, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodeToggle, MatIcon, MatNestedTreeNode, MatTreeNodeOutlet, MatButton, RulesBuilderComponent]\n})\nexport class RulesViewComponent implements OnInit {\n\n  activeView: ActiveView = ActiveView.EXPENSES;\n  expensesCategoryWrapper!: CategoryTreeWrapper;\n  revenueCategoryTreeWrapper!: CategoryTreeWrapper;\n\n  selectedCategoryNode!: CategoryNode;\n\n\n  showCategoryTree: boolean = true;\n\n\n  constructor(private appService: AppService, public dialog: MatDialog,\n              private errorDialogService: ErrorDialogService, private authService: AuthService){\n  }\n\n\n  onClickCreateRule(node: CategoryNode){\n    this.selectedCategoryNode = node;\n    this.showCategoryTree= false;\n  }\n\n  ngOnInit(): void {\n    this.expensesCategoryWrapper = new CategoryTreeWrapper(this.appService, \"expenses\");\n    this.revenueCategoryTreeWrapper = new CategoryTreeWrapper(this.appService, \"revenue\");\n  }\n\n  hasChild = (_: number, node: CategoryNode) => !!node.children && node.children.length > 0;\n\n\n  protected readonly faNetworkWired = faNetworkWired;\n  protected readonly faPlay = faPlay;\n\n\n  getTooltip(node: any): string {\n    let qualifiedName = (node as CategoryNode).qualifiedName;\n    return `create rule for category ${qualifiedName}`\n\n  }\n\n  onToggleChange($event: MatButtonToggleChange) {\n    const value = $event.value;\n    if (value === \"expenses\") {\n      this.activeView = ActiveView.EXPENSES;\n    } else if (value === \"revenue\") {\n      this.activeView = ActiveView.REVENUE;\n    } else {\n      throw new Error(\"Unknown value \" + value);\n    }\n  }\n\n  protected readonly ActiveView = ActiveView;\n\n  onClickNavigateBackToCategories() {\n    this.showCategoryTree = true;\n  }\n\n  runRules() {\n    try {\n      let user = this.authService.getUser();\n      if (!user ||!user.userName) {\n        this.errorDialogService.openErrorDialog(\"Cannot run rules\", \"User is not defined!\");\n        return;\n      }\n\n      this.appService.categorizeTransactions(user.userName).subscribe(response => {\n          this.openDialog(response);\n        },\n\n        error => {\n          this.errorDialogService.openErrorDialog(\"Error running categorization\", error.message)\n        })\n    } catch (e) {\n\n      this.errorDialogService.openErrorDialog(\"Error running categorization\", (e as Error).message);\n    }\n  }\n\n  openDialog(data: TransactionsCategorizationResponse): void {\n    const dialogRef = this.dialog.open(RunCategorizationDialogComponent, {\n      minWidth: '400px', data: data\n    });\n\n\n  }\n\n  onChangeSelectedBankAccountsForCurrentRule($event: string[]) {\n\n  }\n\n  protected readonly faSearch = faSearch;\n}\n\n\nclass CategoryTreeWrapper {\n\n  treeControl = new NestedTreeControl<CategoryNode>(node => node.children);\n  dataSource = new MatTreeNestedDataSource<CategoryNode>();\n\n\n  constructor(private appService: AppService, type: string) {\n    const illegalNodes = [\"NO CATEGORY\", \"DUMMY CATEGORY\"]\n\n    const filterAndSortNodes = (nodes: CategoryNode[]) => {\n      return nodes.filter(n => !illegalNodes.includes(n.name)).sort((a, b) => a.name.localeCompare(b.name));\n    }\n\n\n    switch (type) {\n      case \"revenue\":\n        this.appService.sharedCategoryTreeRevenueObservable$.subscribe(nodes => {\n          this.dataSource.data = filterAndSortNodes(nodes);\n        })\n        break;\n      case \"expenses\":\n        this.appService.sharedCategoryTreeExpensesObservable$.subscribe(nodes => {\n          this.dataSource.data = filterAndSortNodes(nodes);\n        })\n        break;\n      default:\n        throw new Error(\"Unknown type \" + type + \"!\");\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".example-tree-invisible {\r\n  display: none;\r\n}\r\n\r\n.example-tree ul,\r\n.example-tree li {\r\n  margin-top: 0;\r\n  margin-bottom: 0;\r\n  list-style-type: none;\r\n}\r\n\r\n/*\r\n * This padding sets alignment of the nested nodes.\r\n */\r\n.example-tree .mat-nested-tree-node div[role=group] {\r\n  padding-left: 40px;\r\n}\r\n\r\n/*\r\n * Padding for leaf nodes.\r\n * Leaf nodes need to have padding so as to align with other non-leaf nodes\r\n * under the same parent.\r\n */\r\n.example-tree div[role=group] > .mat-tree-node {\r\n  padding-left: 40px;\r\n}\r\n\r\n.center-content {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.right-content {\r\n  /* Adjust these properties as needed */\r\n  width: 100%; /* This will make the div take up the full width of its parent. Adjust as needed. */\r\n  text-align: right; /* This will align the text to the right. Adjust as needed. */\r\n}\r\n\r\n.grid-container {\r\n  display: flex;\r\n  grid-template-columns: 1fr 1fr;\r\n  grid-gap: 20px;\r\n}\r\n\r\n.parent {\r\n  position: relative;\r\n  width: 100%; /* Ensure the parent takes up the full width */\r\n  padding-bottom: 20px;\r\n  margin-bottom: 20px;\r\n  //height: 100vh;\r\n}\r\n\r\n.child0 {\r\n  position: absolute;\r\n  left: 1%; /* Position child1 at 50% of the parent's width */\r\n  //transform: translateX(-10%); /* Center child1 horizontally */\r\n  padding-right: 10px;\r\n}\r\n.child1 {\r\n  position: absolute;\r\n  left: 50%; /* Position child1 at 50% of the parent's width */\r\n  transform: translateX(-50%); /* Center child1 horizontally */\r\n}\r\n\r\n.child2 {\r\n  position: absolute;\r\n  right: 0; /* Position child2 at the right edge of the parent */\r\n  padding-right: 10px;\r\n\r\n}\r\n\r\n.button-container {\r\n  display: flex;\r\n  //justify-content: flex-end;\r\n  justify-content: center;\r\n}\r\n\r\n\r\n.toolbar-container {\r\n  display: flex;\r\n  justify-content: space-between;\r\n}\r\n.title {\r\n  flex: 1;\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n",
                    "styleUrl": "./rules-view.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 61,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<mat-toolbar color=\"primary\" class=\"toolbar-container\">\n    <span class=\"title\">Rules</span>\n    <button (click)=\"runRules()\"  class=\"button-container\" mat-icon-button>\n        <fa-icon style=\"justify-content: center\" [icon]=\"faPlay\" [fixedWidth]=\"true\" matTooltip=\"Run rules\"></fa-icon>\n    </button>\n\n</mat-toolbar>\n\n<div style=\"padding-left: 10px\">\n\n  <div [ngSwitch]=\"showCategoryTree\">\n    <div *ngSwitchCase=\"true\">\n\n      <div class=\"parent\">\n        <div class=\"child0\" >\n\n        </div>\n        <div class=\"child1\">\n          <mat-button-toggle-group (change)=\"onToggleChange($event)\" name=\"fontStyle\" aria-label=\"Font Style\">\n            <mat-button-toggle [checked]=\"true\" value=\"expenses\">Expenses</mat-button-toggle>\n            <mat-button-toggle value=\"revenue\">Revenue</mat-button-toggle>\n          </mat-button-toggle-group>\n        </div>\n\n      </div>\n      <div [ngSwitch]=\"activeView\" style=\"height: 95vh; overflow-y: scroll\">\n        <div *ngSwitchCase=\"ActiveView.EXPENSES\">\n          <mat-tree style=\"padding-left: 10px\"\n                    [dataSource]=\"expensesCategoryWrapper.dataSource\" [treeControl]=\"expensesCategoryWrapper.treeControl\"\n                    class=\"example-tree\">\n            <!-- This is the tree node template for leaf nodes -->\n            <!-- There is inline padding applied to this node using styles.\n              This padding value depends on the mat-icon-button width. -->\n            <mat-tree-node *matTreeNodeDef=\"let node\" matTreeNodeToggle>\n              <div class=\"mat-tree-node\">\n                <button mat-icon-button [disabled]=\"true\">\n                  <mat-icon>remove</mat-icon>\n                </button>\n                {{ node.name }}\n                <button (click)=\"onClickCreateRule(node)\" mat-icon-button>\n                  <fa-icon [icon]=\"faNetworkWired\" [fixedWidth]=\"true\" [matTooltip]=\"getTooltip(node)\"></fa-icon>\n                </button>\n              </div>\n            </mat-tree-node>\n            <!-- This is the tree node template for expandable nodes -->\n            <mat-nested-tree-node *matTreeNodeDef=\"let node; when: hasChild\">\n              <div class=\"mat-tree-node\">\n                <button mat-icon-button matTreeNodeToggle\n                        [attr.aria-label]=\"'Toggle ' + node.name\">\n                  <mat-icon class=\"mat-icon-rtl-mirror\">\n                    {{ expensesCategoryWrapper.treeControl.isExpanded(node) ? 'expand_more' : 'add' }}\n                  </mat-icon>\n                </button>\n                {{ node.name }}\n                <button (click)=\"onClickCreateRule(node)\" mat-icon-button>\n                  <fa-icon [icon]=\"faNetworkWired\" [fixedWidth]=\"true\" [matTooltip]=\"getTooltip(node)\"></fa-icon>\n                </button>\n              </div>\n              <!-- There is inline padding applied to this div using styles.\n                  This padding value depends on the mat-icon-button width.  -->\n              <div [class.example-tree-invisible]=\"!expensesCategoryWrapper.treeControl.isExpanded(node)\"\n                   role=\"group\">\n                <ng-container matTreeNodeOutlet></ng-container>\n              </div>\n            </mat-nested-tree-node>\n          </mat-tree>\n        </div>\n        <div *ngSwitchCase=\"ActiveView.REVENUE\">\n          <mat-tree  style=\"padding-left: 10px\"\n                    [dataSource]=\"revenueCategoryTreeWrapper.dataSource\"\n                    [treeControl]=\"revenueCategoryTreeWrapper.treeControl\" class=\"example-tree\">\n            <!-- This is the tree node template for leaf nodes -->\n            <!-- There is inline padding applied to this node using styles.\n              This padding value depends on the mat-icon-button width. -->\n            <mat-tree-node *matTreeNodeDef=\"let node\" matTreeNodeToggle>\n              <div class=\"mat-tree-node\">\n                <button mat-icon-button [disabled]=\"true\">\n                  <mat-icon>remove</mat-icon>\n                </button>\n                {{ node.name }}\n                <button (click)=\"onClickCreateRule(node)\" mat-icon-button>\n                  <fa-icon [icon]=\"faNetworkWired\" [fixedWidth]=\"true\" [matTooltip]=\"getTooltip(node)\"></fa-icon>\n                </button>\n              </div>\n            </mat-tree-node>\n            <!-- This is the tree node template for expandable nodes -->\n            <mat-nested-tree-node *matTreeNodeDef=\"let node; when: hasChild\">\n              <div class=\"mat-tree-node\">\n                <button mat-icon-button matTreeNodeToggle\n                        [attr.aria-label]=\"'Toggle ' + node.name\">\n                  <mat-icon class=\"mat-icon-rtl-mirror\">\n                    {{ revenueCategoryTreeWrapper.treeControl.isExpanded(node) ? 'expand_more' : 'add' }}\n                  </mat-icon>\n                </button>\n                {{ node.name }}\n                <button (click)=\"onClickCreateRule(node)\" mat-icon-button>\n                  <fa-icon [icon]=\"faNetworkWired\" [fixedWidth]=\"true\" [matTooltip]=\"getTooltip(node)\"></fa-icon>\n                </button>\n              </div>\n              <!-- There is inline padding applied to this div using styles.\n                  This padding value depends on the mat-icon-button width.  -->\n              <div [class.example-tree-invisible]=\"!revenueCategoryTreeWrapper.treeControl.isExpanded(node)\"\n                   role=\"group\">\n                <ng-container matTreeNodeOutlet></ng-container>\n              </div>\n            </mat-nested-tree-node>\n          </mat-tree>\n        </div>\n      </div>\n    </div>\n    <div *ngSwitchCase=\"false\">\n      <div class=\"grid-container\">\n        <div class=\"grid-child\" style=\"padding-top: 5px; padding-left: 5px\">\n          <button mat-raised-button (click)=\"onClickNavigateBackToCategories()\"\n                  matTooltip=\"Navigate back to category overview\">\n            <mat-icon>keyboard_backspace</mat-icon>\n          </button>\n        </div>\n      </div>\n      <div>\n        <category-rules [categoryNode]=\"selectedCategoryNode\">\n        </category-rules>\n      </div>\n    </div>\n\n  </div>\n\n</div>\n"
        },
        {
            "name": "RunCategorizationDialogComponent",
            "id": "component-RunCategorizationDialogComponent-4f05e9743491edc839389e7a4c4703c5b26e6de1bfb250d6e4a9d5a6917040fa285784e66e693611a7565ff325da8300bb8680be6443acb24dba40f080d064ac",
            "file": "src/app/rules-view/rules-view.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-dialog",
            "styleUrls": [],
            "styles": [],
            "templateUrl": [
                "./run-categorization-dialog-component.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionsCategorizationResponse",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 36,
                    "decorators": [
                        {
                            "name": "Inject",
                            "stringifiedArguments": "MAT_DIALOG_DATA"
                        }
                    ],
                    "modifierKind": [
                        170,
                        125
                    ]
                },
                {
                    "name": "dialogRef",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatDialogRef<RunCategorizationDialogComponent>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35,
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "onOkClick",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 39,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatDialogTitle"
                },
                {
                    "name": "CdkScrollable"
                },
                {
                    "name": "MatDialogContent"
                },
                {
                    "name": "MatDialogActions"
                },
                {
                    "name": "MatButton"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {NestedTreeControl} from '@angular/cdk/tree';\nimport {Component, Inject, OnInit} from '@angular/core';\nimport {AppService} from \"../app.service\";\nimport { MatTreeNestedDataSource, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodeToggle, MatNestedTreeNode, MatTreeNodeOutlet } from \"@angular/material/tree\";\nimport {faNetworkWired, faPlay} from \"@fortawesome/free-solid-svg-icons\";\nimport { MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggle } from \"@angular/material/button-toggle\";\nimport { MAT_DIALOG_DATA, MatDialog, MatDialogRef, MatDialogTitle, MatDialogContent, MatDialogActions } from \"@angular/material/dialog\";\nimport {ActiveView, CategoryNode, TransactionsCategorizationResponse} from \"../model\";\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport {AuthService} from \"../auth/auth.service\";\nimport {faSearch} from \"@fortawesome/free-solid-svg-icons/faSearch\";\nimport { MatToolbar } from '@angular/material/toolbar';\nimport { MatIconButton, MatButton } from '@angular/material/button';\nimport { FaIconComponent } from '@fortawesome/angular-fontawesome';\nimport { MatTooltip } from '@angular/material/tooltip';\nimport { NgSwitch, NgSwitchCase } from '@angular/common';\nimport { MatIcon } from '@angular/material/icon';\nimport { RulesBuilderComponent } from '../rules-builder/rules-builder.component';\nimport { CdkScrollable } from '@angular/cdk/scrolling';\n\n\n@Component({\n    selector: 'app-dialog', templateUrl: './run-categorization-dialog-component.component.html',\n    standalone: true,\n    imports: [\n        MatDialogTitle,\n        CdkScrollable,\n        MatDialogContent,\n        MatDialogActions,\n        MatButton,\n    ],\n})\nexport class RunCategorizationDialogComponent {\n\n  constructor(public dialogRef: MatDialogRef<RunCategorizationDialogComponent>,\n              @Inject(MAT_DIALOG_DATA) public data: TransactionsCategorizationResponse) {\n  }\n\n  onOkClick(): void {\n    this.dialogRef.close();\n  }\n\n}\n\n@Component({\n    selector: 'app-expenses-rules-view',\n    templateUrl: './rules-view.component.html',\n    styleUrls: ['./rules-view.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, MatIconButton, FaIconComponent, MatTooltip, NgSwitch, NgSwitchCase, MatButtonToggleGroup, MatButtonToggle, MatTree, MatTreeNodeDef, MatTreeNode, MatTreeNodeToggle, MatIcon, MatNestedTreeNode, MatTreeNodeOutlet, MatButton, RulesBuilderComponent]\n})\nexport class RulesViewComponent implements OnInit {\n\n  activeView: ActiveView = ActiveView.EXPENSES;\n  expensesCategoryWrapper!: CategoryTreeWrapper;\n  revenueCategoryTreeWrapper!: CategoryTreeWrapper;\n\n  selectedCategoryNode!: CategoryNode;\n\n\n  showCategoryTree: boolean = true;\n\n\n  constructor(private appService: AppService, public dialog: MatDialog,\n              private errorDialogService: ErrorDialogService, private authService: AuthService){\n  }\n\n\n  onClickCreateRule(node: CategoryNode){\n    this.selectedCategoryNode = node;\n    this.showCategoryTree= false;\n  }\n\n  ngOnInit(): void {\n    this.expensesCategoryWrapper = new CategoryTreeWrapper(this.appService, \"expenses\");\n    this.revenueCategoryTreeWrapper = new CategoryTreeWrapper(this.appService, \"revenue\");\n  }\n\n  hasChild = (_: number, node: CategoryNode) => !!node.children && node.children.length > 0;\n\n\n  protected readonly faNetworkWired = faNetworkWired;\n  protected readonly faPlay = faPlay;\n\n\n  getTooltip(node: any): string {\n    let qualifiedName = (node as CategoryNode).qualifiedName;\n    return `create rule for category ${qualifiedName}`\n\n  }\n\n  onToggleChange($event: MatButtonToggleChange) {\n    const value = $event.value;\n    if (value === \"expenses\") {\n      this.activeView = ActiveView.EXPENSES;\n    } else if (value === \"revenue\") {\n      this.activeView = ActiveView.REVENUE;\n    } else {\n      throw new Error(\"Unknown value \" + value);\n    }\n  }\n\n  protected readonly ActiveView = ActiveView;\n\n  onClickNavigateBackToCategories() {\n    this.showCategoryTree = true;\n  }\n\n  runRules() {\n    try {\n      let user = this.authService.getUser();\n      if (!user ||!user.userName) {\n        this.errorDialogService.openErrorDialog(\"Cannot run rules\", \"User is not defined!\");\n        return;\n      }\n\n      this.appService.categorizeTransactions(user.userName).subscribe(response => {\n          this.openDialog(response);\n        },\n\n        error => {\n          this.errorDialogService.openErrorDialog(\"Error running categorization\", error.message)\n        })\n    } catch (e) {\n\n      this.errorDialogService.openErrorDialog(\"Error running categorization\", (e as Error).message);\n    }\n  }\n\n  openDialog(data: TransactionsCategorizationResponse): void {\n    const dialogRef = this.dialog.open(RunCategorizationDialogComponent, {\n      minWidth: '400px', data: data\n    });\n\n\n  }\n\n  onChangeSelectedBankAccountsForCurrentRule($event: string[]) {\n\n  }\n\n  protected readonly faSearch = faSearch;\n}\n\n\nclass CategoryTreeWrapper {\n\n  treeControl = new NestedTreeControl<CategoryNode>(node => node.children);\n  dataSource = new MatTreeNestedDataSource<CategoryNode>();\n\n\n  constructor(private appService: AppService, type: string) {\n    const illegalNodes = [\"NO CATEGORY\", \"DUMMY CATEGORY\"]\n\n    const filterAndSortNodes = (nodes: CategoryNode[]) => {\n      return nodes.filter(n => !illegalNodes.includes(n.name)).sort((a, b) => a.name.localeCompare(b.name));\n    }\n\n\n    switch (type) {\n      case \"revenue\":\n        this.appService.sharedCategoryTreeRevenueObservable$.subscribe(nodes => {\n          this.dataSource.data = filterAndSortNodes(nodes);\n        })\n        break;\n      case \"expenses\":\n        this.appService.sharedCategoryTreeExpensesObservable$.subscribe(nodes => {\n          this.dataSource.data = filterAndSortNodes(nodes);\n        })\n        break;\n      default:\n        throw new Error(\"Unknown type \" + type + \"!\");\n    }\n  }\n}\n",
            "assetsDirs": [],
            "styleUrlsData": "",
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "dialogRef",
                        "type": "MatDialogRef<RunCategorizationDialogComponent>",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "data",
                        "type": "TransactionsCategorizationResponse",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 33,
                "jsdoctags": [
                    {
                        "name": "dialogRef",
                        "type": "MatDialogRef<RunCategorizationDialogComponent>",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "data",
                        "type": "TransactionsCategorizationResponse",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "templateData": "<div class=\"mat-typography\">\r\n  <h3 mat-dialog-title>Categorization result</h3>\r\n  <div mat-dialog-content>\r\n    <div >Message: {{ data.message }}</div>\r\n    <div>Transactions with category: {{ data.withCategoryCount }}</div>\r\n    <div>Transactions without category: {{ data.withoutCategoryCount }}</div>\r\n    <div>Type: {{ data.type }}</div>\r\n  </div>\r\n  <div mat-dialog-actions style=\"justify-content: center\">\r\n    <button mat-button (click)=\"onOkClick()\">OK</button>\r\n  </div>\r\n</div>\r\n"
        },
        {
            "name": "SaveErrorDialogComponent",
            "id": "component-SaveErrorDialogComponent-3872229279830c699d0627c373375ddb836cb463d710ae6fdfef9d110ed2bff7357e0bc941d15f59debcc8ba91a81e2e3ae1290db784c391f1adc599a38100a7",
            "file": "src/app/budget/save-error-dialog/save-error-dialog.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-save-error-dialog",
            "styleUrls": [
                "./save-error-dialog.component.css"
            ],
            "styles": [],
            "templateUrl": [
                "./save-error-dialog.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "literal type",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 35,
                    "decorators": [
                        {
                            "name": "Inject",
                            "stringifiedArguments": "MAT_DIALOG_DATA"
                        }
                    ],
                    "modifierKind": [
                        170,
                        125
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 39,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatDialogTitle"
                },
                {
                    "name": "MatDialogContent"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                },
                {
                    "name": "MatDialogActions"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "MatDialogClose"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {Component, Inject, OnInit} from '@angular/core';\nimport {\n    MAT_DIALOG_DATA,\n    MatDialogActions,\n    MatDialogClose,\n    MatDialogContent,\n    MatDialogTitle\n} from \"@angular/material/dialog\";\nimport {BudgetTreeNode} from \"../budget.component\";\nimport {\n    MatCell,\n    MatCellDef,\n    MatColumnDef,\n    MatHeaderCell,\n    MatHeaderCellDef,\n    MatHeaderRow,\n    MatHeaderRowDef,\n    MatRow,\n    MatRowDef,\n    MatTable\n} from '@angular/material/table';\nimport {MatButton} from '@angular/material/button';\n\n@Component({\n    selector: 'app-save-error-dialog',\n    templateUrl: './save-error-dialog.component.html',\n    styleUrls: ['./save-error-dialog.component.css'],\n    standalone: true,\n    imports: [MatDialogTitle, MatDialogContent, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatDialogActions, MatButton, MatDialogClose]\n})\nexport class SaveErrorDialogComponent implements OnInit {\n\n\n\n  constructor(@Inject(MAT_DIALOG_DATA) public data: { message: string, nodes: BudgetTreeNode[] }) {\n\n  }\n\n  ngOnInit(): void {\n  }\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "",
                    "styleUrl": "./save-error-dialog.component.css"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "data",
                        "type": "literal type",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 31,
                "jsdoctags": [
                    {
                        "name": "data",
                        "type": "literal type",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<h1 style=\"align-content: center\" mat-dialog-title>Fout</h1>\n<div mat-dialog-content>\n  <div >{{ data.message }}</div>\n  <table mat-table [dataSource]=\"data.nodes\" class=\"mat-z8\" style=\"border-collapse: separate; width: 100%\">\n\n    <!-- Category Column -->\n    <ng-container matColumnDef=\"categorie\">\n      <th mat-header-cell *matHeaderCellDef>Categorie</th>\n      <td mat-cell *matCellDef=\"let node\">{{ node.name }}</td>\n    </ng-container>\n\n    <!-- Budget Column -->\n    <ng-container matColumnDef=\"maandbudget\">\n      <th mat-header-cell *matHeaderCellDef>Maandbudget</th>\n      <td mat-cell *matCellDef=\"let node\">{{ node.budgetTreeNodeAmount }}</td>\n    </ng-container>\n\n    <tr mat-header-row *matHeaderRowDef=\"['categorie', 'maandbudget']\"></tr>\n    <tr mat-row *matRowDef=\"let row; columns: ['categorie', 'maandbudget'];\"></tr>\n\n  </table>\n</div>\n<div mat-dialog-actions>\n  <button mat-button mat-dialog-close>Ok</button>\n</div>\n"
        },
        {
            "name": "TransactionCommunicationsSearchComponent",
            "id": "component-TransactionCommunicationsSearchComponent-5542c230a592dd3197befbc9e9338fa6f218d3732d29f8df6c95d1c54a4234e08156de77ca9bf0314ceae520e19d3d6d66a8fdca78cf5f1710151147de02e585",
            "file": "src/app/transaction-mededelingen-search/transaction-communications-search.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-transaction-communications-search",
            "styleUrls": [
                "./transaction-communications-search.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./transaction-communications-search.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "change",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 16,
                    "type": "EventEmitter<boolean>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "searchText",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 15
                }
            ],
            "methodsClass": [
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 19,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onSearchTextChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 22,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatLabel"
                },
                {
                    "name": "MatInput"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, EventEmitter, OnInit, Output } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { MatFormField, MatLabel } from '@angular/material/form-field';\nimport { MatInput } from '@angular/material/input';\n\n@Component({\n    selector: 'app-transaction-communications-search',\n    templateUrl: './transaction-communications-search.component.html',\n    styleUrls: ['./transaction-communications-search.component.scss'],\n    standalone: true,\n    imports: [FormsModule, MatFormField, MatLabel, MatInput]\n})\nexport class TransactionCommunicationsSearchComponent implements OnInit {\n\n  searchText!: string;\n  @Output() change: EventEmitter<boolean> = new EventEmitter<boolean>();\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n  onSearchTextChange(){\n    this.change.emit();\n  }\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".example-form {\r\n    min-width: 150px;\r\n    max-width: 500px;\r\n    width: 100%;\r\n  }\r\n  \r\n  .example-full-width {\r\n    width: 100%;\r\n  }",
                    "styleUrl": "./transaction-communications-search.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [],
                "line": 16
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<form class=\"example-form\">\n  <mat-form-field class=\"example-full-width\">\n    <mat-label>Transactie / Mededelingen</mat-label>\n    <input type=\"text\" matInput [(ngModel)]=\"searchText\" (change)=\"onSearchTextChange()\" name=\"searchTextInput\">\n  </mat-form-field>\n</form>"
        },
        {
            "name": "TransactionsComponent",
            "id": "component-TransactionsComponent-0e33c21da40ae0a7c023743c17035b9a671d4caa772940232634987f769893efce592228ba5cbd3d9a3c028229654ed100f7c8eb925fac0ab3d6348ccdd492b6",
            "file": "src/app/transactions/transactions.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-transactions",
            "styleUrls": [
                "./transactions.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./transactions.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "accountSelectionComponent",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "BankAccountSelectionComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 56,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "BankAccountSelectionComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "categoryMap",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryMap",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 78
                },
                {
                    "name": "currentSort",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 57,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "dataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "PaginationDataSource<Transaction | TransactionQuery>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 63
                },
                {
                    "name": "datepipe",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "DatePipe",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 82,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "dialog",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatDialog",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 81,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "displayedColumns",
                    "defaultValue": "[\n    \"bookingDate\",\n    \"counterparty\",\n    \"transaction\",\n    \"amount\",\n    \"transactionType\"\n  ]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 64
                },
                {
                    "name": "faTag",
                    "defaultValue": "faTag",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 373,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "fileInput",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 75,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "'fileInput'"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "filesAreUploading",
                    "defaultValue": "false",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 60
                },
                {
                    "name": "paginator",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatPaginator",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 53,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatPaginator, {static: false}"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "selectedAccount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 73
                },
                {
                    "name": "sort",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatSort",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 54,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatSort, {static: false}"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "table",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatTable<Transaction>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 55,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "MatTable"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "transactionQuery",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionQuery",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 71
                },
                {
                    "name": "transactionQueryAsJson",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "string",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 72
                },
                {
                    "name": "transactionToManuallyReview",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 61
                },
                {
                    "name": "viewType",
                    "defaultValue": "ViewType.INITIAL_VIEW",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "ViewType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 77
                },
                {
                    "name": "ViewType",
                    "defaultValue": "ViewType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 372,
                    "modifierKind": [
                        124,
                        148
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "amountType",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AmountType",
                    "typeParameters": [],
                    "line": 209,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "displayDateOrNA",
                    "args": [
                        {
                            "name": "s",
                            "type": "Date | undefined | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string | null",
                    "typeParameters": [],
                    "line": 217,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "s",
                            "type": "Date | undefined | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "displayNumberOrNA",
                    "args": [
                        {
                            "name": "number",
                            "type": "Number | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 194,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "number",
                            "type": "Number | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "displayStringOrNA",
                    "args": [
                        {
                            "name": "s",
                            "type": "string | undefined | null",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 201,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "s",
                            "type": "string | undefined | null",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "doQuery",
                    "args": [
                        {
                            "name": "transactionQuery",
                            "type": "TransactionQuery | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 346,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transactionQuery",
                            "type": "TransactionQuery | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getNrOfTransactionsToManuallyReview",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 375,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "getNrOfTransactionsToManuallyReviewTooltip",
                    "args": [],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 386,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleAccountChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 252,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "initDataSource",
                    "args": [
                        {
                            "name": "account",
                            "type": "string | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "PaginationDataSource<Transaction, TransactionQuery>",
                    "typeParameters": [],
                    "line": 292,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "name": "account",
                            "type": "string | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 280,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 285,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onChangeFileInput",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 110,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onClickFileInputButton",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 106,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "openDialog",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 225,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "saveTransaction",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 308,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setCategory",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "selectedCategoryQualifiedNameStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 326,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "selectedCategoryQualifiedNameStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setIsAdvanceSharedAccount",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "event",
                            "type": "MatRadioChange",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 319,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "event",
                            "type": "MatRadioChange",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setIsRecurring",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "event",
                            "type": "MatRadioChange",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 312,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "event",
                            "type": "MatRadioChange",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "showAllTransactions",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 274,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "showTransactionsToManuallyReview",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 101,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "sortBy",
                    "args": [
                        {
                            "name": "event",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 335,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "translateBooleanToDutchJaNee",
                    "args": [
                        {
                            "name": "b",
                            "type": "Boolean | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "string",
                    "typeParameters": [],
                    "line": 183,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "b",
                            "type": "Boolean | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatToolbar"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "MatProgressSpinner"
                },
                {
                    "name": "BankAccountSelectionComponent",
                    "type": "component"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "MatIcon"
                },
                {
                    "name": "MatTooltip"
                },
                {
                    "name": "MatBadge"
                },
                {
                    "name": "FaIconComponent",
                    "type": "component"
                },
                {
                    "name": "MatPaginator"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "MatSort"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatSortHeader"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "CategoryTreeDropdownComponent",
                    "type": "component"
                },
                {
                    "name": "MatRadioGroup"
                },
                {
                    "name": "MatRadioButton"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                },
                {
                    "name": "AsyncPipe",
                    "type": "pipe"
                },
                {
                    "name": "TitleCasePipe",
                    "type": "pipe"
                },
                {
                    "name": "DatePipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { DatePipe, NgIf, AsyncPipe, TitleCasePipe } from '@angular/common';\nimport {AfterViewInit, Component, OnInit, ViewChild} from '@angular/core';\nimport {MatDialog} from '@angular/material/dialog';\nimport {MatPaginator} from '@angular/material/paginator';\nimport { MatRadioChange, MatRadioGroup, MatRadioButton } from '@angular/material/radio';\nimport { MatSort, MatSortHeader } from '@angular/material/sort';\nimport { MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from '@angular/material/table';\nimport {PaginationDataSource} from '@daanvdn/ngx-pagination-data-source';\nimport {AppService} from '../app.service';\nimport {\n  AmountType, CategoryMap,\n  CompositeTransactionsFileUploadResponse, EMPTY_TRANSACTION_QUERY, FileWrapper, inferAmountType\n} from '../model';\nimport {BankAccountSelectionComponent} from '../bank-account-selection/bank-account-selection.component';\nimport {TransactionSearchDialogComponent} from '../transaction-search-dialog/transaction-search-dialog.component';\nimport {AuthService} from \"../auth/auth.service\";\nimport { HttpEventType, HttpResponse } from \"@angular/common/http\";\nimport {ErrorDialogService} from \"../error-dialog/error-dialog.service\";\nimport {faTag} from \"@fortawesome/free-solid-svg-icons\";\nimport {Router} from \"@angular/router\";\nimport {Transaction, TransactionQuery, TransactionTypeEnum} from '@daanvdn/budget-assistant-client';\nimport { MatToolbar } from '@angular/material/toolbar';\nimport { MatProgressSpinner } from '@angular/material/progress-spinner';\nimport { MatButton } from '@angular/material/button';\nimport { MatIcon } from '@angular/material/icon';\nimport { MatTooltip } from '@angular/material/tooltip';\nimport { MatBadge } from '@angular/material/badge';\nimport { FaIconComponent } from '@fortawesome/angular-fontawesome';\nimport { CategoryTreeDropdownComponent } from '../category-tree-dropdown/category-tree-dropdown.component';\n\n\nenum ViewType {\n  INITIAL_VIEW = \"INITIAL_VIEW\",\n  RUN_QUERY = \"RUN_QUERY\",\n  SHOW_ALL = \"SHOW_ALL\",\n  UPLOAD_TRANSACTIONS = \"UPLOAD_TRANSACTIONS\",\n}\n\n\n@Component({\n    selector: 'app-transactions',\n    templateUrl: './transactions.component.html',\n    styleUrls: ['./transactions.component.scss'],\n    standalone: true,\n    imports: [MatToolbar, NgIf, MatProgressSpinner, BankAccountSelectionComponent, MatButton, MatIcon, MatTooltip, MatBadge, FaIconComponent, MatPaginator, MatTable, MatSort, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatSortHeader, MatCellDef, MatCell, CategoryTreeDropdownComponent, MatRadioGroup, MatRadioButton, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, AsyncPipe, TitleCasePipe, DatePipe]\n})\nexport class TransactionsComponent implements OnInit, AfterViewInit {\n\n\n\n\n  //table stuff\n  @ViewChild(MatPaginator, { static: false }) paginator!: MatPaginator;\n  @ViewChild(MatSort, { static: false }) sort!: MatSort;\n  @ViewChild(MatTable) table!: MatTable<Transaction>;\n  @ViewChild(BankAccountSelectionComponent) accountSelectionComponent!: BankAccountSelectionComponent;\n  private currentSort?: any;\n\n\n  filesAreUploading = false; // Add this line\n  transactionToManuallyReview!: Number;\n\n  dataSource: PaginationDataSource<Transaction, TransactionQuery>;\n  displayedColumns = [\n    \"bookingDate\",\n    \"counterparty\",\n    \"transaction\",\n    \"amount\",\n    \"transactionType\"\n  ];\n  transactionQuery?: TransactionQuery;\n  transactionQueryAsJson?: string;\n  selectedAccount?:string;\n\n  @ViewChild('fileInput') fileInput: any;\n\n  viewType: ViewType = ViewType.INITIAL_VIEW;\n  categoryMap?: CategoryMap;\n\n\n  constructor(private appService: AppService, private authService: AuthService, public dialog: MatDialog,\n              public datepipe: DatePipe, private errorDialogService: ErrorDialogService, private router: Router) {\n\n    let account = undefined\n    this.dataSource = this.initDataSource(account);\n    this.appService.categoryMapObservable$.subscribe(categoryMap => {\n      this.categoryMap = categoryMap;\n    })\n\n    this.appService.selectedBankAccountObservable$.subscribe(bankAccount => {\n      if (bankAccount) {\n        this.appService.countTransactionToManuallyReview(bankAccount).subscribe(count => {\n          this.transactionToManuallyReview = count;\n\n        });\n      }\n    })\n\n  }\n\n  showTransactionsToManuallyReview(){\n\n    this.router.navigate(['/categorieën']);\n  }\n\n  onClickFileInputButton(): void {\n    this.fileInput.nativeElement.click();\n  }\n\n  onChangeFileInput(): void {\n    this.filesAreUploading = true;\n    let files: File[] = this.fileInput.nativeElement.files;\n    let fileWrapperArray: FileWrapper[] = [];\n\n    for (let index = 0; index < files.length; index++) {\n      const file = files[index];\n      fileWrapperArray.push({ file: file, inProgress: false, progress: 0, failed: false });\n    }\n\n    let currentUser = this.authService.getUser();\n    if (!currentUser || !currentUser.userName) {\n      this.errorDialogService.openErrorDialog(\"Cannot upload transactions!\", \"User is not defined\");\n      return;\n    }\n    this.appService.uploadTransactionFiles(fileWrapperArray, currentUser.userName).subscribe(result => {\n\n      if (result.type === HttpEventType.Response) {\n\n        let response = result as HttpResponse<CompositeTransactionsFileUploadResponse>\n        let uploadTimestamp = response.body?.uploadTimestamp;\n        if (uploadTimestamp === undefined) {\n          this.filesAreUploading = false;\n          throw new Error(\"uploadTimestamp is undefined\");\n        }\n\n        let newSort;\n        if (this.currentSort !== undefined) {\n          newSort = this.currentSort;\n        } else {\n\n          newSort = {property: 'bookingDate', order: 'desc'}\n          this.currentSort = newSort;\n        }\n\n        let transactionQuery: TransactionQuery = {\n          transactionType: TransactionTypeEnum.BOTH,\n          counterpartyName: undefined,\n          minAmount: undefined,\n          maxAmount: undefined,\n          accountNumber: undefined,\n          categoryId: undefined,\n          counterpartyAccountNumber: undefined,\n          startDate: undefined,\n          endDate: undefined,\n          transactionOrCommunication: undefined,\n          uploadTimestamp: uploadTimestamp\n        }\n\n        this.dataSource = new PaginationDataSource<Transaction, TransactionQuery>(\n          (request, query) => {\n            request.size = 50;\n            return this.appService.pageTransactions(request, query);\n          },\n          newSort, transactionQuery\n        );\n        this.viewType = ViewType.UPLOAD_TRANSACTIONS;\n        this.filesAreUploading = false;\n\n\n      }\n\n\n    })\n\n\n\n\n\n\n  }\n\n\n  translateBooleanToDutchJaNee(b: Boolean | undefined): string {\n    if (b === undefined) {\n      return \"N/A\";\n    }\n\n    if (b) {\n      return \"ja\";\n    }\n\n    return \"nee\";\n  }\n  displayNumberOrNA(number: Number | undefined): string {\n    if (number === undefined) {\n      return \"N/A\";\n    }\n\n    return number.toString();\n  }\n  displayStringOrNA(s: string | undefined | null): string {\n    if (s === undefined || s === null) {\n      return \"N/A\";\n    }\n\n    return s;\n  }\n\n  amountType(transaction: Transaction): AmountType {\n    if (transaction.amount === undefined || transaction.amount === null) {\n      return AmountType.BOTH;\n    }\n    return inferAmountType(transaction.amount)\n\n\n  }\n  displayDateOrNA(s: Date | undefined | null): string | null {\n    if (s === undefined || s === null) {\n      return \"N/A\";\n    }\n    return this.datepipe.transform(s, 'dd-MM-yyyy')\n\n  }\n\n  openDialog(): void {\n\n\n    const dialogRef = this.dialog.open(TransactionSearchDialogComponent, {\n      restoreFocus: false\n    });\n\n    dialogRef.afterClosed().subscribe(result => {\n      // console.log('The dialog was closed');\n      if (result === undefined) {\n        return;\n      } else {\n        this.transactionQuery = result;\n        if (this.transactionQuery != undefined){\n          this.transactionQuery.accountNumber = this.selectedAccount;\n\n        }\n\n      }\n      if (this.transactionQuery !== undefined) {\n        this.transactionQueryAsJson = JSON.stringify(this.transactionQuery)\n      }\n      this.doQuery(this.transactionQuery)\n    });\n\n  }\n\n  handleAccountChange(){\n    this.selectedAccount = this.accountSelectionComponent.selectedBankAccount.accountNumber\n    if (this.selectedAccount === undefined || this.selectedAccount === this.appService.DUMMY_BANK_ACCOUNT) {\n      return;\n    }\n    this.transactionQuery  = {\n      transactionType: TransactionTypeEnum.BOTH,\n      counterpartyName: undefined,\n      minAmount: undefined,\n      maxAmount: undefined,\n      accountNumber: this.selectedAccount,\n      categoryId: undefined,\n      counterpartyAccountNumber: undefined,\n      startDate: undefined,\n      endDate: undefined,\n      transactionOrCommunication: undefined,\n      uploadTimestamp: undefined\n\n    }\n    this.doQuery(this.transactionQuery)\n\n  }\n  showAllTransactions() {\n    this.dataSource = this.initDataSource(this.selectedAccount);\n    this.transactionQuery = undefined;\n    this.viewType = ViewType.SHOW_ALL;\n\n  }\n  ngAfterViewInit(): void {\n\n  }\n\n\n  ngOnInit() {\n\n  }\n\n\n\n\n  private initDataSource(account:string | undefined): PaginationDataSource<Transaction, TransactionQuery> {\n    let query = {} as TransactionQuery;\n    if(account !== undefined){\n      query.accountNumber = account;\n\n    }\n    return new PaginationDataSource<Transaction, TransactionQuery>(\n      (request, query) => {\n        request.size = 50;\n        return this.appService.pageTransactions(request, query);\n      },\n      {property: 'bookingDate', order: 'desc'}, query\n    );\n  }\n\n\n  saveTransaction(transaction: Transaction) {\n    this.appService.saveTransaction(transaction)\n  }\n\n  setIsRecurring(transaction: Transaction, event: MatRadioChange) {\n    let value: boolean = event.value;\n    transaction.isRecurring = value;\n    this.saveTransaction(transaction);\n  }\n\n\n  setIsAdvanceSharedAccount(transaction: Transaction, event: MatRadioChange) {\n    let value: boolean = event.value;\n    transaction.isAdvanceSharedAccount = value;\n    this.saveTransaction(transaction);\n  }\n\n\n  setCategory(transaction: Transaction, selectedCategoryQualifiedNameStr: string) {\n    let category = this.categoryMap?.getSimpleCategory(selectedCategoryQualifiedNameStr);\n    if (!category) {\n      throw new Error(\"No category found for \" + selectedCategoryQualifiedNameStr);\n    }\n    transaction.category = category;\n    this.saveTransaction(transaction);\n  }\n\n  sortBy(event: any) {\n    let key = event.active;\n    let direction = event.direction;\n    this.currentSort = {\n      property: key,\n      order: direction || \"ASC\"\n\n    };\n    this.dataSource.sortBy(this.currentSort);\n  }\n\n  doQuery(transactionQuery: TransactionQuery | undefined): void {\n    if (transactionQuery === undefined) {\n      return;\n    }\n\n    let newSort;\n    if (this.currentSort !== undefined) {\n      newSort = this.currentSort;\n    } else {\n\n      newSort = { property: 'bookingDate', order: 'desc' }\n      this.currentSort = newSort;\n    }\n\n    this.dataSource = new PaginationDataSource<Transaction, TransactionQuery>(\n      (request, query) => {\n        request.size = 50;\n        return this.appService.pageTransactions(request, query);\n      },\n      newSort, transactionQuery\n    );\n\n    this.viewType = ViewType.RUN_QUERY;\n  }\n\n\n  protected readonly ViewType = ViewType;\n  protected readonly faTag = faTag;\n\n  getNrOfTransactionsToManuallyReview(): string {\n    if (this.transactionToManuallyReview){\n\n      return  this.transactionToManuallyReview.toString();\n    }\n\n    return \"\";\n\n\n  }\n\n  getNrOfTransactionsToManuallyReviewTooltip() : string {\n    if (this.transactionToManuallyReview){\n\n      return `You have ${this.transactionToManuallyReview} transactions to manually review`;\n    }\n\n    return \"\";\n  }\n}\n\n\n\n\n\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": "section {\r\n  display: flex;\r\n  align-items: flex-start;\r\n}\r\n\r\n\r\n.spinner-container {\r\n  background-color: #ffffff; /* Change this to your desired color */\r\n  padding: 20px;\r\n  border-radius: 10px;\r\n  display: flex; /* Add this line */\r\n  justify-content: center; /* Add this line */\r\n  align-items: center; /* Add this line */\r\n  flex-direction: column;\r\n}\r\n.overlay {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: rgba(0, 0, 0, 0.3);\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  z-index: 9999;\r\n}\r\n\r\n\r\nbutton {\r\n\r\n  padding: 1.40em 0;\r\n  line-height: 1;\r\n\r\n}\r\n\r\n.example-element-detail {\r\n  overflow: hidden;\r\n  display: flex;\r\n}\r\n\r\n.stacked-items {\r\n  min-width: 250px;\r\n  // border: 2px solid black;\r\n  padding: 2px;\r\n  // font-weight: lighter;\r\n  margin: 2px 0;\r\n  //height: 204px;\r\n}\r\n\r\n.default-items {\r\n  padding: 8px;\r\n  // font-weight: lighter;\r\n  margin: 8px 0;\r\n  //height: 204px;\r\n  max-width: 100%;\r\n  white-space: nowrap;\r\n}\r\n.flex-container {\r\n  display: flex;\r\n}\r\n\r\n.flex-child{\r\n  flex: 1;\r\n}\r\n\r\n.flex-child:first-child {\r\n  margin-right: 2px;\r\n}\r\n",
                    "styleUrl": "./transactions.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "datepipe",
                        "type": "DatePipe",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "router",
                        "type": "Router",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 78,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "authService",
                        "type": "AuthService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "dialog",
                        "type": "MatDialog",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "datepipe",
                        "type": "DatePipe",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "errorDialogService",
                        "type": "ErrorDialogService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "router",
                        "type": "Router",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "AfterViewInit"
            ],
            "templateData": "<mat-toolbar color=\"primary\" class=\"toolbar-header\">\n  <span>Transactions</span>\n</mat-toolbar>\n<div>\n  <div *ngIf=\"filesAreUploading\" class=\"overlay\">\n    <div class=\"spinner-container\">\n      <h3>Bestanden worden geüpload</h3>\n      <mat-spinner></mat-spinner>\n    </div>\n  </div>\n  <div class=\"mat-z8 wrapper\" >\n    <div style=\"padding-left: 16px;position: sticky; top:0px; background: rgba(255, 255, 255, 1); padding-top: 10px\"\n         class=\"flex-container\">\n      <bank-account-selection class=\"flex-child\" (change)=\"handleAccountChange()\" style=\"; display: flex; align-items: flex-start; justify-content: flex-start\"></bank-account-selection>\n      <span style=\"padding-right: 5px\"></span>\n      <button\n        style=\"max-width: 50px; max-height: 50px; padding-right: 5px; display: flex; align-items: center; justify-content: center;\"\n        class=\"button flex-child\" mat-raised-button\n        (click)=\"onClickFileInputButton()\"\n      >\n        <input type=\"file\" style=\"display: none\" #fileInput accept=\".csv\" multiple (change)=\"onChangeFileInput()\"/>\n        <mat-icon matTooltip=\"Transacties toevoegen (csv)\" matTooltipPosition=\"below\">\n          add_to_photos\n        </mat-icon>\n      </button>\n      <span style=\"padding-right: 5px\"></span>\n      <button\n        style=\"max-width: 50px; max-height: 50px; padding-right: 5px; display: flex; align-items: center; justify-content: center;\"\n        class=\"button flex-child\" mat-raised-button\n        (click)=\"openDialog()\">\n        <mat-icon matTooltip=\"Zoekopdracht\">search</mat-icon>\n      </button>\n      <span style=\"padding-right: 5px\"></span>\n      <button\n        style=\"max-width: 50px; max-height: 50px; padding-right: 5px; display: flex; align-items: center; justify-content: center;\"\n        class=\"button flex-child\" mat-raised-button\n        (click)=\"showAllTransactions()\">\n        <mat-icon matTooltip=\"Toon alle transacties\">remove_red_eye</mat-icon>\n      </button>\n      <span style=\"padding-right: 5px\"></span>\n      <button [matBadge]=\"getNrOfTransactionsToManuallyReview()\" matBadgeOverlap=\"true\" matBadgeColor=\"warn\" [matTooltip]=\"getNrOfTransactionsToManuallyReviewTooltip()\"\n        style=\"max-width: 50px; max-height: 50px; padding-right: 5px; display: flex; align-items: center; justify-content: center;\"\n        class=\"button flex-child\" mat-raised-button\n        (click)=\"showTransactionsToManuallyReview()\">\n          <fa-icon size=\"lg\" [icon]=\"faTag\" [fixedWidth]=\"true\"></fa-icon>\n      </button>\n\n\n\n\n      <div class=\"flex-child\" *ngIf=\"viewType == ViewType.RUN_QUERY;else showAll\"\n           style=\"margin-left: 32px;font-size: larger;padding-top: 10px;\">\n        <span class=\"flex-child\" style=\"margin-left: 16px;font-style: italic;padding-top: 10px;\">Zoekresultaten worden getoond</span>\n      </div>\n      <ng-template #showAll>\n        <ng-template [ngIf]=\"viewType == ViewType.SHOW_ALL\" [ngIfElse]=\"third\">\n          <span class=\"flex-child\" style=\"margin-left: 16px;font-size: larger; font-style: italic;padding-top: 10px;\">Alle records worden getoond</span>\n        </ng-template>\n      </ng-template>\n      <ng-template #third>\n        <ng-template [ngIf]=\"viewType == ViewType.UPLOAD_TRANSACTIONS\">\n        <span class=\"flex-child\"\n              style=\"margin-left: 16px;font-size: larger; font-style: italic;padding-top: 10px;\">Records van geüploade bestanden</span>\n        </ng-template>\n      </ng-template>\n\n      <div class=\"flex-child\">\n        <mat-paginator *ngIf=\"dataSource.page$ | async as page\" [length]=\"page.totalElements\" [pageSize]=\"page.size\"\n                       [pageIndex]=\"page.number\" (page)=\"dataSource.fetch($event.pageIndex)\">\n        </mat-paginator>\n      </div>\n    </div>\n    <div style=\"background-color:white; overflow-y: scroll; height: 80vh\">\n      <table mat-table [dataSource]=\"dataSource\" matSort (matSortChange)=\"sortBy($event)\" class=\"mat-z8\"\n             style=\"border-collapse: separate; width: 100%\"\n              matSortDisableClear matSortActive=\"bookingDate\" matSortDirection=\"asc\">\n        <ng-container matColumnDef=\"bookingDate\">\n          <th mat-header-cell *matHeaderCellDef mat-sort-header style=\"font-size: large; width: 15%\">Date</th>\n          <td mat-cell  *matCellDef=\"let item\">\n            <div class=\"default-items\">\n              {{ item.bookingDate | date }}\n            </div>\n          </td>\n        </ng-container>\n        <ng-container matColumnDef=\"counterparty\">\n          <th mat-header-cell *matHeaderCellDef mat-sort-header style=\"font-size: large; width: 15%\">Counterparty</th>\n          <td mat-cell  *matCellDef=\"let item\">\n            <div class=\"stacked-items\" style=\" inline-size: 200px;\">\n              <div>{{ item.counterparty.name | titlecase }}</div>\n              <div\n                style=\"font-style: italic; font-weight: lighter;padding-block: 2px;\">{{ item.counterparty.accountNumber }}\n              </div>\n              <div\n                style=\"font-style: italic; font-weight: lighter;padding-block: 2px;\">{{ item.counterparty.streetAndNumber }} {{\n                  item.counterparty.zipCodeAndCity\n                }}\n              </div>\n            </div>\n          </td>\n        </ng-container>\n        <ng-container matColumnDef=\"transaction\">\n          <th mat-header-cell *matHeaderCellDef mat-sort-header style=\"font-size: large;width: 20%\">Transaction</th>\n          <td mat-cell *matCellDef=\"let item\">\n            <div class=\"stacked-items\"\n                 style=\"font-weight: lighter;padding-block: 2px; inline-size: 300px;  overflow-wrap: break-word;\">\n              <div>{{ item.transaction }}</div>\n              <div *ngIf=\"item.transaction !== item.communications\"\n                   style=\"padding-block: 2px\">{{ item.communications }}\n              </div>\n            </div>\n          </td>\n        </ng-container>\n        <ng-container matColumnDef=\"amount\">\n          <th mat-header-cell *matHeaderCellDef mat-sort-header style=\"font-size: large; width: 10%\">Amount</th>\n          <td mat-cell *matCellDef=\"let item\">\n            <div class=\"stacked-items\" style=\"min-width: 100px;\">\n              <div>{{ item.amount }} {{ item.currency }}</div>\n            </div>\n          </td>\n        </ng-container>\n        <ng-container matColumnDef=\"transactionType\">\n          <th mat-header-cell *matHeaderCellDef style=\"font-size: large; width: 40%\">Transaction Type</th>\n          <td mat-cell  *matCellDef=\"let item\">\n            <table style=\"width: 100%\">\n              <tr >\n                <td >\n                  <div style=\"font-weight: lighter;font-style: italic;\">categorie\n                  </div>\n                </td>\n                <td >\n                  <div>\n                    <app-category-tree-dropdown\n                      (selectionChange)=\"setCategory(item, $event)\"\n                      [selectedCategoryQualifiedNameStr]=\"item.category\"\n                      [transactionTypeEnum]=\"amountType(item)\"\n                    >\n                    </app-category-tree-dropdown>\n                  </div>\n                </td>\n              </tr>\n              <tr >\n                <td >\n                  <div style=\"font-weight: lighter;font-style: italic;\">recurrent\n                  </div>\n                </td>\n                <td >\n                  <mat-radio-group name=\"recurrent_options\" (change)=\"setIsRecurring(item, $event)\">\n                    <mat-radio-button style=\"margin-right: 5px;\" [value]=\"true\"\n                                      [checked]=\"item.isRecurring == true\">ja\n                    </mat-radio-button>\n                    <mat-radio-button style=\"padding-right: 5px;\" [value]=\"false\"\n                                      [checked]=\"item.isRecurring == false\">nee\n                    </mat-radio-button>\n                  </mat-radio-group>\n                </td>\n              </tr>\n              <tr >\n                <td >\n                  <div style=\"font-weight: lighter; font-style: italic;\">needs<br>reimbursement\n                  </div>\n                </td>\n                <td >\n                  <mat-radio-group name=\"voorschot_options\" (change)=\"setIsAdvanceSharedAccount(item, $event)\">\n                    <mat-radio-button style=\"margin-right: 5px;\" [value]=\"true\"\n                                      [checked]=\"item.isAdvanceSharedAccount == true\">ja\n                    </mat-radio-button>\n                    <mat-radio-button style=\"margin-right: 5px;\" [value]=\"false\"\n                                      [checked]=\"item.isAdvanceSharedAccount == false\">nee\n                    </mat-radio-button>\n                  </mat-radio-group>\n                </td>\n              </tr>\n\n            </table>\n          </td>\n        </ng-container>\n\n        <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n        <tr VALIGN=TOP mat-row *matRowDef=\"let row; columns: displayedColumns\"></tr>\n      </table>\n\n      <mat-paginator *ngIf=\"dataSource.page$ | async as page\" [length]=\"page.totalElements\" [pageSize]=\"page.size\"\n                     [pageIndex]=\"page.number\" (page)=\"dataSource.fetch($event.pageIndex)\">\n      </mat-paginator>\n    </div>\n  </div>\n</div>\n"
        },
        {
            "name": "TransactionSearchDialogComponent",
            "id": "component-TransactionSearchDialogComponent-df89efc129cab92b0b5b9758a5c846a50bb3f787a4b0fcc37c052331e29b37ed9e14f1a9c5257614f7a42c3d0802af97a84a69de19548deadbbd16a7442dd619",
            "file": "src/app/transaction-search-dialog/transaction-search-dialog.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-transaction-search-dialog",
            "styleUrls": [
                "./transaction-search-dialog.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./transaction-search-dialog.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "AmountType",
                    "defaultValue": "AmountType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 246,
                    "modifierKind": [
                        124,
                        148
                    ]
                },
                {
                    "name": "categorySelection",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryTreeDropdownComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "CategoryTreeDropdownComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "currentQuery",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionQuery",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 59
                },
                {
                    "name": "data",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionQuery",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 33,
                    "decorators": [
                        {
                            "name": "Inject",
                            "stringifiedArguments": "MAT_DIALOG_DATA"
                        }
                    ],
                    "modifierKind": [
                        170,
                        125
                    ]
                },
                {
                    "name": "dialogRef",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatDialogRef<TransactionSearchDialogComponent>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 32,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "periodSelection",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "PeriodSelectionComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "PeriodSelectionComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "tegenpartijRekeningSelection",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CounterpartyAccountNumberSelectionComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "CounterpartyAccountNumberSelectionComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "tegenpartijSelection",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CounterpartyNameSelectionComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "CounterpartyNameSelectionComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "transactionMededelingenSearch",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionCommunicationsSearchComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 29,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "TransactionCommunicationsSearchComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "transactiontypeSelectionComponent",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactiontypeSelectionComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "TransactiontypeSelectionComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "handleCategorySelectionChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 134,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handlePeriodSelectionChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 105,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleRekeningTegenpartijSelectionChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 187,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleTegenpartijSelectionChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 161,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleTransactionMededelingenSearchChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 213,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "handleTransactionTypeSelectionChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 62,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 38,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 49,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onCancelClick",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 239,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onSearchClick",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 242,
                    "deprecated": false,
                    "deprecationMessage": ""
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatDialogTitle"
                },
                {
                    "name": "CdkScrollable"
                },
                {
                    "name": "MatDialogContent"
                },
                {
                    "name": "TransactiontypeSelectionComponent",
                    "type": "component"
                },
                {
                    "name": "PeriodSelectionComponent",
                    "type": "component"
                },
                {
                    "name": "CategoryTreeDropdownComponent",
                    "type": "component"
                },
                {
                    "name": "CounterpartyNameSelectionComponent_1",
                    "type": "component"
                },
                {
                    "name": "CounterpartyAccountNumberSelectionComponent_1",
                    "type": "component"
                },
                {
                    "name": "TransactionCommunicationsSearchComponent",
                    "type": "component"
                },
                {
                    "name": "MatDialogActions"
                },
                {
                    "name": "MatButton"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { AfterViewInit, Component, Inject, OnInit, ViewChild } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA, MatDialogTitle, MatDialogContent, MatDialogActions } from '@angular/material/dialog';\nimport {CategoryTreeDropdownComponent} from '../category-tree-dropdown/category-tree-dropdown.component';\nimport {AmountType, TransactionQuery, TransactionType} from '../model';\nimport { PeriodSelectionComponent } from '../period-selection/period-selection.component';\nimport { CounterpartyAccountNumberSelectionComponent } from '.././counterparty-account-number-selection/counterparty-account-number-selection.component';\nimport { CounterpartyNameSelectionComponent } from '.././counterparty-name-selection/counterparty-name-selection.component';\nimport { TransactionCommunicationsSearchComponent } from '../transaction-mededelingen-search/transaction-communications-search.component';\nimport { TransactiontypeSelectionComponent } from '../transactiontype-selection/transactiontype-selection.component';\nimport { CdkScrollable } from '@angular/cdk/scrolling';\nimport { CounterpartyNameSelectionComponent as CounterpartyNameSelectionComponent_1 } from '../counterparty-name-selection/counterparty-name-selection.component';\nimport { CounterpartyAccountNumberSelectionComponent as CounterpartyAccountNumberSelectionComponent_1 } from '../counterparty-account-number-selection/counterparty-account-number-selection.component';\nimport { MatButton } from '@angular/material/button';\n\n@Component({\n    selector: 'app-transaction-search-dialog',\n    templateUrl: './transaction-search-dialog.component.html',\n    styleUrls: ['./transaction-search-dialog.component.scss'],\n    standalone: true,\n    imports: [MatDialogTitle, CdkScrollable, MatDialogContent, TransactiontypeSelectionComponent, PeriodSelectionComponent, CategoryTreeDropdownComponent, CounterpartyNameSelectionComponent_1, CounterpartyAccountNumberSelectionComponent_1, TransactionCommunicationsSearchComponent, MatDialogActions, MatButton]\n})\nexport class TransactionSearchDialogComponent implements OnInit, AfterViewInit {\n\n  @ViewChild(TransactiontypeSelectionComponent) transactiontypeSelectionComponent!: TransactiontypeSelectionComponent;\n  @ViewChild(PeriodSelectionComponent) periodSelection!: PeriodSelectionComponent;\n  @ViewChild(CategoryTreeDropdownComponent) categorySelection!: CategoryTreeDropdownComponent;\n  @ViewChild(CounterpartyNameSelectionComponent) tegenpartijSelection!: CounterpartyNameSelectionComponent;\n  @ViewChild(CounterpartyAccountNumberSelectionComponent) tegenpartijRekeningSelection!: CounterpartyAccountNumberSelectionComponent;\n  @ViewChild(TransactionCommunicationsSearchComponent) transactionMededelingenSearch!: TransactionCommunicationsSearchComponent;\n\n  constructor(\n    public dialogRef: MatDialogRef<TransactionSearchDialogComponent>,\n    @Inject(MAT_DIALOG_DATA) public data: TransactionQuery,\n  ) {\n\n\n  }\n  ngAfterViewInit(): void {\n    /**\n     * logic to make dialog scroll to top\n     */\n    let element : Element |null = document.querySelector(\"#first\");\n    if(element !== null){\n      element.scrollIntoView(true);\n    }\n  }\n\n\n  ngOnInit() {\n\n\n  }\n\n\n\n\n\n\n  currentQuery?: TransactionQuery;\n\n\n  handleTransactionTypeSelectionChange() {\n    let vType: TransactionType = this.transactiontypeSelectionComponent.selectedTransactionType;\n    let vInkomsten: boolean = false;\n    let vUitgaven: boolean = false;\n    switch (vType) {\n      case TransactionType.BOTH:\n        vInkomsten = true;\n        vUitgaven = false;\n        break;\n      case TransactionType.REVENUE:\n        vInkomsten = true;\n        break;\n      case TransactionType.EXPENSES:\n        vUitgaven = true;\n        break;\n\n    }\n    if (this.currentQuery === undefined) {\n      this.currentQuery = {\n        revenue: vInkomsten,\n        expenses: vUitgaven,\n        counterpartyName: undefined,\n        minAmount: undefined,\n        maxAmount: undefined,\n        accountNumber: undefined,\n        category: undefined,\n        freeText: undefined,\n        counterpartyAccountNumber: undefined,\n        startDate: undefined,\n        endDate: undefined,\n        transactionOrCommunication : undefined,\n        uploadTimestamp: undefined\n\n\n      }\n    } else {\n      this.currentQuery.revenue = vInkomsten;\n      this.currentQuery.expenses = vUitgaven;\n\n    }\n\n  }\n\n  handlePeriodSelectionChange(){\n    let vStartDate: Date | null =this.periodSelection.range.controls.start.value;\n    let vEndDate : Date | null = this.periodSelection.range.controls.end.value;\n\n\n    if (this.currentQuery === undefined) {\n      this.currentQuery = {\n        revenue: undefined,\n        expenses: undefined,\n        counterpartyName: undefined,\n        minAmount: undefined,\n        maxAmount: undefined,\n        accountNumber: undefined,\n        category: undefined,\n        freeText: undefined,\n        counterpartyAccountNumber: undefined,\n        startDate: vStartDate,\n        endDate: vEndDate,\n        transactionOrCommunication : undefined,\n        uploadTimestamp: undefined\n\n      }\n    } else {\n      this.currentQuery.startDate = vStartDate;\n      this.currentQuery.endDate = vEndDate;\n\n    }\n\n  }\n  handleCategorySelectionChange(){\n    let vCategory: string | undefined  = this.categorySelection.selectedCategoryQualifiedNameStr;\n\n\n\n    if (this.currentQuery === undefined) {\n      this.currentQuery = {\n        revenue: undefined,\n        expenses: undefined,\n        counterpartyName: undefined,\n        minAmount: undefined,\n        maxAmount: undefined,\n        accountNumber: undefined,\n        category: vCategory,\n        freeText: undefined,\n        counterpartyAccountNumber: undefined,\n        startDate: undefined,\n        endDate: undefined,\n        transactionOrCommunication : undefined,\n        uploadTimestamp: undefined\n\n      }\n    } else {\n      this.currentQuery.category = vCategory\n    }\n\n  }\n  handleTegenpartijSelectionChange(){\n    let vTegenpartij: string | undefined  = this.tegenpartijSelection.selectedCounterpartyName;\n\n    if (this.currentQuery === undefined) {\n      this.currentQuery = {\n        revenue: undefined,\n        expenses: undefined,\n        counterpartyName: vTegenpartij,\n        minAmount: undefined,\n        maxAmount: undefined,\n        accountNumber: undefined,\n        category: undefined,\n        freeText: undefined,\n        counterpartyAccountNumber: undefined,\n        startDate: undefined,\n        endDate: undefined,\n        transactionOrCommunication : undefined,\n        uploadTimestamp: undefined\n\n      }\n    } else {\n      this.currentQuery.counterpartyName = vTegenpartij;\n    }\n\n  }\n\n  handleRekeningTegenpartijSelectionChange(){\n    let vRekeningTegenpartij: string | undefined  = this.tegenpartijRekeningSelection.selectedCounterpartAccountNumber;\n\n    if (this.currentQuery === undefined) {\n      this.currentQuery = {\n        revenue: undefined,\n        expenses: undefined,\n        counterpartyName: undefined,\n        minAmount: undefined,\n        maxAmount: undefined,\n        accountNumber: undefined,\n        category: undefined,\n        freeText: undefined,\n        counterpartyAccountNumber: vRekeningTegenpartij,\n        startDate: undefined,\n        endDate: undefined,\n        transactionOrCommunication : undefined,\n        uploadTimestamp: undefined\n\n      }\n    } else {\n      this.currentQuery.counterpartyAccountNumber = vRekeningTegenpartij;\n    }\n\n  }\n\n  handleTransactionMededelingenSearchChange(){\n    let vSearchText: string | undefined  = this.transactionMededelingenSearch.searchText;\n\n    if (this.currentQuery === undefined) {\n      this.currentQuery = {\n        revenue: undefined,\n        expenses: undefined,\n        counterpartyName: undefined,\n        minAmount: undefined,\n        maxAmount: undefined,\n        accountNumber: undefined,\n        category: undefined,\n        freeText: undefined,\n        counterpartyAccountNumber: undefined,\n        startDate: undefined,\n        endDate: undefined,\n        transactionOrCommunication : vSearchText,\n        uploadTimestamp: undefined\n\n      }\n    } else {\n      this.currentQuery.transactionOrCommunication = vSearchText;\n    }\n\n  }\n\n  onCancelClick(): void {\n    this.dialogRef.close();\n  }\n  onSearchClick(): void {\n    this.dialogRef.close(this.currentQuery);\n  }\n\n    protected readonly AmountType = AmountType;\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".stacked-items {\r\n    min-width: 250px;\r\n    // border: 2px solid black;\r\n    padding: 8px;\r\n    // font-weight: lighter;\r\n    margin: 8px 0;\r\n    height: 204px;\r\n    \r\n  }\r\n.top-border{\r\n    border-top: 1px gray solid\r\n}\r\n.bottom-border{\r\n    border-bottom: 1px gray solid\r\n}\r\n ",
                    "styleUrl": "./transaction-search-dialog.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "dialogRef",
                        "type": "MatDialogRef<TransactionSearchDialogComponent>",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "data",
                        "type": "TransactionQuery",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 29,
                "jsdoctags": [
                    {
                        "name": "dialogRef",
                        "type": "MatDialogRef<TransactionSearchDialogComponent>",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "data",
                        "type": "TransactionQuery",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "AfterViewInit"
            ],
            "templateData": "<h1 mat-dialog-title style=\"text-align: center;\">Zoek transacties</h1>\n<div style=\"width: 100%;\">\n  <div mat-dialog-content style=\"width: 100%;\" >\n    <div style=\"padding-top: 5px;\" class=\"top-border bottom-border\">\n      <div id=\"first\" style=\"padding-top: 5px;font-weight: bold; color: rgb(59, 58, 58); font-size: larger;\">\n        Transactie type\n      </div>\n      <app-transactiontype-selection style=\"min-width: 350px;\"\n        (transactionTypeChange)=\"handleTransactionTypeSelectionChange()\"></app-transactiontype-selection>\n\n    </div>\n    <div style=\"padding-top: 5px;\" class=\"top-border bottom-border\">\n      <div style=\"padding-top: 5px;font-weight: bold; color: rgb(59, 58, 58); font-size: larger;\">\n        Periode\n      </div>\n      <period-selection style=\" font-size: larger;\"\n        (change)=\"handlePeriodSelectionChange()\"></period-selection>\n    </div>\n\n    <div style=\"padding-top: 5px;\" class=\"top-border bottom-border\">\n      <div style=\"padding-top: 5px;font-weight: bold; color: rgb(59, 58, 58); font-size: larger;\">\n        Categorie\n      </div>\n      <app-category-tree-dropdown style=\" font-size: larger;\" (selectionChange)=\"handleCategorySelectionChange()\"\n                                  [selectedCategoryQualifiedNameStr]=\"'DUMMY CATEGORIE'\"\n                                  [transactionTypeEnum]=\"AmountType.BOTH\"\n      ></app-category-tree-dropdown>\n\n\n    </div>\n\n    <div style=\"padding-top: 5px;\" class=\"top-border bottom-border\">\n      <div style=\"padding-top: 5px;font-weight: bold; color: rgb(59, 58, 58); font-size: larger;\">\n        Tegenpartij\n      </div>\n      <app-counterparty-name-selection\n        (change)=\"handleTegenpartijSelectionChange()\"></app-counterparty-name-selection>\n      <app-counterparty-account-number-selection\n        (change)=\"handleRekeningTegenpartijSelectionChange()\"></app-counterparty-account-number-selection>\n    </div>\n\n    <div style=\"padding-top: 5px;\" class=\"top-border bottom-border\">\n      <div style=\"padding-top: 5px;font-weight: bold; color: rgb(59, 58, 58); font-size: larger;\">\n        Transactie\n      </div>\n      <app-transaction-communications-search\n        (change)=\"handleTransactionMededelingenSearchChange()\"></app-transaction-communications-search>\n\n    </div>\n  </div>\n  <div mat-dialog-actions>\n    <button mat-button (click)=\"onCancelClick()\">Annuleer</button>\n    <button mat-button (click)=\"onSearchClick()\" cdkFocusInitial>Zoek</button>\n  </div>\n</div>\n"
        },
        {
            "name": "TransactionsInContextDialogComponent",
            "id": "component-TransactionsInContextDialogComponent-7ce946bc0ddcba0a714cf2f18d2d081d85d0810944c26c83f67f9ff41a58505525473fdecb004a3db328c32f760a9fd69f3c716fb92994647802ccf69099ead7",
            "file": "src/app/transaction-dialog/transactions-in-context-dialog.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "transactions-in-context-dialog",
            "styleUrls": [
                "./transactions-in-context-dialog.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./transactions-in-context-dialog.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [],
            "propertiesClass": [
                {
                    "name": "categoryMap",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryMap",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 48,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "currentSort",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "indexKey": "",
                    "optional": true,
                    "description": "",
                    "line": 47,
                    "modifierKind": [
                        123
                    ]
                },
                {
                    "name": "dataSource",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "PaginationDataSource<Transaction | TransactionInContextQuery>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 39
                },
                {
                    "name": "dialogRef",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "MatDialogRef<TransactionsInContextDialogComponent>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 50,
                    "modifierKind": [
                        125
                    ]
                },
                {
                    "name": "displayedColumns",
                    "defaultValue": "[\n        \"bookingDate\",\n        \"counterparty\",\n        \"transaction\",\n        \"amount\",\n        \"transactionType\"\n    ]",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 40
                },
                {
                    "name": "query",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionInContextQuery",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 51,
                    "decorators": [
                        {
                            "name": "Inject",
                            "stringifiedArguments": "MAT_DIALOG_DATA"
                        }
                    ],
                    "modifierKind": [
                        170,
                        125
                    ]
                }
            ],
            "methodsClass": [
                {
                    "name": "amountType",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "AmountType",
                    "typeParameters": [],
                    "line": 111,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "doQuery",
                    "args": [
                        {
                            "name": "transactionQuery",
                            "type": "TransactionInContextQuery | undefined",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 72,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transactionQuery",
                            "type": "TransactionInContextQuery | undefined",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ngAfterViewInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 123,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 57,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onCloseClick",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 119,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "saveTransaction",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 107,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "setCategory",
                    "args": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "selectedCategoryQualifiedNameStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 98,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "transaction",
                            "type": "Transaction",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "selectedCategoryQualifiedNameStr",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "sortBy",
                    "args": [
                        {
                            "name": "event",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 61,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "jsdoctags": [
                        {
                            "name": "event",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatDialogTitle"
                },
                {
                    "name": "MatDialogContent"
                },
                {
                    "name": "MatTable"
                },
                {
                    "name": "MatSort"
                },
                {
                    "name": "MatColumnDef"
                },
                {
                    "name": "MatHeaderCellDef"
                },
                {
                    "name": "MatHeaderCell"
                },
                {
                    "name": "MatSortHeader"
                },
                {
                    "name": "MatCellDef"
                },
                {
                    "name": "MatCell"
                },
                {
                    "name": "NgIf"
                },
                {
                    "name": "CategoryTreeDropdownComponent",
                    "type": "component"
                },
                {
                    "name": "MatHeaderRowDef"
                },
                {
                    "name": "MatHeaderRow"
                },
                {
                    "name": "MatRowDef"
                },
                {
                    "name": "MatRow"
                },
                {
                    "name": "MatPaginator"
                },
                {
                    "name": "MatDialogActions"
                },
                {
                    "name": "MatButton"
                },
                {
                    "name": "AsyncPipe",
                    "type": "pipe"
                },
                {
                    "name": "TitleCasePipe",
                    "type": "pipe"
                },
                {
                    "name": "DatePipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import {AfterViewInit, Component, Inject, OnInit} from '@angular/core';\nimport {PaginationDataSource} from \"@daanvdn/ngx-pagination-data-source\";\nimport {AppService} from \"../app.service\";\nimport {\n    MAT_DIALOG_DATA,\n    MatDialogActions,\n    MatDialogContent,\n    MatDialogRef,\n    MatDialogTitle\n} from \"@angular/material/dialog\";\nimport {Transaction, TransactionInContextQuery} from \"@daanvdn/budget-assistant-client\";\nimport {AmountType, CategoryMap, inferAmountType} from \"../model\";\nimport {\n    MatCell,\n    MatCellDef,\n    MatColumnDef,\n    MatHeaderCell,\n    MatHeaderCellDef,\n    MatHeaderRow,\n    MatHeaderRowDef,\n    MatRow,\n    MatRowDef,\n    MatTable\n} from '@angular/material/table';\nimport {MatSort, MatSortHeader} from '@angular/material/sort';\nimport {AsyncPipe, DatePipe, NgIf, TitleCasePipe} from '@angular/common';\nimport {CategoryTreeDropdownComponent} from '../category-tree-dropdown/category-tree-dropdown.component';\nimport {MatPaginator} from '@angular/material/paginator';\nimport {MatButton} from '@angular/material/button';\n\n@Component({\n    selector: 'transactions-in-context-dialog',\n    templateUrl: './transactions-in-context-dialog.component.html',\n    styleUrls: ['./transactions-in-context-dialog.component.scss'],\n    standalone: true,\n    imports: [MatDialogTitle, MatDialogContent, MatTable, MatSort, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatSortHeader, MatCellDef, MatCell, NgIf, CategoryTreeDropdownComponent, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatPaginator, MatDialogActions, MatButton, AsyncPipe, TitleCasePipe, DatePipe]\n})\nexport class TransactionsInContextDialogComponent implements OnInit, AfterViewInit {\n    dataSource!: PaginationDataSource<Transaction, TransactionInContextQuery>;\n    displayedColumns = [\n        \"bookingDate\",\n        \"counterparty\",\n        \"transaction\",\n        \"amount\",\n        \"transactionType\"\n    ];\n    private currentSort?: any;\n    private categoryMap?: CategoryMap;\n\n    constructor(private appService: AppService, public dialogRef: MatDialogRef<TransactionsInContextDialogComponent>,\n                @Inject(MAT_DIALOG_DATA) public query: TransactionInContextQuery) {\n        this.appService.categoryMapObservable$.subscribe(categoryMap => {\n            this.categoryMap = categoryMap;\n        });\n    }\n\n    ngOnInit(): void {\n        this.doQuery(this.query);\n    }\n\n    sortBy(event: any) {\n        let key = event.active;\n        let direction = event.direction;\n        this.currentSort = {\n            property: key,\n            order: direction || \"ASC\"\n\n        };\n        this.dataSource.sortBy(this.currentSort);\n    }\n\n    doQuery(transactionQuery: TransactionInContextQuery | undefined): void {\n        if (transactionQuery === undefined) {\n            return;\n        }\n\n        let newSort;\n        if (this.currentSort !== undefined) {\n            newSort = this.currentSort;\n        }\n        else {\n\n            newSort = {property: 'bookingDate', order: 'desc'}\n            this.currentSort = newSort;\n        }\n\n        this.dataSource = new PaginationDataSource<Transaction, TransactionInContextQuery>(\n            (request, query) => {\n                request.size = 50;\n                return this.appService.pageTransactionsInContext(request, query);\n            },\n            newSort, transactionQuery\n        );\n\n\n    }\n\n    setCategory(transaction: Transaction, selectedCategoryQualifiedNameStr: string) {\n        let simpleCategory = this.categoryMap?.getSimpleCategory(selectedCategoryQualifiedNameStr);\n        if (! simpleCategory){\n            throw new Error(\"No category found for \" + selectedCategoryQualifiedNameStr);\n        }\n        transaction.category = simpleCategory;\n        this.saveTransaction(transaction);\n    }\n\n    saveTransaction(transaction: Transaction) {\n        this.appService.saveTransaction(transaction)\n    }\n\n    amountType(transaction: Transaction): AmountType {\n        if (transaction.amount === undefined || transaction.amount === null) {\n            return AmountType.BOTH;\n        }\n        return inferAmountType(transaction.amount)\n\n\n    }\n    onCloseClick(): void {\n        this.dialogRef.close();\n    }\n\n    ngAfterViewInit(): void {\n        /**\n         * logic to make dialog scroll to top\n         */\n        let element : Element |null = document.querySelector(\"#first\");\n        if(element !== null){\n            element.scrollIntoView(true);\n        }\n    }\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".stacked-items {\r\n  min-width: 250px;\r\n  // border: 2px solid black;\r\n  padding: 8px;\r\n  // font-weight: lighter;\r\n  margin: 8px 0;\r\n  height: 204px;\r\n\r\n}\r\n.top-border{\r\n  border-top: 1px gray solid\r\n}\r\n.bottom-border{\r\n  border-bottom: 1px gray solid\r\n}\r\n",
                    "styleUrl": "./transactions-in-context-dialog.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "dialogRef",
                        "type": "MatDialogRef<TransactionsInContextDialogComponent>",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "query",
                        "type": "TransactionInContextQuery",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 48,
                "jsdoctags": [
                    {
                        "name": "appService",
                        "type": "AppService",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "dialogRef",
                        "type": "MatDialogRef<TransactionsInContextDialogComponent>",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "query",
                        "type": "TransactionInContextQuery",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit",
                "AfterViewInit"
            ],
            "templateData": "<div mat-dialog-title style=\"text-align: center;\">Transactions for category <span style=\"font-style: italic\">{{ query.categoryId }} and period {{query.period}}</span> </div>\n<!--fixme: we need the actual category and not the categoryId-->\n<div mat-dialog-content style=\"background-color:white; overflow-y: scroll; height: 100%; width: 100%; display: flex; flex-direction: column; align-items: center;\">\n    <div>\n        <table mat-table [dataSource]=\"dataSource\" matSort (matSortChange)=\"sortBy($event)\" class=\"mat-z8\"\n               style=\"border-collapse: separate; width: 100%\"\n               matSortDisableClear matSortActive=\"bookingDate\" matSortDirection=\"asc\">\n            <ng-container matColumnDef=\"bookingDate\">\n                <th mat-header-cell *matHeaderCellDef mat-sort-header style=\"font-size: large; width: 15%\">Date</th>\n                <td mat-cell *matCellDef=\"let item\">\n                    <div class=\"default-items\">\n                        {{ item.bookingDate | date }}\n                    </div>\n                </td>\n            </ng-container>\n            <ng-container matColumnDef=\"counterparty\">\n                <th mat-header-cell *matHeaderCellDef mat-sort-header style=\"font-size: large; width: 15%\">\n                    Counterparty\n                </th>\n                <td mat-cell *matCellDef=\"let item\">\n                    <div class=\"stacked-items\" style=\" inline-size: 200px;\">\n                        <div>{{ item.counterparty.name | titlecase }}</div>\n                        <div\n                                style=\"font-style: italic; font-weight: lighter;padding-block: 2px;\">{{ item.counterparty.accountNumber }}\n                        </div>\n                        <div\n                                style=\"font-style: italic; font-weight: lighter;padding-block: 2px;\">{{ item.counterparty.streetAndNumber }} {{\n                                item.counterparty.zipCodeAndCity\n                            }}\n                        </div>\n                    </div>\n                </td>\n            </ng-container>\n            <ng-container matColumnDef=\"transaction\">\n                <th mat-header-cell *matHeaderCellDef mat-sort-header style=\"font-size: large;width: 20%\">Transaction\n                </th>\n                <td mat-cell *matCellDef=\"let item\">\n                    <div class=\"stacked-items\"\n                         style=\"font-weight: lighter;padding-block: 2px; inline-size: 300px;  overflow-wrap: break-word;\">\n                        <div>{{ item.transaction }}</div>\n                        <div *ngIf=\"item.transaction !== item.communications\"\n                             style=\"padding-block: 2px\">{{ item.communications }}\n                        </div>\n                    </div>\n                </td>\n            </ng-container>\n            <ng-container matColumnDef=\"amount\">\n                <th mat-header-cell *matHeaderCellDef mat-sort-header style=\"font-size: large; width: 10%\">Amount</th>\n                <td mat-cell *matCellDef=\"let item\">\n                    <div class=\"stacked-items\" style=\"min-width: 100px;\">\n                        <div>{{ item.amount }} {{ item.currency }}</div>\n                    </div>\n                </td>\n            </ng-container>\n            <ng-container matColumnDef=\"transactionType\">\n                <th mat-header-cell *matHeaderCellDef style=\"font-size: large; width: 40%\">Transaction Type</th>\n                <td mat-cell *matCellDef=\"let item\">\n                    <table style=\"width: 100%\">\n                        <tr>\n                            <td>\n                                <div style=\"font-weight: lighter;font-style: italic;\">Category</div>\n                            </td>\n                            <td>\n                                <div>\n                                    <app-category-tree-dropdown\n                                            (selectionChange)=\"setCategory(item, $event)\"\n                                            [selectedCategoryQualifiedNameStr]=\"item.category\"\n                                            [transactionTypeEnum]=\"amountType(item)\"\n                                    >\n                                    </app-category-tree-dropdown>\n                                </div>\n                            </td>\n                        </tr>\n                    </table>\n                </td>\n            </ng-container>\n\n            <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n            <tr VALIGN=TOP mat-row *matRowDef=\"let row; columns: displayedColumns\"></tr>\n        </table>\n\n        <mat-paginator *ngIf=\"dataSource.page$ | async as page\" [length]=\"page.totalElements\" [pageSize]=\"page.size\"\n                       [pageIndex]=\"page.number\" (page)=\"dataSource.fetch($event.pageIndex)\">\n        </mat-paginator>\n    </div>\n    <div mat-dialog-actions style=\"align-self: center\">\n        <button mat-raised-button (click)=\"onCloseClick()\">Close</button>\n    </div>\n</div>"
        },
        {
            "name": "TransactiontypeSelectionComponent",
            "id": "component-TransactiontypeSelectionComponent-bbeee4ece5080675a22c82b0ebb412ea1fc66fddc639847a13744086202106dd3772196a68a44fcbfff61a5bc59aa0132ca0e92d37461a9533df53468cd48e87",
            "file": "src/app/transactiontype-selection/transactiontype-selection.component.ts",
            "encapsulation": [],
            "entryComponents": [],
            "inputs": [],
            "outputs": [],
            "providers": [],
            "selector": "app-transactiontype-selection",
            "styleUrls": [
                "./transactiontype-selection.component.scss"
            ],
            "styles": [],
            "templateUrl": [
                "./transactiontype-selection.component.html"
            ],
            "viewProviders": [],
            "hostDirectives": [],
            "inputsClass": [],
            "outputsClass": [
                {
                    "name": "transactionTypeChange",
                    "defaultValue": "new EventEmitter<boolean>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "line": 33,
                    "type": "EventEmitter<boolean>"
                }
            ],
            "propertiesClass": [
                {
                    "name": "maxAmount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 27
                },
                {
                    "name": "minAmount",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "number",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 26
                },
                {
                    "name": "ngSelect",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "NgSelectComponent",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 28,
                    "decorators": [
                        {
                            "name": "ViewChild",
                            "stringifiedArguments": "NgSelectComponent"
                        }
                    ],
                    "modifierKind": [
                        170
                    ]
                },
                {
                    "name": "selectedTransactionType",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionType",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 25
                },
                {
                    "name": "transactionTypes",
                    "defaultValue": "new Map<string, TransactionType>()",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string | TransactionType>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 23
                },
                {
                    "name": "transactionTypesObservable",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Observable<string[]>",
                    "indexKey": "",
                    "optional": false,
                    "description": "",
                    "line": 24
                }
            ],
            "methodsClass": [
                {
                    "name": "getSelectedTransactionType",
                    "args": [],
                    "optional": false,
                    "returnType": "TransactionType | null | undefined",
                    "typeParameters": [],
                    "line": 57,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "rawdescription": "\n\nwe cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n",
                    "description": "<p>we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround</p>\n",
                    "modifierKind": [
                        123
                    ],
                    "jsdoctags": [
                        {
                            "tagName": {
                                "pos": 1927,
                                "end": 1934,
                                "kind": 80,
                                "id": 0,
                                "flags": 16842752,
                                "transformFlags": 0,
                                "escapedText": "returns"
                            },
                            "comment": ""
                        }
                    ]
                },
                {
                    "name": "ngOnInit",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 37,
                    "deprecated": false,
                    "deprecationMessage": ""
                },
                {
                    "name": "onSelectionChange",
                    "args": [],
                    "optional": false,
                    "returnType": "void",
                    "typeParameters": [],
                    "line": 44,
                    "deprecated": false,
                    "deprecationMessage": "",
                    "modifierKind": [
                        125
                    ]
                }
            ],
            "deprecated": false,
            "deprecationMessage": "",
            "hostBindings": [],
            "hostListeners": [],
            "standalone": true,
            "imports": [
                {
                    "name": "MatFormField"
                },
                {
                    "name": "MatLabel"
                },
                {
                    "name": "MatInput"
                },
                {
                    "name": "FormsModule",
                    "type": "module"
                },
                {
                    "name": "NgSelectComponent",
                    "type": "component"
                },
                {
                    "name": "AsyncPipe",
                    "type": "pipe"
                }
            ],
            "description": "",
            "rawdescription": "\n",
            "type": "component",
            "sourceCode": "import { Component, EventEmitter, OnInit, Output, ViewChild } from '@angular/core';\nimport { FormBuilder, FormGroup, FormsModule } from '@angular/forms';\nimport { NgSelectComponent } from '@ng-select/ng-select';\nimport { first, Observable, of } from 'rxjs';\nimport { TransactionType } from '../model';\nimport { MatFormField, MatLabel } from '@angular/material/form-field';\nimport { MatInput } from '@angular/material/input';\nimport { AsyncPipe } from '@angular/common';\n\n@Component({\n    selector: 'app-transactiontype-selection',\n    templateUrl: './transactiontype-selection.component.html',\n    styleUrls: ['./transactiontype-selection.component.scss'],\n    standalone: true,\n    imports: [MatFormField, MatLabel, MatInput, FormsModule, NgSelectComponent, AsyncPipe]\n})\n\n\nexport class TransactiontypeSelectionComponent implements OnInit {\n\n\n\n  transactionTypes: Map<string, TransactionType> = new Map<string, TransactionType>();\n  transactionTypesObservable!: Observable<string[]>;\n  selectedTransactionType!: TransactionType;\n  minAmount!:number;\n  maxAmount!:number;\n  @ViewChild(NgSelectComponent) ngSelect!:NgSelectComponent;\n\n\n\n\n  @Output() transactionTypeChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n  constructor(private formBuilder: FormBuilder) {\n  }\n\n  ngOnInit() {\n    this.transactionTypes.set(\"in- & uitkomsten\", TransactionType.BOTH)\n    this.transactionTypes.set(\"uitgaven\", TransactionType.EXPENSES)\n    this.transactionTypes.set(\"inkomsten\", TransactionType.REVENUE)\n    this.transactionTypesObservable = of(Array.from(this.transactionTypes.keys()))\n  }\n\n  public onSelectionChange(): void{\n    let sel = this.getSelectedTransactionType();\n    if (sel !== null && sel != undefined){\n      this.selectedTransactionType = sel;\n      this.transactionTypeChange.emit();\n    }\n  }\n\n  /**\n   * we cannot use two-way binding on ngModel because of how ng-select works. so this is a workaround\n   * @returns\n   */\n\n  private getSelectedTransactionType(): TransactionType | null | undefined{\n    let selectedItems = this.ngSelect.selectedItems;\n    if (selectedItems == null || selectedItems.length ===0){\n      return null;\n    }\n    if( selectedItems.length != 1){\n      throw new Error(\"only 1 item can be selected!\")\n    }\n    let firstValue: string | undefined = selectedItems[0].value;\n    if (firstValue === undefined){\n      throw new Error(\"value must not be undefined!\")\n    }\n\n    return this.transactionTypes.get(firstValue);\n\n\n\n\n  }\n\n\n}\n",
            "assetsDirs": [],
            "styleUrlsData": [
                {
                    "data": ".grid-container {\r\n    display: grid;\r\n    grid-template-columns: 50px 1fr 1fr;\r\n    grid-gap: 20px;\r\n}",
                    "styleUrl": "./transactiontype-selection.component.scss"
                }
            ],
            "stylesData": "",
            "constructorObj": {
                "name": "constructor",
                "description": "",
                "deprecated": false,
                "deprecationMessage": "",
                "args": [
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "line": 33,
                "jsdoctags": [
                    {
                        "name": "formBuilder",
                        "type": "FormBuilder",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            "extends": [],
            "implements": [
                "OnInit"
            ],
            "templateData": "<!-- <div  style=\"width: fit-content;block-size: fit-content\" >\n  \n</div> -->\n<div class=\"grid-container\" style=\"width: 100%;\" appearance=\"fill\">\n  <div class=\"grid-child\" style=\"padding-top: 15px;font-size: larger;\">\n    <span>Bedrag</span> \n  </div>\n  <div>\n    <mat-form-field class=\"grid-child\" >\n      <mat-label>min. bedrag</mat-label>\n      <input matInput [(ngModel)]=\"minAmount\" (change)=\"onSelectionChange()\">\n    </mat-form-field>\n  </div>\n  <div>\n    <mat-form-field class=\"grid-child\" >\n      <mat-label>max. bedrag</mat-label>\n      <input matInput [(ngModel)]=\"maxAmount\" (change)=\"onSelectionChange()\">\n    </mat-form-field>\n  </div>\n\n</div>\n\n\n\n<ng-select style=\"font-size: larger;\" [items]=\"transactionTypesObservable | async\"\n           autofocus\n           (ngModel)=\"selectedTransactionType\"\n           (change)=\"onSelectionChange()\" \n           placeholder=\"inkomsten / uitgaven\"\n           >\n</ng-select>"
        }
    ],
    "modules": [
        {
            "name": "AppRoutingModule",
            "id": "module-AppRoutingModule-fd0d859ef6999b02f85a3412cb3756dc2cb59d064663e55133105c438b936880b1bb55c990f5843d921cfba7a92ff4015e4038404b13ae13901b176bb03bc3ae",
            "description": "",
            "deprecationMessage": "",
            "deprecated": false,
            "file": "src/app/app-routing.module.ts",
            "methods": [],
            "sourceCode": "import {NgModule} from '@angular/core';\nimport {RouterModule, Routes} from '@angular/router';\nimport {InsightsComponent} from '././insights/insights.component';\nimport {TransactionsComponent} from './transactions/transactions.component';\nimport {LoginComponent} from \"./login/login.component\";\nimport {AuthGuard} from \"./auth/auth.guard\";\nimport {HomeLayoutComponent} from \"./layouts/home-layout/home-layout.component\";\nimport {LoginLayoutComponent} from \"./layouts/login-layout/login-layout.component\";\nimport {ProfileComponent} from \"././profile/profile.component\";\nimport {RegisterComponent} from \"./register/register.component\";\nimport {BudgetComponent} from \"./budget/budget.component\";\nimport {RulesViewComponent} from \"./rules-view/rules-view.component\";\nimport {ManualCategorizationViewComponent} from \"./manual-categorization-view/manual-categorization-view.component\";\n\nconst routes: Routes =\n\n  /*[\n    {path: 'login', component: LoginComponent, outlet: \"login_outlet\"},\n    {path: '', component: TransactionsComponent, canActivate: [AuthGuard]},\n    {path: 'transacties', component: TransactionsComponent, canActivate: [AuthGuard]},\n    {path: 'analyse', component: AnalysisComponent, canActivate: [AuthGuard]},\n    {path: '**', component: LoginComponent, outlet: \"login_outlet\"},\n\n\n  ];\n*/\n[\n  {\n    path: '',\n    component: HomeLayoutComponent,\n    canActivate: [AuthGuard],\n    children: [\n      {\n        path: 'profiel',\n        component: ProfileComponent\n      },\n      {\n        path: 'transacties',\n        component: TransactionsComponent\n      },\n      {\n        path: 'inzichten',\n        component: InsightsComponent\n      },\n      {\n        path: 'budget',\n        component: BudgetComponent\n      },\n      {\n        path: 'regels',\n        component: RulesViewComponent\n      },\n      {\n        path: 'categorieën',\n        component: ManualCategorizationViewComponent\n      }\n    ]\n  },\n  {\n    path: '',\n    component: LoginLayoutComponent,\n    children: [\n      {\n        path: 'login',\n        component: LoginComponent\n      },\n      {\n        path: 'register',\n        component: RegisterComponent\n      }\n    ]\n  },\n  {path: '**', redirectTo: ''}\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)\n  ],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {\n}\n",
            "children": [
                {
                    "type": "providers",
                    "elements": []
                },
                {
                    "type": "declarations",
                    "elements": []
                },
                {
                    "type": "imports",
                    "elements": []
                },
                {
                    "type": "exports",
                    "elements": []
                },
                {
                    "type": "bootstrap",
                    "elements": []
                },
                {
                    "type": "classes",
                    "elements": []
                }
            ]
        }
    ],
    "miscellaneous": {
        "variables": [
            {
                "name": "CONTROL_VALUE_ACCESSOR",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/query-builder/query-builder.component.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "any",
                "defaultValue": "{\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => QueryBuilderComponent),\n  multi: true\n}"
            },
            {
                "name": "DEFAULT_QUERY_BUILDER_CONFIG",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "QueryBuilderConfig",
                "defaultValue": "{\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}"
            },
            {
                "name": "dummy",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/revenue-expenses-per-period-and-category/data.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "[]",
                "defaultValue": "[{\r\n  \"name\": \"2021 - 2021\",\r\n  \"series\": [\r\n    {\"name\": \"medisch (uitgaven)\", \"value\": -3730}, {\r\n      \"name\": \"medisch (inkomsten)\", \"value\": 1645\r\n    }]\r\n}, {\r\n  \"name\": \"2022 - 2022\",\r\n  \"series\": [{\"name\": \"gemeenschappelijke kosten (uitgaven)\", \"value\": -18570}, {\r\n    \"name\": \"belastingen (uitgaven)\",\r\n    \"value\": -694\r\n  }, {\"name\": \"belastingen (inkomsten)\", \"value\": 347}, {\r\n    \"name\": \"wonen (uitgaven)\",\r\n    \"value\": -4433\r\n  }, {\"name\": \"wonen (inkomsten)\", \"value\": 1415}, {\r\n    \"name\": \"vakbond (uitgaven)\",\r\n    \"value\": -162\r\n  }, {\"name\": \"inkomsten (uitgaven)\", \"value\": -362}, {\r\n    \"name\": \"inkomsten (inkomsten)\",\r\n    \"value\": 36102\r\n  }, {\"name\": \"vrije tijd (uitgaven)\", \"value\": -2614}, {\r\n    \"name\": \"vrije tijd (inkomsten)\",\r\n    \"value\": 991\r\n  }, {\"name\": \"telecom (uitgaven)\", \"value\": -944}, {\r\n    \"name\": \"medisch (uitgaven)\",\r\n    \"value\": -2802\r\n  }, {\"name\": \"medisch (inkomsten)\", \"value\": 601}, {\r\n    \"name\": \"sparen (uitgaven)\",\r\n    \"value\": -8902\r\n  }, {\"name\": \"giften (uitgaven)\", \"value\": -624}, {\r\n    \"name\": \"giften (inkomsten)\",\r\n    \"value\": 950\r\n  }, {\"name\": \"leningen (uitgaven)\", \"value\": -1726}, {\r\n    \"name\": \"webshops (uitgaven)\",\r\n    \"value\": -384\r\n  }, {\"name\": \"transfer spaargeld (inkomsten)\", \"value\": 6621}, {\r\n    \"name\": \"kredietkaart (uitgaven)\",\r\n    \"value\": -3321\r\n  }, {\"name\": \"bankkosten (uitgaven)\", \"value\": -68}, {\r\n    \"name\": \"cash geldopname (uitgaven)\",\r\n    \"value\": -2560\r\n  }, {\"name\": \"cash geldopname (inkomsten)\", \"value\": 60}, {\r\n    \"name\": \"kledij & verzorging (uitgaven)\",\r\n    \"value\": -827\r\n  }, {\"name\": \"auto & vervoer (uitgaven)\", \"value\": -55}, {\r\n    \"name\": \"huishouden (uitgaven)\",\r\n    \"value\": -205\r\n  }, {\"name\": \"GEEN CATEGORIE (uitgaven)\", \"value\": -676}, {\"name\": \"energie (uitgaven)\", \"value\": -929}]\r\n}]"
            },
            {
                "name": "DUMMY_CATEGORY",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/model.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "CategoryNode",
                "defaultValue": "{\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}"
            },
            {
                "name": "DUMMY_USER",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/model.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "User",
                "defaultValue": "{\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}"
            },
            {
                "name": "EMPTY_PERIOD",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/model.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Period",
                "defaultValue": "{\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}"
            },
            {
                "name": "EMPTY_TRANSACTION_QUERY",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/model.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "TransactionQuery",
                "defaultValue": "{\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}"
            },
            {
                "name": "environment",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/environments/environment.prod.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  production: true,\n  API_BASE_PATH: \"\"\n}"
            },
            {
                "name": "environment",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/environments/environment.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  production: false,\n  //backendUrl: \"http://localhost:8080\",\n  API_BASE_PATH: 'http://localhost:8080'\n}"
            },
            {
                "name": "FIELDS_BY_NAME_MAP",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Map<string, Field>",
                "defaultValue": "createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG)"
            },
            {
                "name": "FIELDS_BY_PATH_FROM_TRANSACTION_MAP",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Map<string, Field>",
                "defaultValue": "createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG)"
            },
            {
                "name": "MATCH_TYPES",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "RuleMatchType[]",
                "defaultValue": "MatchTypes.ALL"
            },
            {
                "name": "MATCH_TYPES_BY_NAME_MAP",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "Map<string, RuleMatchType>",
                "defaultValue": "createMatchTypesByNameMap(MATCH_TYPES)"
            },
            {
                "name": "NO_CATEGORY",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/model.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "CategoryNode",
                "defaultValue": "{\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}"
            },
            {
                "name": "PICK_FORMATS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/filters/filters.component.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  parse: {dateInput: {month: 'short', year: 'numeric', day: 'numeric'}},\n  display: {\n    dateInput: 'input',\n    monthYearLabel: {year: 'numeric', month: 'short'},\n    dateA11yLabel: {year: 'numeric', month: 'long', day: 'numeric'},\n    monthYearA11yLabel: {year: 'numeric', month: 'long'}\n  }\n}"
            },
            {
                "name": "PICK_FORMATS",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/period-selection/period-selection.component.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "object",
                "defaultValue": "{\n  parse: { dateInput: { month: 'short', year: 'numeric', day: 'numeric' } },\n  display: {\n    dateInput: 'input',\n    monthYearLabel: { year: 'numeric', month: 'short' },\n    dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },\n    monthYearA11yLabel: { year: 'numeric', month: 'long' }\n  }\n}"
            },
            {
                "name": "VALIDATOR",
                "ctype": "miscellaneous",
                "subtype": "variable",
                "file": "src/app/query-builder/query-builder.component.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "type": "any",
                "defaultValue": "{\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => QueryBuilderComponent),\n  multi: true\n}"
            }
        ],
        "functions": [
            {
                "name": "anyIsUndefinedOrEmpty",
                "file": "src/app/model.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "args",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "dotDotDotToken": true
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": "args",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "dotDotDotToken": true,
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "convertClientRuleSetToRuleSet",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "<p>Converts a ClientRuleSet to a RuleSet</p>\n",
                "args": [
                    {
                        "name": "clientRuleSet",
                        "type": "ClientRuleSet",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "RuleSet",
                "jsdoctags": [
                    {
                        "name": "clientRuleSet",
                        "type": "ClientRuleSet",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "convertClientRuleToRule",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "<p>Converts a RuleSet to a ClientRuleSet</p>\n",
                "args": [
                    {
                        "name": "clientRule",
                        "type": "ClientRule",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Rule",
                "jsdoctags": [
                    {
                        "name": "clientRule",
                        "type": "ClientRule",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "convertRuleToClientRule",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "<p>Converts a Rule to a ClientRule</p>\n",
                "args": [
                    {
                        "name": "rule",
                        "type": "Rule",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "type",
                        "type": "TypeEnum",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "TypeEnum.BOTH"
                    }
                ],
                "returnType": "ClientRule",
                "jsdoctags": [
                    {
                        "name": "rule",
                        "type": "Rule",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "type",
                        "type": "TypeEnum",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "defaultValue": "TypeEnum.BOTH",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "createFieldByNameMap",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "queryBuilderConfig",
                        "type": "QueryBuilderConfig",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Map<string, Field>",
                "jsdoctags": [
                    {
                        "name": "queryBuilderConfig",
                        "type": "QueryBuilderConfig",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "createFieldByPathFromTransactionMap",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "DEFAULT_QUERY_BUILDER_CONFIG",
                        "type": "QueryBuilderConfig",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Map<string, Field>",
                "jsdoctags": [
                    {
                        "name": "DEFAULT_QUERY_BUILDER_CONFIG",
                        "type": "QueryBuilderConfig",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "createMatchTypesByNameMap",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "MATCH_TYPES",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Map<string, RuleMatchType>",
                "jsdoctags": [
                    {
                        "name": "MATCH_TYPES",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "deserializeRuleSet",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "jsonString",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "RuleSet",
                "jsdoctags": [
                    {
                        "name": "jsonString",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getColorForLabel",
                "file": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "label",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "labelColors",
                        "type": "Map",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "string",
                "jsdoctags": [
                    {
                        "name": "label",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "labelColors",
                        "type": "Map",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "getRandomColor",
                "file": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": []
            },
            {
                "name": "inferAmountType",
                "file": "src/app/model.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "amount",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "jsdoctags": [
                    {
                        "name": "amount",
                        "type": "number",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "isEmptyString",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "value",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": "value",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "isObject",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "object",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": "object",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "isValidRuleSetObject",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "obj",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": "obj",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "objectsAreEqual",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "obj1",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "obj2",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "boolean",
                "jsdoctags": [
                    {
                        "name": "obj1",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "obj2",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "operatorReviverFn",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "key",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "value",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "returnType": "Operator",
                "jsdoctags": [
                    {
                        "name": "key",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "value",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "ruleSetReviverFn",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "key",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "value",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "jsdoctags": [
                    {
                        "name": "key",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "value",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            },
            {
                "name": "ruleSetReviverFn0",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "ctype": "miscellaneous",
                "subtype": "function",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "args": [
                    {
                        "name": "key",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "value",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "jsdoctags": [
                    {
                        "name": "key",
                        "type": "string",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    },
                    {
                        "name": "value",
                        "type": "any",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "tagName": {
                            "text": "param"
                        }
                    }
                ]
            }
        ],
        "typealiases": [
            {
                "name": "CategoryType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "\"EXPENSES\" | \"REVENUE\"",
                "file": "src/app/model.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 192
            },
            {
                "name": "ExtendedConditionEnum",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "ConditionEnum",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 183
            },
            {
                "name": "FieldType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "FieldTypeEnum | \"null\"",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 192
            },
            {
                "name": "MatchType",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "RuleMatchType",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 183
            },
            {
                "name": "RuleSetRulesInner",
                "ctype": "miscellaneous",
                "subtype": "typealias",
                "rawtype": "any",
                "file": "src/app/query-builder/query-builder.interfaces.ts",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "kind": 133
            }
        ],
        "enumerations": [
            {
                "name": "ActiveView",
                "childs": [
                    {
                        "name": "EXPENSES",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "expenses"
                    },
                    {
                        "name": "REVENUE",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "revenue"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/model.ts"
            },
            {
                "name": "AmountType",
                "childs": [
                    {
                        "name": "REVENUE",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "REVENUE"
                    },
                    {
                        "name": "EXPENSES",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "EXPENSES"
                    },
                    {
                        "name": "BOTH",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "BOTH"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/model.ts"
            },
            {
                "name": "FileQueueStatus",
                "childs": [
                    {
                        "name": "Pending",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Success",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Error",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "Progress",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/file-uploader.service.ts"
            },
            {
                "name": "Grouping",
                "childs": [
                    {
                        "name": "MONTH",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "month"
                    },
                    {
                        "name": "QUARTER",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "quarter"
                    },
                    {
                        "name": "YEAR",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "year"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/model.ts"
            },
            {
                "name": "LoginFailureReason",
                "childs": [
                    {
                        "name": "PASSWORD_USER_COMBINATION_IS_WRONG",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "SERVER_ERROR",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/auth/auth.service.ts"
            },
            {
                "name": "RegisterFailureReason",
                "childs": [
                    {
                        "name": "USER_ALREADY_EXISTS",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "EMPTY_FIELDS",
                        "deprecated": false,
                        "deprecationMessage": ""
                    },
                    {
                        "name": "SERVER_ERROR",
                        "deprecated": false,
                        "deprecationMessage": ""
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/auth/auth.service.ts"
            },
            {
                "name": "Response",
                "childs": [
                    {
                        "name": "SUCCESS",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "SUCCESS"
                    },
                    {
                        "name": "FAILED",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "FAILED"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/auth/auth.service.ts"
            },
            {
                "name": "StartEndDateShortcut",
                "childs": [
                    {
                        "name": "CURRENT_MONTH",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "current month"
                    },
                    {
                        "name": "PREVIOUS_MONTH",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "previous month"
                    },
                    {
                        "name": "CURRENT_QUARTER",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "current quarter"
                    },
                    {
                        "name": "PREVIOUS_QUARTER",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "previous quarter"
                    },
                    {
                        "name": "CURRENT_YEAR",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "current year"
                    },
                    {
                        "name": "PREVIOUS_YEAR",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "previous year"
                    },
                    {
                        "name": "ALL",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "all"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/model.ts"
            },
            {
                "name": "TransactionType",
                "childs": [
                    {
                        "name": "REVENUE",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "revenue"
                    },
                    {
                        "name": "EXPENSES",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "expenses"
                    },
                    {
                        "name": "BOTH",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "both"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/model.ts"
            },
            {
                "name": "Type",
                "childs": [
                    {
                        "name": "SUCCESS",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "SUCCESS"
                    },
                    {
                        "name": "FAILED",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "FAILED"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/model.ts"
            },
            {
                "name": "ViewType",
                "childs": [
                    {
                        "name": "INITIAL_VIEW",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "INITIAL_VIEW"
                    },
                    {
                        "name": "RUN_QUERY",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "RUN_QUERY"
                    },
                    {
                        "name": "SHOW_ALL",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "SHOW_ALL"
                    },
                    {
                        "name": "UPLOAD_TRANSACTIONS",
                        "deprecated": false,
                        "deprecationMessage": "",
                        "value": "UPLOAD_TRANSACTIONS"
                    }
                ],
                "ctype": "miscellaneous",
                "subtype": "enum",
                "deprecated": false,
                "deprecationMessage": "",
                "description": "",
                "file": "src/app/transactions/transactions.component.ts"
            }
        ],
        "groupedVariables": {
            "src/app/query-builder/query-builder.component.ts": [
                {
                    "name": "CONTROL_VALUE_ACCESSOR",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/query-builder/query-builder.component.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "defaultValue": "{\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => QueryBuilderComponent),\n  multi: true\n}"
                },
                {
                    "name": "VALIDATOR",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/query-builder/query-builder.component.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "any",
                    "defaultValue": "{\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => QueryBuilderComponent),\n  multi: true\n}"
                }
            ],
            "src/app/query-builder/query-builder.interfaces.ts": [
                {
                    "name": "DEFAULT_QUERY_BUILDER_CONFIG",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "QueryBuilderConfig",
                    "defaultValue": "{\r\n  fields: {\r\n    counterpartyName: new Field(\"counterpartyName\", \"counterparty.name\", 'string', \"Counterparty Name\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    counterpartyAccount: new Field(\"counterpartyAccount\", \"counterparty.accountNumber\", 'string', \"Counterparty Account\", undefined,\r\n      undefined, StringOperators.ALL),\r\n    transaction: new Field(\"transaction\", \"transaction\", 'string', \"Transaction\", undefined, undefined, StringOperators.ALL),\r\n    communications: new Field(\"communications\", \"communications\", 'string', \"Communications\", undefined, undefined,\r\n      StringOperators.ALL),\r\n    currency: new Field(\"currency\", \"currency\", 'category', \"Currency\", undefined, [], CategoricalOperators.ALL),\r\n    country: new Field(\"country\", \"countryCode\", 'categorical', \"Country\", undefined, [], CategoricalOperators.ALL),\r\n  }\r\n}"
                },
                {
                    "name": "FIELDS_BY_NAME_MAP",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string, Field>",
                    "defaultValue": "createFieldByNameMap(DEFAULT_QUERY_BUILDER_CONFIG)"
                },
                {
                    "name": "FIELDS_BY_PATH_FROM_TRANSACTION_MAP",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string, Field>",
                    "defaultValue": "createFieldByPathFromTransactionMap(DEFAULT_QUERY_BUILDER_CONFIG)"
                },
                {
                    "name": "MATCH_TYPES",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "RuleMatchType[]",
                    "defaultValue": "MatchTypes.ALL"
                },
                {
                    "name": "MATCH_TYPES_BY_NAME_MAP",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Map<string, RuleMatchType>",
                    "defaultValue": "createMatchTypesByNameMap(MATCH_TYPES)"
                }
            ],
            "src/app/revenue-expenses-per-period-and-category/data.ts": [
                {
                    "name": "dummy",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/revenue-expenses-per-period-and-category/data.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "[]",
                    "defaultValue": "[{\r\n  \"name\": \"2021 - 2021\",\r\n  \"series\": [\r\n    {\"name\": \"medisch (uitgaven)\", \"value\": -3730}, {\r\n      \"name\": \"medisch (inkomsten)\", \"value\": 1645\r\n    }]\r\n}, {\r\n  \"name\": \"2022 - 2022\",\r\n  \"series\": [{\"name\": \"gemeenschappelijke kosten (uitgaven)\", \"value\": -18570}, {\r\n    \"name\": \"belastingen (uitgaven)\",\r\n    \"value\": -694\r\n  }, {\"name\": \"belastingen (inkomsten)\", \"value\": 347}, {\r\n    \"name\": \"wonen (uitgaven)\",\r\n    \"value\": -4433\r\n  }, {\"name\": \"wonen (inkomsten)\", \"value\": 1415}, {\r\n    \"name\": \"vakbond (uitgaven)\",\r\n    \"value\": -162\r\n  }, {\"name\": \"inkomsten (uitgaven)\", \"value\": -362}, {\r\n    \"name\": \"inkomsten (inkomsten)\",\r\n    \"value\": 36102\r\n  }, {\"name\": \"vrije tijd (uitgaven)\", \"value\": -2614}, {\r\n    \"name\": \"vrije tijd (inkomsten)\",\r\n    \"value\": 991\r\n  }, {\"name\": \"telecom (uitgaven)\", \"value\": -944}, {\r\n    \"name\": \"medisch (uitgaven)\",\r\n    \"value\": -2802\r\n  }, {\"name\": \"medisch (inkomsten)\", \"value\": 601}, {\r\n    \"name\": \"sparen (uitgaven)\",\r\n    \"value\": -8902\r\n  }, {\"name\": \"giften (uitgaven)\", \"value\": -624}, {\r\n    \"name\": \"giften (inkomsten)\",\r\n    \"value\": 950\r\n  }, {\"name\": \"leningen (uitgaven)\", \"value\": -1726}, {\r\n    \"name\": \"webshops (uitgaven)\",\r\n    \"value\": -384\r\n  }, {\"name\": \"transfer spaargeld (inkomsten)\", \"value\": 6621}, {\r\n    \"name\": \"kredietkaart (uitgaven)\",\r\n    \"value\": -3321\r\n  }, {\"name\": \"bankkosten (uitgaven)\", \"value\": -68}, {\r\n    \"name\": \"cash geldopname (uitgaven)\",\r\n    \"value\": -2560\r\n  }, {\"name\": \"cash geldopname (inkomsten)\", \"value\": 60}, {\r\n    \"name\": \"kledij & verzorging (uitgaven)\",\r\n    \"value\": -827\r\n  }, {\"name\": \"auto & vervoer (uitgaven)\", \"value\": -55}, {\r\n    \"name\": \"huishouden (uitgaven)\",\r\n    \"value\": -205\r\n  }, {\"name\": \"GEEN CATEGORIE (uitgaven)\", \"value\": -676}, {\"name\": \"energie (uitgaven)\", \"value\": -929}]\r\n}]"
                }
            ],
            "src/app/model.ts": [
                {
                    "name": "DUMMY_CATEGORY",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/model.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryNode",
                    "defaultValue": "{\r\n    children: [],\r\n    name: \"DUMMY CATEGORY\",\r\n    qualifiedName: \"DUMMY CATEGORY\",\r\n    type: undefined,\r\n    id: -1\r\n}"
                },
                {
                    "name": "DUMMY_USER",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/model.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "User",
                    "defaultValue": "{\r\n    firstName: undefined,\r\n    lastName: undefined,\r\n    email: undefined,\r\n    password: undefined,\r\n    bankAccounts: undefined,\r\n    userName: undefined\r\n}"
                },
                {
                    "name": "EMPTY_PERIOD",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/model.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "Period",
                    "defaultValue": "{\r\n    start: \"\",\r\n    end: \"\",\r\n    grouping: Grouping.MONTH,\r\n    value: \"\"\r\n\r\n}"
                },
                {
                    "name": "EMPTY_TRANSACTION_QUERY",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/model.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "TransactionQuery",
                    "defaultValue": "{\r\n    revenue: undefined,\r\n    expenses: undefined,\r\n    counterpartyName: undefined,\r\n    minAmount: undefined,\r\n    maxAmount: undefined,\r\n    accountNumber: undefined,\r\n    category: undefined,\r\n    freeText: undefined,\r\n    counterpartyAccountNumber: undefined,\r\n    startDate: undefined,\r\n    endDate: undefined,\r\n    transactionOrCommunication: undefined,\r\n    uploadTimestamp: undefined\r\n\r\n\r\n}"
                },
                {
                    "name": "NO_CATEGORY",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/model.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "CategoryNode",
                    "defaultValue": "{\r\n    children: [],\r\n    name: \"NO CATEGORY\",\r\n    qualifiedName: \"NO CATEGORY\",\r\n    type: undefined ,\r\n    id: -1\r\n}"
                }
            ],
            "src/environments/environment.prod.ts": [
                {
                    "name": "environment",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/environments/environment.prod.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  production: true,\n  API_BASE_PATH: \"\"\n}"
                }
            ],
            "src/environments/environment.ts": [
                {
                    "name": "environment",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/environments/environment.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  production: false,\n  //backendUrl: \"http://localhost:8080\",\n  API_BASE_PATH: 'http://localhost:8080'\n}"
                }
            ],
            "src/app/filters/filters.component.ts": [
                {
                    "name": "PICK_FORMATS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/filters/filters.component.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  parse: {dateInput: {month: 'short', year: 'numeric', day: 'numeric'}},\n  display: {\n    dateInput: 'input',\n    monthYearLabel: {year: 'numeric', month: 'short'},\n    dateA11yLabel: {year: 'numeric', month: 'long', day: 'numeric'},\n    monthYearA11yLabel: {year: 'numeric', month: 'long'}\n  }\n}"
                }
            ],
            "src/app/period-selection/period-selection.component.ts": [
                {
                    "name": "PICK_FORMATS",
                    "ctype": "miscellaneous",
                    "subtype": "variable",
                    "file": "src/app/period-selection/period-selection.component.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "type": "object",
                    "defaultValue": "{\n  parse: { dateInput: { month: 'short', year: 'numeric', day: 'numeric' } },\n  display: {\n    dateInput: 'input',\n    monthYearLabel: { year: 'numeric', month: 'short' },\n    dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },\n    monthYearA11yLabel: { year: 'numeric', month: 'long' }\n  }\n}"
                }
            ]
        },
        "groupedFunctions": {
            "src/app/model.ts": [
                {
                    "name": "anyIsUndefinedOrEmpty",
                    "file": "src/app/model.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "args",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "dotDotDotToken": true
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": "args",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "dotDotDotToken": true,
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "inferAmountType",
                    "file": "src/app/model.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "amount",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "jsdoctags": [
                        {
                            "name": "amount",
                            "type": "number",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/app/query-builder/query-builder.interfaces.ts": [
                {
                    "name": "convertClientRuleSetToRuleSet",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "<p>Converts a ClientRuleSet to a RuleSet</p>\n",
                    "args": [
                        {
                            "name": "clientRuleSet",
                            "type": "ClientRuleSet",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "RuleSet",
                    "jsdoctags": [
                        {
                            "name": "clientRuleSet",
                            "type": "ClientRuleSet",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "convertClientRuleToRule",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "<p>Converts a RuleSet to a ClientRuleSet</p>\n",
                    "args": [
                        {
                            "name": "clientRule",
                            "type": "ClientRule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Rule",
                    "jsdoctags": [
                        {
                            "name": "clientRule",
                            "type": "ClientRule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "convertRuleToClientRule",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "<p>Converts a Rule to a ClientRule</p>\n",
                    "args": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "type",
                            "type": "TypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "TypeEnum.BOTH"
                        }
                    ],
                    "returnType": "ClientRule",
                    "jsdoctags": [
                        {
                            "name": "rule",
                            "type": "Rule",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "type",
                            "type": "TypeEnum",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "defaultValue": "TypeEnum.BOTH",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "createFieldByNameMap",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "queryBuilderConfig",
                            "type": "QueryBuilderConfig",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Map<string, Field>",
                    "jsdoctags": [
                        {
                            "name": "queryBuilderConfig",
                            "type": "QueryBuilderConfig",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "createFieldByPathFromTransactionMap",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "DEFAULT_QUERY_BUILDER_CONFIG",
                            "type": "QueryBuilderConfig",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Map<string, Field>",
                    "jsdoctags": [
                        {
                            "name": "DEFAULT_QUERY_BUILDER_CONFIG",
                            "type": "QueryBuilderConfig",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "createMatchTypesByNameMap",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "MATCH_TYPES",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Map<string, RuleMatchType>",
                    "jsdoctags": [
                        {
                            "name": "MATCH_TYPES",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "deserializeRuleSet",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "jsonString",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "RuleSet",
                    "jsdoctags": [
                        {
                            "name": "jsonString",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isEmptyString",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "value",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": "value",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isObject",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "object",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": "object",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "isValidRuleSetObject",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "obj",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": "obj",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "objectsAreEqual",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "obj1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "obj2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "boolean",
                    "jsdoctags": [
                        {
                            "name": "obj1",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "obj2",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "operatorReviverFn",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "key",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "value",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "Operator",
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "value",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ruleSetReviverFn",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "key",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "value",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "value",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "ruleSetReviverFn0",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "key",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "value",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "jsdoctags": [
                        {
                            "name": "key",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "value",
                            "type": "any",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                }
            ],
            "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts": [
                {
                    "name": "getColorForLabel",
                    "file": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": [
                        {
                            "name": "label",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "labelColors",
                            "type": "Map",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "returnType": "string",
                    "jsdoctags": [
                        {
                            "name": "label",
                            "type": "string",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        },
                        {
                            "name": "labelColors",
                            "type": "Map",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "tagName": {
                                "text": "param"
                            }
                        }
                    ]
                },
                {
                    "name": "getRandomColor",
                    "file": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
                    "ctype": "miscellaneous",
                    "subtype": "function",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "args": []
                }
            ]
        },
        "groupedEnumerations": {
            "src/app/model.ts": [
                {
                    "name": "ActiveView",
                    "childs": [
                        {
                            "name": "EXPENSES",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "expenses"
                        },
                        {
                            "name": "REVENUE",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "revenue"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/model.ts"
                },
                {
                    "name": "AmountType",
                    "childs": [
                        {
                            "name": "REVENUE",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "REVENUE"
                        },
                        {
                            "name": "EXPENSES",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "EXPENSES"
                        },
                        {
                            "name": "BOTH",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "BOTH"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/model.ts"
                },
                {
                    "name": "Grouping",
                    "childs": [
                        {
                            "name": "MONTH",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "month"
                        },
                        {
                            "name": "QUARTER",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "quarter"
                        },
                        {
                            "name": "YEAR",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "year"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/model.ts"
                },
                {
                    "name": "StartEndDateShortcut",
                    "childs": [
                        {
                            "name": "CURRENT_MONTH",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "current month"
                        },
                        {
                            "name": "PREVIOUS_MONTH",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "previous month"
                        },
                        {
                            "name": "CURRENT_QUARTER",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "current quarter"
                        },
                        {
                            "name": "PREVIOUS_QUARTER",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "previous quarter"
                        },
                        {
                            "name": "CURRENT_YEAR",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "current year"
                        },
                        {
                            "name": "PREVIOUS_YEAR",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "previous year"
                        },
                        {
                            "name": "ALL",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "all"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/model.ts"
                },
                {
                    "name": "TransactionType",
                    "childs": [
                        {
                            "name": "REVENUE",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "revenue"
                        },
                        {
                            "name": "EXPENSES",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "expenses"
                        },
                        {
                            "name": "BOTH",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "both"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/model.ts"
                },
                {
                    "name": "Type",
                    "childs": [
                        {
                            "name": "SUCCESS",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "SUCCESS"
                        },
                        {
                            "name": "FAILED",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "FAILED"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/model.ts"
                }
            ],
            "src/app/file-uploader.service.ts": [
                {
                    "name": "FileQueueStatus",
                    "childs": [
                        {
                            "name": "Pending",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Success",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Error",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "Progress",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/file-uploader.service.ts"
                }
            ],
            "src/app/auth/auth.service.ts": [
                {
                    "name": "LoginFailureReason",
                    "childs": [
                        {
                            "name": "PASSWORD_USER_COMBINATION_IS_WRONG",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "SERVER_ERROR",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/auth/auth.service.ts"
                },
                {
                    "name": "RegisterFailureReason",
                    "childs": [
                        {
                            "name": "USER_ALREADY_EXISTS",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "EMPTY_FIELDS",
                            "deprecated": false,
                            "deprecationMessage": ""
                        },
                        {
                            "name": "SERVER_ERROR",
                            "deprecated": false,
                            "deprecationMessage": ""
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/auth/auth.service.ts"
                },
                {
                    "name": "Response",
                    "childs": [
                        {
                            "name": "SUCCESS",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "SUCCESS"
                        },
                        {
                            "name": "FAILED",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "FAILED"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/auth/auth.service.ts"
                }
            ],
            "src/app/transactions/transactions.component.ts": [
                {
                    "name": "ViewType",
                    "childs": [
                        {
                            "name": "INITIAL_VIEW",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "INITIAL_VIEW"
                        },
                        {
                            "name": "RUN_QUERY",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "RUN_QUERY"
                        },
                        {
                            "name": "SHOW_ALL",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "SHOW_ALL"
                        },
                        {
                            "name": "UPLOAD_TRANSACTIONS",
                            "deprecated": false,
                            "deprecationMessage": "",
                            "value": "UPLOAD_TRANSACTIONS"
                        }
                    ],
                    "ctype": "miscellaneous",
                    "subtype": "enum",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "file": "src/app/transactions/transactions.component.ts"
                }
            ]
        },
        "groupedTypeAliases": {
            "src/app/model.ts": [
                {
                    "name": "CategoryType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "\"EXPENSES\" | \"REVENUE\"",
                    "file": "src/app/model.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 192
                }
            ],
            "src/app/query-builder/query-builder.interfaces.ts": [
                {
                    "name": "ExtendedConditionEnum",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "ConditionEnum",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 183
                },
                {
                    "name": "FieldType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "FieldTypeEnum | \"null\"",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 192
                },
                {
                    "name": "MatchType",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "RuleMatchType",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 183
                },
                {
                    "name": "RuleSetRulesInner",
                    "ctype": "miscellaneous",
                    "subtype": "typealias",
                    "rawtype": "any",
                    "file": "src/app/query-builder/query-builder.interfaces.ts",
                    "deprecated": false,
                    "deprecationMessage": "",
                    "description": "",
                    "kind": 133
                }
            ]
        }
    },
    "routes": [],
    "coverage": {
        "count": 2,
        "status": "low",
        "files": [
            {
                "filePath": "src/app/JsonDateInterceptor.ts",
                "type": "interceptor",
                "linktype": "interceptor",
                "name": "JsonDateInterceptor",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AnalysisForPeriodByCategoryComponent",
                "coveragePercent": 0,
                "coverageCount": "0/15",
                "status": "low"
            },
            {
                "filePath": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "PieChartData",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getColorForLabel",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/analysis-for-period-by-category/analysis-for-period-by-category.component.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "getRandomColor",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/app.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "AppComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/app.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "AppService",
                "coveragePercent": 0,
                "coverageCount": "0/63",
                "status": "low"
            },
            {
                "filePath": "src/app/auth.interceptor.ts",
                "type": "interceptor",
                "linktype": "interceptor",
                "name": "AuthInterceptor",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/auth/auth.guard.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "AuthGuard",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/auth/auth.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "AuthService",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/auth/auth.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "LoginResponse",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/auth/auth.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "RegisterResponse",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/bank-account-check-boxes/bank-account-check-boxes.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "BankAccountCheckBoxesComponent",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/bank-account-selection/bank-account-selection.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "BankAccountSelectionComponent",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/boolean-radio-button-group/boolean-radio-button-group.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "BooleanRadioButtonGroupComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/budget-tracking/budget-tracking.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "BudgetTrackingComponent",
                "coveragePercent": 0,
                "coverageCount": "0/13",
                "status": "low"
            },
            {
                "filePath": "src/app/budget/budget.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "BudgetComponent",
                "coveragePercent": 4,
                "coverageCount": "2/47",
                "status": "low"
            },
            {
                "filePath": "src/app/budget/budget.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "FlatBudgetTreeNode",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/budget/budget.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "MyErrorStateMatcher",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/budget/budget.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "BudgetTreeNode",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/budget/budget.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "FindOrCreateBudgetResponse",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/budget/budget.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "UpdateBudgetEntryResponse",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/budget/save-error-dialog/save-error-dialog.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "SaveErrorDialogComponent",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/category-details/category-details.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CategoryDetailsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/18",
                "status": "low"
            },
            {
                "filePath": "src/app/category-details/category-details.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Category",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/category-tree-dropdown/category-tree-dropdown.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CategoryTreeDropdownComponent",
                "coveragePercent": 10,
                "coverageCount": "3/28",
                "status": "low"
            },
            {
                "filePath": "src/app/category-tree-dropdown/category-tree-dropdown.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "BackingDatabase",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/counterparty-account-number-selection/counterparty-account-number-selection.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CounterpartyAccountNumberSelectionComponent",
                "coveragePercent": 11,
                "coverageCount": "1/9",
                "status": "low"
            },
            {
                "filePath": "src/app/counterparty-name-selection/counterparty-name-selection.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CounterpartyNameSelectionComponent",
                "coveragePercent": 11,
                "coverageCount": "1/9",
                "status": "low"
            },
            {
                "filePath": "src/app/criteria-toolbar/criteria-toolbar.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "CriteriaToolbarComponent",
                "coveragePercent": 0,
                "coverageCount": "0/24",
                "status": "low"
            },
            {
                "filePath": "src/app/error-dialog/error-dialog.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ErrorDialogComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/error-dialog/error-dialog.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ErrorDialogService",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/expenses-revenue-toggle/expenses-revenue-toggle.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ExpensesRevenueToggleComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/file-uploader.service.ts",
                "type": "class",
                "linktype": "classe",
                "name": "FileQueueObject",
                "coveragePercent": 0,
                "coverageCount": "0/15",
                "status": "low"
            },
            {
                "filePath": "src/app/file-uploader.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "FileUploaderService",
                "coveragePercent": 0,
                "coverageCount": "0/16",
                "status": "low"
            },
            {
                "filePath": "src/app/file-uploader/file-uploader.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "FileUploaderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/filters/filters.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "FiltersComponent",
                "coveragePercent": 0,
                "coverageCount": "0/24",
                "status": "low"
            },
            {
                "filePath": "src/app/filters/filters.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "PickDateAdapter",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/filters/filters.component.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "PICK_FORMATS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/grouping-type-selection/grouping-type-selection.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "GroupingTypeSelectionComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/iban.pipe.ts",
                "type": "pipe",
                "linktype": "pipe",
                "name": "IbanPipe",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/insights/insights.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "InsightsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/11",
                "status": "low"
            },
            {
                "filePath": "src/app/layouts/home-layout/home-layout.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "HomeLayoutComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/layouts/login-layout/login-layout.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "LoginLayoutComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/login/login.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "LoginComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/manual-categorization-view/manual-categorization-view.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ManualCategorizationViewComponent",
                "coveragePercent": 0,
                "coverageCount": "0/19",
                "status": "low"
            },
            {
                "filePath": "src/app/manual-categorization-view/manual-categorization-view.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "GroupByCounterpartyDataSource",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/manual-categorization-view/manual-categorization-view.component.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "GroupBy",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "class",
                "linktype": "classe",
                "name": "CategoryMap",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "class",
                "linktype": "classe",
                "name": "FlatCategoryNode",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "class",
                "linktype": "classe",
                "name": "ResolvedStartEndDateShortcut",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "BankAccount",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "BudgetTrackerResult",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "BudgetTrackerResultNode",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "CategoryAndAmount",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "CategoryDetailsForPeriodHandlerResult",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "CategoryNode",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "CompositeTransactionsFileUploadResponse",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Counterparty",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Dataset",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "DistributionByCategoryForPeriodChartData",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "DistributionByCategoryForPeriodHandlerResult",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "DistributionByCategoryForPeriodHandlerResult2",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "DistributionByCategoryForPeriodTableData",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "DistributionByTransactionTypeForPeriod",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "FileWrapper",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Period",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "PeriodAndAmount",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Transaction",
                "coveragePercent": 0,
                "coverageCount": "0/19",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "TransactionQuery",
                "coveragePercent": 0,
                "coverageCount": "0/14",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "TransactionsCategorizationResponse",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "TransactionsFileUploadResponse",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "TransactionsFileUploadResponseWrapper",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "TransactionsInContextQuery",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "User",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "anyIsUndefinedOrEmpty",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "inferAmountType",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "DUMMY_CATEGORY",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "DUMMY_USER",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "EMPTY_PERIOD",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "EMPTY_TRANSACTION_QUERY",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "NO_CATEGORY",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "CategoryType",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/model/criteria.model.ts",
                "type": "class",
                "linktype": "classe",
                "name": "Criteria",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/navigation/navigation.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "NavigationComponent",
                "coveragePercent": 0,
                "coverageCount": "0/12",
                "status": "low"
            },
            {
                "filePath": "src/app/period-selection/period-selection.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "PeriodSelectionComponent",
                "coveragePercent": 5,
                "coverageCount": "1/19",
                "status": "low"
            },
            {
                "filePath": "src/app/period-selection/period-selection.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "PickDateAdapter",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/period-selection/period-selection.component.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "PICK_FORMATS",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/profile/profile.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ProfileComponent",
                "coveragePercent": 0,
                "coverageCount": "0/11",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "QueryBuilderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/73",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "FieldsMetaData",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.component.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "CONTROL_VALUE_ACCESSOR",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.component.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "VALIDATOR",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "CategoricalOperators",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "Comparator",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "Field",
                "coveragePercent": 0,
                "coverageCount": "0/11",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "MatchTypes",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "MultiMap",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "NumericalOperators",
                "coveragePercent": 0,
                "coverageCount": "0/8",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "Operator",
                "coveragePercent": 0,
                "coverageCount": "0/7",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "Rule",
                "coveragePercent": 0,
                "coverageCount": "0/20",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "RuleSet",
                "coveragePercent": 0,
                "coverageCount": "0/11",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "RuleUtils",
                "coveragePercent": 0,
                "coverageCount": "0/12",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "class",
                "linktype": "classe",
                "name": "StringOperators",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "FieldMap",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "LocalRuleMeta",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "Option",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "QueryBuilderClassNames",
                "coveragePercent": 0,
                "coverageCount": "0/31",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "QueryBuilderConfig",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "RuleSetWrapper",
                "coveragePercent": 0,
                "coverageCount": "0/2",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "convertClientRuleSetToRuleSet",
                "coveragePercent": 100,
                "coverageCount": "1/1",
                "status": "very-good"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "convertClientRuleToRule",
                "coveragePercent": 100,
                "coverageCount": "1/1",
                "status": "very-good"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "convertRuleToClientRule",
                "coveragePercent": 100,
                "coverageCount": "1/1",
                "status": "very-good"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "createFieldByNameMap",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "createFieldByPathFromTransactionMap",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "createMatchTypesByNameMap",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "deserializeRuleSet",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "isEmptyString",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "isObject",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "isValidRuleSetObject",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "objectsAreEqual",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "operatorReviverFn",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "ruleSetReviverFn",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "function",
                "linktype": "miscellaneous",
                "linksubtype": "function",
                "name": "ruleSetReviverFn0",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "DEFAULT_QUERY_BUILDER_CONFIG",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "FIELDS_BY_NAME_MAP",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "FIELDS_BY_PATH_FROM_TRANSACTION_MAP",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "MATCH_TYPES",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "MATCH_TYPES_BY_NAME_MAP",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "ExtendedConditionEnum",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "FieldType",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "MatchType",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/query-builder/query-builder.interfaces.ts",
                "type": "type alias",
                "linktype": "miscellaneous",
                "linksubtype": "typealias",
                "name": "RuleSetRulesInner",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/recurrence/recurrence.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "RecurrenceComponent",
                "coveragePercent": 0,
                "coverageCount": "0/10",
                "status": "low"
            },
            {
                "filePath": "src/app/register/register.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "RegisterComponent",
                "coveragePercent": 0,
                "coverageCount": "0/11",
                "status": "low"
            },
            {
                "filePath": "src/app/revenue-expenses-per-period-and-category/context-menu.service.ts",
                "type": "injectable",
                "linktype": "injectable",
                "name": "ContextMenuService",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/revenue-expenses-per-period-and-category/context-menu.service.ts",
                "type": "interface",
                "linktype": "interface",
                "name": "CategoryAndPeriod",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/app/revenue-expenses-per-period-and-category/data.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "dummy",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/app/revenue-expenses-per-period-and-category/revenue-expenses-per-period-and-category.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "RevenueExpensesPerPeriodAndCategoryComponent",
                "coveragePercent": 0,
                "coverageCount": "0/31",
                "status": "low"
            },
            {
                "filePath": "src/app/revenue-expenses/revenue-expenses.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ExpensesRevenueComponent",
                "coveragePercent": 0,
                "coverageCount": "0/23",
                "status": "low"
            },
            {
                "filePath": "src/app/rules-builder/rules-builder.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "RulesBuilderComponent",
                "coveragePercent": 0,
                "coverageCount": "0/9",
                "status": "low"
            },
            {
                "filePath": "src/app/rules-view/rules-view.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "RulesViewComponent",
                "coveragePercent": 0,
                "coverageCount": "0/21",
                "status": "low"
            },
            {
                "filePath": "src/app/rules-view/rules-view.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "RunCategorizationDialogComponent",
                "coveragePercent": 0,
                "coverageCount": "0/5",
                "status": "low"
            },
            {
                "filePath": "src/app/rules-view/rules-view.component.ts",
                "type": "class",
                "linktype": "classe",
                "name": "CategoryTreeWrapper",
                "coveragePercent": 0,
                "coverageCount": "0/4",
                "status": "low"
            },
            {
                "filePath": "src/app/transaction-dialog/transactions-in-context-dialog.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TransactionsInContextDialogComponent",
                "coveragePercent": 0,
                "coverageCount": "0/16",
                "status": "low"
            },
            {
                "filePath": "src/app/transaction-mededelingen-search/transaction-communications-search.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TransactionCommunicationsSearchComponent",
                "coveragePercent": 0,
                "coverageCount": "0/6",
                "status": "low"
            },
            {
                "filePath": "src/app/transaction-search-dialog/transaction-search-dialog.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TransactionSearchDialogComponent",
                "coveragePercent": 0,
                "coverageCount": "0/22",
                "status": "low"
            },
            {
                "filePath": "src/app/transactions/transactions.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TransactionsComponent",
                "coveragePercent": 0,
                "coverageCount": "0/43",
                "status": "low"
            },
            {
                "filePath": "src/app/transactiontype-selection/transactiontype-selection.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "TransactiontypeSelectionComponent",
                "coveragePercent": 8,
                "coverageCount": "1/12",
                "status": "low"
            },
            {
                "filePath": "src/app/uitgaven-per-categorie/expenses-by-category.component.ts",
                "type": "component",
                "linktype": "component",
                "name": "ExpensesByCategoryComponent",
                "coveragePercent": 0,
                "coverageCount": "0/3",
                "status": "low"
            },
            {
                "filePath": "src/environments/environment.prod.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "environment",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            },
            {
                "filePath": "src/environments/environment.ts",
                "type": "variable",
                "linktype": "miscellaneous",
                "linksubtype": "variable",
                "name": "environment",
                "coveragePercent": 0,
                "coverageCount": "0/1",
                "status": "low"
            }
        ]
    }
}